// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};
use web_audio_api::analysis::*;
use web_audio_api::buffer::*;
use web_audio_api::capacity::*;
use web_audio_api::context::concrete_base::*;
use web_audio_api::context::offline::*;
use web_audio_api::context::online::*;
use web_audio_api::context::*;
use web_audio_api::decoding::*;
use web_audio_api::events::*;
use web_audio_api::io::cpal::private::*;
use web_audio_api::io::microphone::*;
use web_audio_api::io::*;
use web_audio_api::media_devices::*;
use web_audio_api::media_element::*;
use web_audio_api::media_recorder::*;
use web_audio_api::media_streams::*;
use web_audio_api::message::*;
use web_audio_api::message_port::*;
use web_audio_api::node::analyser::*;
use web_audio_api::node::audio_buffer_source::*;
use web_audio_api::node::biquad_filter::*;
use web_audio_api::node::channel_merger::*;
use web_audio_api::node::channel_splitter::*;
use web_audio_api::node::constant_source::*;
use web_audio_api::node::convolver::*;
use web_audio_api::node::delay::*;
use web_audio_api::node::destination::*;
use web_audio_api::node::dynamics_compressor::*;
use web_audio_api::node::gain::*;
use web_audio_api::node::iir_filter::*;
use web_audio_api::node::media_element_source::*;
use web_audio_api::node::media_stream_destination::*;
use web_audio_api::node::media_stream_source::*;
use web_audio_api::node::media_stream_track_source::*;
use web_audio_api::node::oscillator::*;
use web_audio_api::node::panner::*;
use web_audio_api::node::script_processor::*;
use web_audio_api::node::stereo_panner::*;
use web_audio_api::node::waveshaper::*;
use web_audio_api::param::*;
use web_audio_api::periodic_wave::*;
use web_audio_api::render::graph::*;
use web_audio_api::render::node_collection::*;
use web_audio_api::render::processor::*;
use web_audio_api::render::quantum::*;
use web_audio_api::render::thread::*;
use web_audio_api::resampling::*;
use web_audio_api::spatial::*;
use web_audio_api::worklet::*;
use web_audio_api::*;

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.37";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -598404409;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__simple__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                Result::<_, ()>::Ok(crate::api::simple::greet(api_name))
            })())
        },
    )
}
fn wire__crate__api__simple__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse(
                    (move || Result::<_, ()>::Ok(crate::api::simple::init_app()))(),
                )
            }
        },
    )
}
fn wire__web_audio_api__AtomicF32_load_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF32_load", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::AtomicF32::load(&api_that, api_ordering))
                    })())
                } })
}
fn wire__web_audio_api__AtomicF32_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AtomicF32_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <f32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::AtomicF32::new(api_value))
                })())
            }
        },
    )
}
fn wire__web_audio_api__AtomicF32_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF32_store", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::AtomicF32::store(&api_that, api_value, api_ordering))
                    })())
                } })
}
fn wire__web_audio_api__AtomicF64_load_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF64_load", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::AtomicF64::load(&api_that, api_ordering))
                    })())
                } })
}
fn wire__web_audio_api__AtomicF64_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AtomicF64_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <f64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::AtomicF64::new(api_value))
                })())
            }
        },
    )
}
fn wire__web_audio_api__AtomicF64_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AtomicF64_store", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);
let api_ordering = <Ordering>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::AtomicF64::store(&api_that, api_value, api_ordering))
                    })())
                } })
}
fn wire__web_audio_api__analysis__AnalyserRingBuffer_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnalyserRingBuffer_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::analysis::AnalyserRingBuffer::new())
                })())
            }
        },
    )
}
fn wire__web_audio_api__analysis__AnalyserRingBuffer_read_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserRingBuffer_read", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_max_len = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::AnalyserRingBuffer::read(&api_that, &mut api_dst, api_max_len))
                    })())
                } })
}
fn wire__web_audio_api__analysis__AnalyserRingBuffer_write_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserRingBuffer_write", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_decode(&mut deserializer);
let api_src = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_src_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_src, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_src_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_src)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_src = api_src_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::AnalyserRingBuffer::write(&api_that, &api_src))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_fft_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_fft_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::fft_size(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_frequency_bin_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_frequency_bin_count", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::frequency_bin_count(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_get_byte_frequency_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_byte_frequency_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>>>::sse_decode(&mut deserializer);
let api_current_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::get_byte_frequency_data(&mut api_that, &mut api_dst, api_current_time))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_get_byte_time_domain_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_byte_time_domain_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::get_byte_time_domain_data(&api_that, &mut api_dst))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_get_float_frequency_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_float_frequency_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_current_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::get_float_frequency_data(&mut api_that, &mut api_dst, api_current_time))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_get_float_time_domain_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_float_time_domain_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_dst = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_dst_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_dst, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_dst_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_dst)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_dst = api_dst_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::get_float_time_domain_data(&api_that, &mut api_dst))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_get_ring_buffer_clone_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_get_ring_buffer_clone", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::get_ring_buffer_clone(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_max_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_max_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::max_decibels(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_min_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_min_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::min_decibels(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Analyser_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::analysis::Analyser::new())
                })())
            }
        },
    )
}
fn wire__web_audio_api__analysis__Analyser_set_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_set_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_min = <f64>::sse_decode(&mut deserializer);
let api_max = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::set_decibels(&mut api_that, api_min, api_max))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_set_fft_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_set_fft_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_fft_size = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::set_fft_size(&mut api_that, api_fft_size))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_set_smoothing_time_constant_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_set_smoothing_time_constant", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::set_smoothing_time_constant(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__analysis__Analyser_smoothing_time_constant_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Analyser_smoothing_time_constant", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::analysis::Analyser::smoothing_time_constant(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__buffer__ChannelData_as_mut_slice_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_as_mut_slice", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::ChannelData::as_mut_slice(&mut api_that))
                    })())
                } })
}
fn wire__web_audio_api__buffer__ChannelData_as_slice_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_as_slice", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::ChannelData::as_slice(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__buffer__ChannelData_from_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelData_from",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<f32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::ChannelData::from(api_data))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__ChannelData_is_empty_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_is_empty", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::ChannelData::is_empty(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__buffer__ChannelData_len_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelData_len", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::ChannelData::len(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__buffer__ChannelData_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelData_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_length = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::ChannelData::new(api_length))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_copy_from_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_buffer_copy_from_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
let api_destination = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_destination_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_destination, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_destination_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_destination)),
                _ => unreachable!(),
            }
        }
        let mut api_destination = api_destination_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::AudioBuffer::copy_from_channel(&api_that, &mut api_destination, api_channel_number))
                    })())
                } })
}
fn wire__web_audio_api__buffer__audio_buffer_copy_from_channel_with_offset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_buffer_copy_from_channel_with_offset", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
let api_destination = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);
let api_offset = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_destination_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_destination, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_destination_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_destination)),
                _ => unreachable!(),
            }
        }
        let mut api_destination = api_destination_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::AudioBuffer::copy_from_channel_with_offset(&api_that, &mut api_destination, api_channel_number, api_offset))
                    })())
                } })
}
fn wire__web_audio_api__buffer__audio_buffer_copy_to_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_buffer_copy_to_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_source = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_source_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_source, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_source_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_source)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_source = api_source_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::AudioBuffer::copy_to_channel(&mut api_that, &api_source, api_channel_number))
                    })())
                } })
}
fn wire__web_audio_api__buffer__audio_buffer_copy_to_channel_with_offset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_buffer_copy_to_channel_with_offset", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_source = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);
let api_offset = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_source_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_source, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_source_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_source)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_source = api_source_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::AudioBuffer::copy_to_channel_with_offset(&mut api_that, &api_source, api_channel_number, api_offset))
                    })())
                } })
}
fn wire__web_audio_api__buffer__audio_buffer_duration_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_duration",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::duration(&api_that))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_from_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_from",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_samples = <Vec<Vec<f32>>>::sse_decode(&mut deserializer);
            let api_sample_rate = <f32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::from(
                        api_samples,
                        api_sample_rate,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_get_channel_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_get_channel_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
            let api_channel_number = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::get_channel_data(
                        &api_that,
                        api_channel_number,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_get_channel_data_mut_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "audio_buffer_get_channel_data_mut", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_decode(&mut deserializer);
let api_channel_number = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::buffer::AudioBuffer::get_channel_data_mut(&mut api_that, api_channel_number))
                    })())
                } })
}
fn wire__web_audio_api__buffer__audio_buffer_length_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_length",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::length(&api_that))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options =
                <web_audio_api::buffer::AudioBufferOptions>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::new(api_options))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_number_of_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_number_of_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::number_of_channels(
                        &api_that,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__buffer__audio_buffer_sample_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "audio_buffer_sample_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::buffer::AudioBuffer::sample_rate(&api_that))
                })())
            }
        },
    )
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_average_load_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioRenderCapacityEvent_get_average_load",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.average_load.clone())
            })())
        },
    )
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioRenderCapacityEvent_get_event",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event.clone())
            })())
        },
    )
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_peak_load_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioRenderCapacityEvent_get_peak_load",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.peak_load.clone())
            })())
        },
    )
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_timestamp_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioRenderCapacityEvent_get_timestamp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.timestamp.clone())
            })())
        },
    )
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_underrun_ratio_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioRenderCapacityEvent_get_underrun_ratio",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.underrun_ratio.clone())
            })())
        },
    )
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_average_load_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacityEvent_set_average_load", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>>>::sse_decode(&mut deserializer);
let api_average_load = <f64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.average_load = api_average_load; })
                })()) })
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacityEvent_set_event", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>>>::sse_decode(&mut deserializer);
let api_event = <Event>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event = api_event; })
                })()) })
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_peak_load_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacityEvent_set_peak_load", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>>>::sse_decode(&mut deserializer);
let api_peak_load = <f64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.peak_load = api_peak_load; })
                })()) })
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_timestamp_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacityEvent_set_timestamp", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>>>::sse_decode(&mut deserializer);
let api_timestamp = <f64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.timestamp = api_timestamp; })
                })()) })
}
fn wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_underrun_ratio_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacityEvent_set_underrun_ratio", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>>>::sse_decode(&mut deserializer);
let api_underrun_ratio = <f64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.underrun_ratio = api_underrun_ratio; })
                })()) })
}
fn wire__web_audio_api__capacity__AudioRenderCapacity_clear_onupdate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacity_clear_onupdate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::capacity::AudioRenderCapacity::clear_onupdate(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__capacity__AudioRenderCapacity_set_onupdate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacity_set_onupdate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::capacity::AudioRenderCapacity::set_onupdate(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__capacity__AudioRenderCapacity_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacity_start", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::capacity::AudioRenderCapacityOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::capacity::AudioRenderCapacity::start(&api_that, api_options))
                    })())
                } })
}
fn wire__web_audio_api__capacity__AudioRenderCapacity_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderCapacity_stop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::capacity::AudioRenderCapacity::stop(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__concrete_base__ConcreteBaseAudioContext_mark_cycle_breaker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConcreteBaseAudioContext_mark_cycle_breaker", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>>>::sse_decode(&mut deserializer);
let api_reg = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_reg_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_reg, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_reg_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_reg)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_reg = api_reg_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::concrete_base::ConcreteBaseAudioContext::mark_cycle_breaker(&api_that, &api_reg))
                    })())
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_clear_oncomplete_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_clear_oncomplete", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::clear_oncomplete(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_length_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_length", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::length(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OfflineAudioContext_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_number_of_channels = <usize>::sse_decode(&mut deserializer);
            let api_length = <usize>::sse_decode(&mut deserializer);
            let api_sample_rate = <f32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::context::offline::OfflineAudioContext::new(
                        api_number_of_channels,
                        api_length,
                        api_sample_rate,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_resume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_resume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::resume(&api_that).await)
                    })().await)
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_set_oncomplete_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_set_oncomplete", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::set_oncomplete(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_start_rendering_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_start_rendering", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::start_rendering(&api_that).await)
                    })().await)
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_start_rendering_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_start_rendering_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::start_rendering_sync(&mut api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_suspend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_suspend", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_suspend_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::suspend(&api_that, api_suspend_time).await)
                    })().await)
                } })
}
fn wire__web_audio_api__context__offline__OfflineAudioContext_suspend_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioContext_suspend_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_suspend_time = <f64>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::offline::OfflineAudioContext::suspend_sync(&mut api_that, api_suspend_time, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_base_latency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_base_latency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::base_latency(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_clear_onsinkchange_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_clear_onsinkchange", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::clear_onsinkchange(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_close_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_close", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::close(&api_that).await)
                    })().await)
                } })
}
fn wire__web_audio_api__context__online__AudioContext_close_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_close_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::close_sync(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_create_media_element_source_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_element_source", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_media_element = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_media_element_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media_element, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_media_element_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_media_element)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let mut api_media_element = api_media_element_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::create_media_element_source(&api_that, &mut api_media_element))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_create_media_stream_destination_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_stream_destination", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::create_media_stream_destination(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_create_media_stream_source_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_stream_source", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_media = <web_audio_api::media_streams::MediaStream>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::create_media_stream_source(&api_that, &api_media))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_create_media_stream_track_source_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_create_media_stream_track_source", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_media = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_media_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_media_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_media)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_media = api_media_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::create_media_stream_track_source(&api_that, &api_media))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioContext_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options = <web_audio_api::context::online::AudioContextOptions>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::context::online::AudioContext::new(
                        api_options,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__context__online__AudioContext_output_latency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_output_latency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::output_latency(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_render_capacity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_render_capacity", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::render_capacity(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_resume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_resume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::resume(&api_that).await)
                    })().await)
                } })
}
fn wire__web_audio_api__context__online__AudioContext_resume_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_resume_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::resume_sync(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_run_diagnostics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_run_diagnostics", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::run_diagnostics(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_set_onsinkchange_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_set_onsinkchange", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::set_onsinkchange(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_set_sink_id_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_set_sink_id_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);
let api_sink_id = <String>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 web_audio_api::context::online::AudioContext::set_sink_id_sync(&api_that, api_sink_id)
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_sink_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_sink_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::sink_id(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__context__online__AudioContext_suspend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_suspend", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_that).await),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::suspend(&api_that).await)
                    })().await)
                } })
}
fn wire__web_audio_api__context__online__AudioContext_suspend_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioContext_suspend_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::AudioContext::suspend_sync(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__decoding__MediaDecoder_try_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaDecoder_try_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_input = <R>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    web_audio_api::decoding::MediaDecoder::try_new(api_input)
                })())
            }
        },
    )
}
fn wire__web_audio_api__decoding__MediaInput_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaInput_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_input = <R>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::decoding::MediaInput::new(api_input))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__ErrorEvent_get_error_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ErrorEvent_get_error",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.error.clone())
            })())
        },
    )
}
fn wire__web_audio_api__events__ErrorEvent_get_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ErrorEvent_get_event",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event.clone())
            })())
        },
    )
}
fn wire__web_audio_api__events__ErrorEvent_get_message_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ErrorEvent_get_message",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.message.clone())
            })())
        },
    )
}
fn wire__web_audio_api__events__ErrorEvent_set_error_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ErrorEvent_set_error", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>>::sse_decode(&mut deserializer);
let api_error = <Box < dyn Any + Send >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.error = api_error; })
                })()) })
}
fn wire__web_audio_api__events__ErrorEvent_set_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ErrorEvent_set_event", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>>::sse_decode(&mut deserializer);
let api_event = <Event>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event = api_event; })
                })()) })
}
fn wire__web_audio_api__events__ErrorEvent_set_message_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ErrorEvent_set_message", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>>::sse_decode(&mut deserializer);
let api_message = <String>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.message = api_message; })
                })()) })
}
fn wire__web_audio_api__events__EventDispatch_audio_processing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_audio_processing",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
            let api_value =
                <web_audio_api::events::AudioProcessingEvent>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::audio_processing(
                        api_id, api_value,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_complete_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_complete",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_buffer = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::complete(api_buffer))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_diagnostics_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_diagnostics",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::diagnostics(
                        api_value,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_ended_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_ended",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::ended(api_id))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
            let api_value = <Box<dyn Any + Send + 'static>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::message(
                        api_id, api_value,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_processor_error_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_processor_error",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
            let api_value = <ErrorEvent>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::processor_error(
                        api_id, api_value,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_render_capacity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_render_capacity",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_value = <AudioRenderCapacityEvent>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::render_capacity(
                        api_value,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_sink_change_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_sink_change",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::sink_change())
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventDispatch_state_change_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventDispatch_state_change",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_state =
                <web_audio_api::context::AudioContextState>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventDispatch::state_change(
                        api_state,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventLoop_clear_handler_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventLoop_clear_handler", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_decode(&mut deserializer);
let api_event = <web_audio_api::events::EventType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::events::EventLoop::clear_handler(&api_that, api_event))
                    })())
                } })
}
fn wire__web_audio_api__events__EventLoop_handle_pending_events_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventLoop_handle_pending_events", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::events::EventLoop::handle_pending_events(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__events__EventLoop_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "EventLoop_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event_recv = <Receiver<EventDispatch>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::events::EventLoop::new(api_event_recv))
                })())
            }
        },
    )
}
fn wire__web_audio_api__events__EventLoop_run_in_thread_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventLoop_run_in_thread", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::events::EventLoop::run_in_thread(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__events__EventLoop_set_handler_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "EventLoop_set_handler", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_decode(&mut deserializer);
let api_event = <web_audio_api::events::EventType>::sse_decode(&mut deserializer);
let api_callback = <EventHandler>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::events::EventLoop::set_handler(&api_that, api_event, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__events__Event_get_type__impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Event_get_type_",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.type_.clone())
            })())
        },
    )
}
fn wire__web_audio_api__events__Event_set_type__impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Event_set_type_", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>>::sse_decode(&mut deserializer);
let api_type_ = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let mut api_type__decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_type_, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_type__decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_type_)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_type_ = api_type__decoded.unwrap();
 Result::<_,()>::Ok({ api_that.type_ = api_type_; })
                })()) })
}
fn wire__web_audio_api__events__OfflineAudioCompletionEvent_get_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OfflineAudioCompletionEvent_get_event",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    OfflineAudioCompletionEvent,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event.clone())
            })())
        },
    )
}
fn wire__web_audio_api__events__OfflineAudioCompletionEvent_get_rendered_buffer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OfflineAudioCompletionEvent_get_rendered_buffer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    OfflineAudioCompletionEvent,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.rendered_buffer.clone())
            })())
        },
    )
}
fn wire__web_audio_api__events__OfflineAudioCompletionEvent_set_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioCompletionEvent_set_event", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>>>::sse_decode(&mut deserializer);
let api_event = <Event>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event = api_event; })
                })()) })
}
fn wire__web_audio_api__events__OfflineAudioCompletionEvent_set_rendered_buffer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OfflineAudioCompletionEvent_set_rendered_buffer", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>>>::sse_decode(&mut deserializer);
let api_rendered_buffer = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.rendered_buffer = api_rendered_buffer; })
                })()) })
}
fn wire__web_audio_api__io__ControlThreadInit_get_ctrl_msg_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ControlThreadInit_get_ctrl_msg_send",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.ctrl_msg_send.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__ControlThreadInit_get_event_recv_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ControlThreadInit_get_event_recv",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event_recv.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__ControlThreadInit_get_event_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ControlThreadInit_get_event_send",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event_send.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__ControlThreadInit_get_frames_played_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ControlThreadInit_get_frames_played",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.frames_played.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__ControlThreadInit_get_load_value_recv_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ControlThreadInit_get_load_value_recv",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.load_value_recv.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__ControlThreadInit_get_state_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ControlThreadInit_get_state",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.state.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__ControlThreadInit_set_ctrl_msg_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ControlThreadInit_set_ctrl_msg_send", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_decode(&mut deserializer);
let api_ctrl_msg_send = <Sender < ControlMessage >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.ctrl_msg_send = api_ctrl_msg_send; })
                })()) })
}
fn wire__web_audio_api__io__ControlThreadInit_set_event_recv_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ControlThreadInit_set_event_recv", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_decode(&mut deserializer);
let api_event_recv = <Receiver < EventDispatch >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event_recv = api_event_recv; })
                })()) })
}
fn wire__web_audio_api__io__ControlThreadInit_set_event_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ControlThreadInit_set_event_send", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_decode(&mut deserializer);
let api_event_send = <Sender < EventDispatch >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event_send = api_event_send; })
                })()) })
}
fn wire__web_audio_api__io__ControlThreadInit_set_frames_played_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ControlThreadInit_set_frames_played", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_decode(&mut deserializer);
let api_frames_played = <Arc < AtomicU64 >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.frames_played = api_frames_played; })
                })()) })
}
fn wire__web_audio_api__io__ControlThreadInit_set_load_value_recv_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ControlThreadInit_set_load_value_recv", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_decode(&mut deserializer);
let api_load_value_recv = <Receiver < AudioRenderCapacityLoad >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.load_value_recv = api_load_value_recv; })
                })()) })
}
fn wire__web_audio_api__io__ControlThreadInit_set_state_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ControlThreadInit_set_state", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_decode(&mut deserializer);
let api_state = <Arc < AtomicU8 >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.state = api_state; })
                })()) })
}
fn wire__web_audio_api__io__RenderThreadInit_get_ctrl_msg_recv_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "RenderThreadInit_get_ctrl_msg_recv",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.ctrl_msg_recv.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__RenderThreadInit_get_event_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "RenderThreadInit_get_event_send",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event_send.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__RenderThreadInit_get_frames_played_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "RenderThreadInit_get_frames_played",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.frames_played.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__RenderThreadInit_get_load_value_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "RenderThreadInit_get_load_value_send",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.load_value_send.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__RenderThreadInit_get_state_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "RenderThreadInit_get_state",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.state.clone())
            })())
        },
    )
}
fn wire__web_audio_api__io__RenderThreadInit_set_ctrl_msg_recv_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThreadInit_set_ctrl_msg_recv", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>>::sse_decode(&mut deserializer);
let api_ctrl_msg_recv = <Receiver < ControlMessage >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.ctrl_msg_recv = api_ctrl_msg_recv; })
                })()) })
}
fn wire__web_audio_api__io__RenderThreadInit_set_event_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThreadInit_set_event_send", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>>::sse_decode(&mut deserializer);
let api_event_send = <Sender < EventDispatch >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event_send = api_event_send; })
                })()) })
}
fn wire__web_audio_api__io__RenderThreadInit_set_frames_played_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThreadInit_set_frames_played", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>>::sse_decode(&mut deserializer);
let api_frames_played = <Arc < AtomicU64 >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.frames_played = api_frames_played; })
                })()) })
}
fn wire__web_audio_api__io__RenderThreadInit_set_load_value_send_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThreadInit_set_load_value_send", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>>::sse_decode(&mut deserializer);
let api_load_value_send = <Sender < AudioRenderCapacityLoad >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.load_value_send = api_load_value_send; })
                })()) })
}
fn wire__web_audio_api__io__RenderThreadInit_set_state_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThreadInit_set_state", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>>::sse_decode(&mut deserializer);
let api_state = <Arc < AtomicU8 >>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.state = api_state; })
                })()) })
}
fn wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_close_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ThreadSafeClosableStream_close", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::io::cpal::private::ThreadSafeClosableStream::close(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ThreadSafeClosableStream_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_stream = <Stream>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(
                        web_audio_api::io::cpal::private::ThreadSafeClosableStream::new(api_stream),
                    )
                })())
            }
        },
    )
}
fn wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_resume_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ThreadSafeClosableStream_resume", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::io::cpal::private::ThreadSafeClosableStream::resume(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_suspend_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ThreadSafeClosableStream_suspend", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::io::cpal::private::ThreadSafeClosableStream::suspend(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__io__microphone__MicrophoneRender_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MicrophoneRender_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_number_of_channels = <usize>::sse_decode(&mut deserializer);
            let api_sample_rate = <f32>::sse_decode(&mut deserializer);
            let api_sender = <Sender<AudioBuffer>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::io::microphone::MicrophoneRender::new(
                        api_number_of_channels,
                        api_sample_rate,
                        api_sender,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__io__microphone__MicrophoneRender_render_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MicrophoneRender_render", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MicrophoneRender>>>::sse_decode(&mut deserializer);
let api_data = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[S]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_data_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_data, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_data_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_data)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_data = api_data_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::io::microphone::MicrophoneRender::render(&api_that, &api_data))
                    })())
                } })
}
fn wire__web_audio_api__media_devices__MediaDeviceInfo_device_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaDeviceInfo_device_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_devices::MediaDeviceInfo::device_id(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_devices__MediaDeviceInfo_group_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaDeviceInfo_group_id", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_devices::MediaDeviceInfo::group_id(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_devices__MediaDeviceInfo_kind_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaDeviceInfo_kind", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_devices::MediaDeviceInfo::kind(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_devices__MediaDeviceInfo_label_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaDeviceInfo_label", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_devices::MediaDeviceInfo::label(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_devices__enumerate_devices_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "enumerate_devices_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::media_devices::enumerate_devices_sync())
                })())
            }
        },
    )
}
fn wire__web_audio_api__media_devices__get_user_media_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_user_media_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_constraints =
                <web_audio_api::media_devices::MediaStreamConstraints>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::media_devices::get_user_media_sync(
                        api_constraints,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__media_element__MediaElement_current_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_current_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::current_time(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_loop__impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_loop_", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::loop_(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaElement_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file = <P>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    web_audio_api::context::online::MediaElement::new(api_file)
                })())
            }
        },
    )
}
fn wire__web_audio_api__media_element__MediaElement_pause_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_pause", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::pause(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_paused_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_paused", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::paused(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_play_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_play", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::play(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_playback_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_playback_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::playback_rate(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_set_current_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_set_current_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::set_current_time(&api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_set_loop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_set_loop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);
let api_value = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::set_loop(&api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__media_element__MediaElement_set_playback_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElement_set_playback_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::context::online::MediaElement::set_playback_rate(&api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__BlobEvent_get_blob_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BlobEvent_get_blob",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.blob.clone())
            })())
        },
    )
}
fn wire__web_audio_api__media_recorder__BlobEvent_get_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BlobEvent_get_event",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.event.clone())
            })())
        },
    )
}
fn wire__web_audio_api__media_recorder__BlobEvent_get_timecode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BlobEvent_get_timecode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.timecode.clone())
            })())
        },
    )
}
fn wire__web_audio_api__media_recorder__BlobEvent_set_blob_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BlobEvent_set_blob", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>>>::sse_decode(&mut deserializer);
let api_blob = <Vec<u8>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.blob = api_blob; })
                })()) })
}
fn wire__web_audio_api__media_recorder__BlobEvent_set_event_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BlobEvent_set_event", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>>>::sse_decode(&mut deserializer);
let api_event = <Event>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.event = api_event; })
                })()) })
}
fn wire__web_audio_api__media_recorder__BlobEvent_set_timecode_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BlobEvent_set_timecode", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>>>::sse_decode(&mut deserializer);
let api_timecode = <f64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.timecode = api_timecode; })
                })()) })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_clear_ondataavailable_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_clear_ondataavailable", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::clear_ondataavailable(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_clear_onerror_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_clear_onerror", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::clear_onerror(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_clear_onstop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_clear_onstop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::clear_onstop(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaRecorder_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_stream =
                <web_audio_api::media_streams::MediaStream>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::media_recorder::MediaRecorder::new(
                        &api_stream,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__media_recorder__MediaRecorder_set_ondataavailable_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_set_ondataavailable", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::set_ondataavailable(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_set_onerror_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_set_onerror", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::set_onerror(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_set_onstop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_set_onstop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::set_onstop(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_start", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::start(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_recorder__MediaRecorder_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaRecorder_stop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_recorder::MediaRecorder::stop(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_streams__MediaStreamTrack_close_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamTrack_close", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_streams::MediaStreamTrack::close(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_streams__MediaStreamTrack_from_iter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaStreamTrack_from_iter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_iter = <T>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::media_streams::MediaStreamTrack::from_iter(
                        api_iter,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__media_streams__MediaStreamTrack_ready_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamTrack_ready_state", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::media_streams::MediaStreamTrack::ready_state(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__media_streams__media_stream_from_tracks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "media_stream_from_tracks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tracks = <Vec<MediaStreamTrack>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::media_streams::MediaStream::from_tracks(
                        api_tracks,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__media_streams__media_stream_get_tracks_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "media_stream_get_tracks",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <web_audio_api::media_streams::MediaStream>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::media_streams::MediaStream::get_tracks(
                        &api_that,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__message__OneshotNotify_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OneshotNotify_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <OneshotNotify>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::message::OneshotNotify::send(api_that))
                })())
            }
        },
    )
}
fn wire__web_audio_api__message_port__MessagePort_clear_onmessage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MessagePort_clear_onmessage", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::message_port::MessagePort::clear_onmessage(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__message_port__MessagePort_post_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MessagePort_post_message", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(&mut deserializer);
let api_msg = <M>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::message_port::MessagePort::post_message(&api_that, api_msg))
                    })())
                } })
}
fn wire__web_audio_api__message_port__MessagePort_set_onmessage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MessagePort_set_onmessage", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::message_port::MessagePort::set_onmessage(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_fft_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_fft_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::fft_size(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_frequency_bin_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_frequency_bin_count", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::frequency_bin_count(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_get_byte_frequency_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_get_byte_frequency_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_buffer = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_buffer_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_buffer, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_buffer_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_buffer)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_buffer = api_buffer_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::get_byte_frequency_data(&mut api_that, &mut api_buffer))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_get_byte_time_domain_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_get_byte_time_domain_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_buffer = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_buffer_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_buffer, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_buffer_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_buffer)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_buffer = api_buffer_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::get_byte_time_domain_data(&mut api_that, &mut api_buffer))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_get_float_frequency_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_get_float_frequency_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_buffer = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_buffer_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_buffer, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_buffer_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_buffer)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_buffer = api_buffer_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::get_float_frequency_data(&mut api_that, &mut api_buffer))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_get_float_time_domain_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_get_float_time_domain_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_buffer = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_buffer_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_buffer, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_buffer_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_buffer)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_buffer = api_buffer_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::get_float_time_domain_data(&mut api_that, &mut api_buffer))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_max_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_max_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::max_decibels(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_min_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_min_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::min_decibels(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::analyser::AnalyserOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_set_fft_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_set_fft_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_fft_size = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::set_fft_size(&mut api_that, api_fft_size))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_set_max_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_set_max_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::set_max_decibels(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_set_min_decibels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_set_min_decibels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::set_min_decibels(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_set_smoothing_time_constant_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_set_smoothing_time_constant", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::set_smoothing_time_constant(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__analyser__AnalyserNode_smoothing_time_constant_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AnalyserNode_smoothing_time_constant", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::analyser::AnalyserNode::smoothing_time_constant(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_buffer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_buffer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::buffer(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_detune_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_detune", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::detune(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_loop__impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_loop_", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::loop_(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_loop_end_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_loop_end", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::loop_end(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_loop_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_loop_start", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::loop_start(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_playback_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_playback_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::playback_rate(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_position_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_position", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::position(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_buffer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_set_buffer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);
let api_audio_buffer = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::set_buffer(&mut api_that, api_audio_buffer))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_loop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_set_loop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);
let api_value = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::set_loop(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_loop_end_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_set_loop_end", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::set_loop_end(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_loop_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_set_loop_start", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::set_loop_start(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_start_at_with_offset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_start_at_with_offset", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);
let api_start = <f64>::sse_decode(&mut deserializer);
let api_offset = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::start_at_with_offset(&mut api_that, api_start, api_offset))
                    })())
                } })
}
fn wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_start_at_with_offset_and_duration_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioBufferSourceNode_start_at_with_offset_and_duration", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>>::sse_decode(&mut deserializer);
let api_start = <f64>::sse_decode(&mut deserializer);
let api_offset = <f64>::sse_decode(&mut deserializer);
let api_duration = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::audio_buffer_source::AudioBufferSourceNode::start_at_with_offset_and_duration(&mut api_that, api_start, api_offset, api_duration))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_detune_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_detune", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::detune(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_frequency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_frequency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::frequency(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_gain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_gain", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::gain(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_get_frequency_response_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_get_frequency_response", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);
let api_frequency_hz = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_mag_response = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_phase_response = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_frequency_hz_decoded = None;
let mut api_mag_response_decoded = None;
let mut api_phase_response_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_frequency_hz, 1, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_mag_response, 2, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_phase_response, 3, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_frequency_hz_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_frequency_hz)),
2 => api_mag_response_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_mag_response)),
3 => api_phase_response_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_phase_response)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_frequency_hz = api_frequency_hz_decoded.unwrap();
let mut api_mag_response = api_mag_response_decoded.unwrap();
let mut api_phase_response = api_phase_response_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::get_frequency_response(&api_that, &api_frequency_hz, &mut api_mag_response, &mut api_phase_response))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::biquad_filter::BiquadFilterOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_q_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_q", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::q(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_set_type_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_set_type", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);
let api_type_ = <web_audio_api::node::biquad_filter::BiquadFilterType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::set_type(&mut api_that, api_type_))
                    })())
                } })
}
fn wire__web_audio_api__node__biquad_filter__BiquadFilterNode_type__impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "BiquadFilterNode_type_", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::biquad_filter::BiquadFilterNode::type_(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__channel_merger__ChannelMergerNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelMergerNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::channel_merger::ChannelMergerOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::channel_merger::ChannelMergerNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__channel_splitter__ChannelSplitterNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelSplitterNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::channel_splitter::ChannelSplitterOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::channel_splitter::ChannelSplitterNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__constant_source__ConstantSourceNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConstantSourceNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::constant_source::ConstantSourceOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::constant_source::ConstantSourceNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__constant_source__ConstantSourceNode_offset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConstantSourceNode_offset", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::constant_source::ConstantSourceNode::offset(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__convolver__ConvolverNode_buffer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConvolverNode_buffer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::convolver::ConvolverNode::buffer(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__convolver__ConvolverNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConvolverNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::convolver::ConvolverOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::convolver::ConvolverNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__convolver__ConvolverNode_normalize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConvolverNode_normalize", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::convolver::ConvolverNode::normalize(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__convolver__ConvolverNode_set_buffer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConvolverNode_set_buffer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>>::sse_decode(&mut deserializer);
let api_buffer = <web_audio_api::buffer::AudioBuffer>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::convolver::ConvolverNode::set_buffer(&mut api_that, api_buffer))
                    })())
                } })
}
fn wire__web_audio_api__node__convolver__ConvolverNode_set_normalize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ConvolverNode_set_normalize", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>>::sse_decode(&mut deserializer);
let api_value = <bool>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::convolver::ConvolverNode::set_normalize(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__delay__DelayNode_delay_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DelayNode_delay_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::delay::DelayNode::delay_time(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__delay__DelayNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DelayNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::delay::DelayOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::delay::DelayNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__destination__AudioDestinationNode_max_channel_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioDestinationNode_max_channel_count", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::destination::AudioDestinationNode::max_channel_count(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_attack_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_attack", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::attack(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_knee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_knee", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::knee(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_ratio_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_ratio", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::ratio(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_reduction_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_reduction", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::reduction(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_release_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_release", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::release(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_threshold_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "DynamicsCompressorNode_threshold", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::dynamics_compressor::DynamicsCompressorNode::threshold(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__gain__GainNode_gain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "GainNode_gain", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::gain::GainNode::gain(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__gain__GainNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "GainNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::gain::GainOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::gain::GainNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__iir_filter__IirFilterNode_get_frequency_response_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "IirFilterNode_get_frequency_response", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>>::sse_decode(&mut deserializer);
let api_frequency_hz = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_mag_response = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_phase_response = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_frequency_hz_decoded = None;
let mut api_mag_response_decoded = None;
let mut api_phase_response_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_frequency_hz, 1, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_mag_response, 2, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_phase_response, 3, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_frequency_hz_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_frequency_hz)),
2 => api_mag_response_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_mag_response)),
3 => api_phase_response_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_phase_response)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_frequency_hz = api_frequency_hz_decoded.unwrap();
let mut api_mag_response = api_mag_response_decoded.unwrap();
let mut api_phase_response = api_phase_response_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::iir_filter::IIRFilterNode::get_frequency_response(&api_that, &api_frequency_hz, &mut api_mag_response, &mut api_phase_response))
                    })())
                } })
}
fn wire__web_audio_api__node__iir_filter__IirFilterNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "IirFilterNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::iir_filter::IIRFilterOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::iir_filter::IIRFilterNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__media_element_source__MediaElementAudioSourceNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElementAudioSourceNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <MediaElementAudioSourceOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::media_element_source::MediaElementAudioSourceNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__media_element_source__MediaElementAudioSourceOptions_get_media_element_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaElementAudioSourceOptions_get_media_element",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    MediaElementAudioSourceOptions,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.media_element.clone())
            })())
        },
    )
}
fn wire__web_audio_api__node__media_element_source__MediaElementAudioSourceOptions_set_media_element_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaElementAudioSourceOptions_set_media_element", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceOptions>>>::sse_decode(&mut deserializer);
let api_media_element = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let mut api_media_element_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media_element, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_media_element_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_media_element)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_media_element = api_media_element_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.media_element = api_media_element; })
                })()) })
}
fn wire__web_audio_api__node__media_stream_destination__MediaStreamAudioDestinationNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamAudioDestinationNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::media_stream_destination::MediaStreamAudioDestinationNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__media_stream_destination__MediaStreamAudioDestinationNode_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamAudioDestinationNode_stream", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::media_stream_destination::MediaStreamAudioDestinationNode::stream(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__media_stream_source__MediaStreamAudioSourceNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamAudioSourceNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <MediaStreamAudioSourceOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::media_stream_source::MediaStreamAudioSourceNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__media_stream_source__MediaStreamAudioSourceOptions_get_media_stream_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaStreamAudioSourceOptions_get_media_stream",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    MediaStreamAudioSourceOptions,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.media_stream.clone())
            })())
        },
    )
}
fn wire__web_audio_api__node__media_stream_source__MediaStreamAudioSourceOptions_set_media_stream_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamAudioSourceOptions_set_media_stream", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceOptions>>>::sse_decode(&mut deserializer);
let api_media_stream = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let mut api_media_stream_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media_stream, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_media_stream_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_media_stream)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_media_stream = api_media_stream_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.media_stream = api_media_stream; })
                })()) })
}
fn wire__web_audio_api__node__media_stream_track_source__MediaStreamTrackAudioSourceNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamTrackAudioSourceNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <MediaStreamTrackAudioSourceOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::media_stream_track_source::MediaStreamTrackAudioSourceNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__media_stream_track_source__MediaStreamTrackAudioSourceOptions_get_media_stream_track_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MediaStreamTrackAudioSourceOptions_get_media_stream_track",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                    MediaStreamTrackAudioSourceOptions,
                >,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.media_stream_track.clone())
            })())
        },
    )
}
fn wire__web_audio_api__node__media_stream_track_source__MediaStreamTrackAudioSourceOptions_set_media_stream_track_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "MediaStreamTrackAudioSourceOptions_set_media_stream_track", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceOptions>>>::sse_decode(&mut deserializer);
let api_media_stream_track = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let mut api_media_stream_track_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_media_stream_track, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_media_stream_track_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_media_stream_track)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_media_stream_track = api_media_stream_track_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.media_stream_track = api_media_stream_track; })
                })()) })
}
fn wire__web_audio_api__node__oscillator__OscillatorNode_detune_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OscillatorNode_detune", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::oscillator::OscillatorNode::detune(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__oscillator__OscillatorNode_frequency_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OscillatorNode_frequency", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::oscillator::OscillatorNode::frequency(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__oscillator__OscillatorNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OscillatorNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::oscillator::OscillatorOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::oscillator::OscillatorNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__oscillator__OscillatorNode_set_periodic_wave_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OscillatorNode_set_periodic_wave", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>>::sse_decode(&mut deserializer);
let api_periodic_wave = <PeriodicWave>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::oscillator::OscillatorNode::set_periodic_wave(&mut api_that, api_periodic_wave))
                    })())
                } })
}
fn wire__web_audio_api__node__oscillator__OscillatorNode_set_type_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OscillatorNode_set_type", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>>::sse_decode(&mut deserializer);
let api_type_ = <web_audio_api::node::oscillator::OscillatorType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::oscillator::OscillatorNode::set_type(&mut api_that, api_type_))
                    })())
                } })
}
fn wire__web_audio_api__node__oscillator__OscillatorNode_type__impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "OscillatorNode_type_", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::oscillator::OscillatorNode::type_(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_cone_inner_angle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_cone_inner_angle", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::cone_inner_angle(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_cone_outer_angle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_cone_outer_angle", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::cone_outer_angle(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_cone_outer_gain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_cone_outer_gain", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::cone_outer_gain(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_distance_model_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_distance_model", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::distance_model(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_max_distance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_max_distance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::max_distance(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::panner::PannerOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_orientation_x_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_orientation_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::orientation_x(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_orientation_y_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_orientation_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::orientation_y(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_orientation_z_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_orientation_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::orientation_z(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_panning_model_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_panning_model", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::panning_model(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_position_x_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_position_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::position_x(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_position_y_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_position_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::position_y(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_position_z_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_position_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::position_z(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_ref_distance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_ref_distance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::ref_distance(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_rolloff_factor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_rolloff_factor", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::rolloff_factor(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_cone_inner_angle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_cone_inner_angle", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_cone_inner_angle(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_cone_outer_angle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_cone_outer_angle", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_cone_outer_angle(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_cone_outer_gain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_cone_outer_gain", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_cone_outer_gain(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_distance_model_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_distance_model", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <web_audio_api::node::panner::DistanceModelType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_distance_model(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_max_distance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_max_distance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_max_distance(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_orientation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_orientation", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_x = <f32>::sse_decode(&mut deserializer);
let api_y = <f32>::sse_decode(&mut deserializer);
let api_z = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_orientation(&api_that, api_x, api_y, api_z))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_panning_model_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_panning_model", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <web_audio_api::node::panner::PanningModelType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_panning_model(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_position_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_position", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_x = <f32>::sse_decode(&mut deserializer);
let api_y = <f32>::sse_decode(&mut deserializer);
let api_z = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_position(&api_that, api_x, api_y, api_z))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_ref_distance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_ref_distance", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_ref_distance(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__panner__PannerNode_set_rolloff_factor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PannerNode_set_rolloff_factor", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_decode(&mut deserializer);
let api_value = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::panner::PannerNode::set_rolloff_factor(&mut api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__node__script_processor__ScriptProcessorNode_buffer_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ScriptProcessorNode_buffer_size", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::script_processor::ScriptProcessorNode::buffer_size(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__script_processor__ScriptProcessorNode_clear_onaudioprocess_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ScriptProcessorNode_clear_onaudioprocess", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::script_processor::ScriptProcessorNode::clear_onaudioprocess(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__script_processor__ScriptProcessorNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ScriptProcessorNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::script_processor::ScriptProcessorOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::script_processor::ScriptProcessorNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__script_processor__ScriptProcessorNode_set_onaudioprocess_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ScriptProcessorNode_set_onaudioprocess", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>>::sse_decode(&mut deserializer);
let api_callback = <F>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::script_processor::ScriptProcessorNode::set_onaudioprocess(&api_that, api_callback))
                    })())
                } })
}
fn wire__web_audio_api__node__stereo_panner__StereoPannerNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "StereoPannerNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::stereo_panner::StereoPannerOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::stereo_panner::StereoPannerNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__stereo_panner__StereoPannerNode_pan_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "StereoPannerNode_pan", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::stereo_panner::StereoPannerNode::pan(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__waveshaper__WaveShaperNode_curve_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WaveShaperNode_curve", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::waveshaper::WaveShaperNode::curve(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__waveshaper__WaveShaperNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WaveShaperNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::node::waveshaper::WaveShaperOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::waveshaper::WaveShaperNode::new(&api_context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__node__waveshaper__WaveShaperNode_oversample_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WaveShaperNode_oversample", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::waveshaper::WaveShaperNode::oversample(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__node__waveshaper__WaveShaperNode_set_curve_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WaveShaperNode_set_curve", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>>::sse_decode(&mut deserializer);
let api_curve = <Vec<f32>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::waveshaper::WaveShaperNode::set_curve(&mut api_that, api_curve))
                    })())
                } })
}
fn wire__web_audio_api__node__waveshaper__WaveShaperNode_set_oversample_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "WaveShaperNode_set_oversample", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>>::sse_decode(&mut deserializer);
let api_oversample = <web_audio_api::node::waveshaper::OverSampleType>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::node::waveshaper::WaveShaperNode::set_oversample(&mut api_that, api_oversample))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_automation_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_automation_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::automation_rate(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_cancel_and_hold_at_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_cancel_and_hold_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_cancel_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::cancel_and_hold_at_time(&api_that, api_cancel_time))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_cancel_scheduled_values_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_cancel_scheduled_values", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_cancel_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::cancel_scheduled_values(&api_that, api_cancel_time))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_default_value_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_default_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::default_value(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_exponential_ramp_to_value_at_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_exponential_ramp_to_value_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_end_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::exponential_ramp_to_value_at_time(&api_that, api_value, api_end_time))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_linear_ramp_to_value_at_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_linear_ramp_to_value_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_end_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::linear_ramp_to_value_at_time(&api_that, api_value, api_end_time))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_max_value_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_max_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::max_value(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_min_value_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_min_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::min_value(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_set_automation_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_automation_rate", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <web_audio_api::param::AutomationRate>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::set_automation_rate(&api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_set_target_at_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_target_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_start_time = <f64>::sse_decode(&mut deserializer);
let api_time_constant = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::set_target_at_time(&api_that, api_value, api_start_time, api_time_constant))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_set_value_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::set_value(&api_that, api_value))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_set_value_at_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_value_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_value = <f32>::sse_decode(&mut deserializer);
let api_start_time = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::set_value_at_time(&api_that, api_value, api_start_time))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_set_value_curve_at_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_set_value_curve_at_time", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);
let api_values = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_decode(&mut deserializer);
let api_start_time = <f64>::sse_decode(&mut deserializer);
let api_duration = <f64>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_values_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_values, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
1 => api_values_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_values)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
let api_values = api_values_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::set_value_curve_at_time(&api_that, &api_values, api_start_time, api_duration))
                    })())
                } })
}
fn wire__web_audio_api__param__AudioParam_value_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioParam_value", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::param::AudioParam::value(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__periodic_wave__PeriodicWave_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "PeriodicWave_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api__context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);
let api_options = <web_audio_api::periodic_wave::PeriodicWaveOptions>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api__context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api__context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api__context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api__context)),
                _ => unreachable!(),
            }
        }
        let api__context = api__context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::periodic_wave::PeriodicWave::new(&api__context, api_options))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_add_edge_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_add_edge", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_source = <(web_audio_api::context::AudioNodeId,usize,)>::sse_decode(&mut deserializer);
let api_dest = <(web_audio_api::context::AudioNodeId,usize,)>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::add_edge(&mut api_that, api_source, api_dest))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_add_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_add_node", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
let api_reclaim_id = <Node>::sse_decode(&mut deserializer);
let api_processor = <Box < dyn AudioProcessor >>::sse_decode(&mut deserializer);
let api_number_of_inputs = <usize>::sse_decode(&mut deserializer);
let api_number_of_outputs = <usize>::sse_decode(&mut deserializer);
let api_channel_config = <web_audio_api::node::audio_node::ChannelConfigInner>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::add_node(&mut api_that, api_index, api_reclaim_id, api_processor, api_number_of_inputs, api_number_of_outputs, api_channel_config))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_before_drop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_before_drop", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_scope = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_scope_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_scope, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_scope_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_scope)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_scope = api_scope_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::before_drop(&mut api_that, &api_scope))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_is_active_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_is_active", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::is_active(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_mark_control_handle_dropped_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_mark_control_handle_dropped", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::mark_control_handle_dropped(&mut api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_mark_cycle_breaker_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_mark_cycle_breaker", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::mark_cycle_breaker(&mut api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Graph_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_reclaim_id_channel =
                <llq::Producer<AudioNodeId>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::render::graph::Graph::new(
                        api_reclaim_id_channel,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__graph__Graph_remove_edge_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_remove_edge", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_source = <(web_audio_api::context::AudioNodeId,usize,)>::sse_decode(&mut deserializer);
let api_dest = <(web_audio_api::context::AudioNodeId,usize,)>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::remove_edge(&mut api_that, api_source, api_dest))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_render_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_render", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_scope = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_scope_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_scope, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_scope_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_scope)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let api_scope = api_scope_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::render(&mut api_that, &api_scope))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_route_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_route_message", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
let api_msg = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<dyn Any>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_msg_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_msg, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_msg_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_msg)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_msg = api_msg_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::route_message(&mut api_that, api_index, &mut api_msg))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_set_channel_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_set_channel_count", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
let api_v = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::set_channel_count(&mut api_that, api_index, api_v))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_set_channel_count_mode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_set_channel_count_mode", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
let api_v = <web_audio_api::node::audio_node::ChannelCountMode>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::set_channel_count_mode(&mut api_that, api_index, api_v))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Graph_set_channel_interpretation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Graph_set_channel_interpretation", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
let api_v = <web_audio_api::node::audio_node::ChannelInterpretation>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Graph::set_channel_interpretation(&mut api_that, api_index, api_v))
                    })())
                } })
}
fn wire__web_audio_api__render__graph__Node_get_buffer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Node_get_buffer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::graph::Node::get_buffer(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__node_collection__node_collection_contains_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "node_collection_contains",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::render::node_collection::NodeCollection>::sse_decode(
                &mut deserializer,
            );
            let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(
                        web_audio_api::render::node_collection::NodeCollection::contains(
                            &api_that, api_index,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__node_collection__node_collection_get_mut_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "node_collection_get_mut", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::node_collection::NodeCollection::get_mut(&mut api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__node_collection__node_collection_get_unchecked_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "node_collection_get_unchecked",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::render::node_collection::NodeCollection>::sse_decode(
                &mut deserializer,
            );
            let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(
                        web_audio_api::render::node_collection::NodeCollection::get_unchecked(
                            &api_that, api_index,
                        ),
                    )
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__node_collection__node_collection_get_unchecked_mut_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "node_collection_get_unchecked_mut", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::node_collection::NodeCollection::get_unchecked_mut(&mut api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__node_collection__node_collection_insert_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "node_collection_insert", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);
let api_value = <RefCell < Node >>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::node_collection::NodeCollection::insert(&mut api_that, api_index, api_value))
                    })())
                } })
}
fn wire__web_audio_api__render__node_collection__node_collection_is_empty_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "node_collection_is_empty",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <web_audio_api::render::node_collection::NodeCollection>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(
                        web_audio_api::render::node_collection::NodeCollection::is_empty(&api_that),
                    )
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__node_collection__node_collection_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "node_collection_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(
                        web_audio_api::render::node_collection::NodeCollection::new(),
                    )
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__node_collection__node_collection_remove_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "node_collection_remove", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>>>::sse_decode(&mut deserializer);
let api_index = <web_audio_api::context::AudioNodeId>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::node_collection::NodeCollection::remove(&mut api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_get_current_frame_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletGlobalScope_get_current_frame",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.current_frame.clone())
            })())
        },
    )
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_get_current_time_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletGlobalScope_get_current_time",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.current_time.clone())
            })())
        },
    )
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_get_sample_rate_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletGlobalScope_get_sample_rate",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.sample_rate.clone())
            })())
        },
    )
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_post_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletGlobalScope_post_message", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>>>::sse_decode(&mut deserializer);
let api_msg = <Box < dyn Any + Send + 'static >>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::processor::AudioWorkletGlobalScope::post_message(&api_that, api_msg))
                    })())
                } })
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_set_current_frame_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletGlobalScope_set_current_frame", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>>>::sse_decode(&mut deserializer);
let api_current_frame = <u64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.current_frame = api_current_frame; })
                })()) })
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_set_current_time_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletGlobalScope_set_current_time", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>>>::sse_decode(&mut deserializer);
let api_current_time = <f64>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.current_time = api_current_time; })
                })()) })
}
fn wire__web_audio_api__render__processor__AudioWorkletGlobalScope_set_sample_rate_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletGlobalScope_set_sample_rate", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>>>::sse_decode(&mut deserializer);
let api_sample_rate = <f32>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.sample_rate = api_sample_rate; })
                })()) })
}
fn wire__web_audio_api__render__quantum__Alloc_silence_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Alloc_silence", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::Alloc::silence(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__Alloc_with_capacity_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Alloc_with_capacity",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_n = <usize>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::render::quantum::Alloc::with_capacity(api_n))
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_channel_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_channel_data", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);
let api_index = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::channel_data(&api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_channel_data_mut_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_channel_data_mut", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);
let api_index = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::channel_data_mut(&mut api_that, api_index))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_channels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::channels(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_channels_mut_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_channels_mut", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::channels_mut(&mut api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_is_silent_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_is_silent", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::is_silent(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_make_silent_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_make_silent", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::make_silent(&mut api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_number_of_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_number_of_channels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::number_of_channels(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__render__quantum__AudioRenderQuantum_set_number_of_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioRenderQuantum_set_number_of_channels", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_decode(&mut deserializer);
let api_n = <usize>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::quantum::AudioRenderQuantum::set_number_of_channels(&mut api_that, api_n))
                    })())
                } })
}
fn wire__web_audio_api__render__thread__RenderThread_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "RenderThread_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sample_rate = <f32>::sse_decode(&mut deserializer);
            let api_number_of_channels = <usize>::sse_decode(&mut deserializer);
            let api_receiver = <Receiver<ControlMessage>>::sse_decode(&mut deserializer);
            let api_state = <Arc<AtomicU8>>::sse_decode(&mut deserializer);
            let api_frames_played = <Arc<AtomicU64>>::sse_decode(&mut deserializer);
            let api_event_sender = <Sender<EventDispatch>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::render::thread::RenderThread::new(
                        api_sample_rate,
                        api_number_of_channels,
                        api_receiver,
                        api_state,
                        api_frames_played,
                        api_event_sender,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__render__thread__RenderThread_render_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThread_render", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThread>>>::sse_decode(&mut deserializer);
let api_output_buffer = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[S]>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let mut api_output_buffer_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_output_buffer, 1, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
1 => api_output_buffer_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_output_buffer)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
let mut api_output_buffer = api_output_buffer_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::thread::RenderThread::render(&mut api_that, &mut api_output_buffer))
                    })())
                } })
}
fn wire__web_audio_api__render__thread__RenderThread_render_audiobuffer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec,_,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThread_render_audiobuffer", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RenderThread>::sse_decode(&mut deserializer);
let api_length = <usize>::sse_decode(&mut deserializer);
let api_suspend_callbacks = <Vec<(usize,oneshot :: Sender < () >,)>>::sse_decode(&mut deserializer);
let api_resume_receiver = <mpsc :: Receiver < () >>::sse_decode(&mut deserializer);
let api_event_loop = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_decode(&mut deserializer);deserializer.end(); move |context| async move {
                    transform_result_sse((move || async move {
                        let mut api_event_loop_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_event_loop, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_event_loop_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_async_ref(&api_event_loop).await),
                _ => unreachable!(),
            }
        }
        let api_event_loop = api_event_loop_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::thread::RenderThread::render_audiobuffer(api_that, api_length, api_suspend_callbacks, api_resume_receiver, &api_event_loop).await)
                    })().await)
                } })
}
fn wire__web_audio_api__render__thread__RenderThread_render_audiobuffer_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "RenderThread_render_audiobuffer_sync", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RenderThread>::sse_decode(&mut deserializer);
let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_decode(&mut deserializer);
let api_suspend_callbacks = <Vec<(usize,Box < dyn FnOnce (& mut OfflineAudioContext) + Send + Sync + 'static >,)>>::sse_decode(&mut deserializer);
let api_event_loop = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let mut api_event_loop_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, true), flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_event_loop, 1, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_context)),
1 => api_event_loop_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_event_loop)),
                _ => unreachable!(),
            }
        }
        let mut api_context = api_context_decoded.unwrap();
let api_event_loop = api_event_loop_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::render::thread::RenderThread::render_audiobuffer_sync(api_that, &mut api_context, api_suspend_callbacks, &api_event_loop))
                    })())
                } })
}
fn wire__web_audio_api__resampling__Resampler_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Resampler_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sample_rate = <f32>::sse_decode(&mut deserializer);
            let api_sample_len = <usize>::sse_decode(&mut deserializer);
            let api_input = <M>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::resampling::Resampler::new(
                        api_sample_rate,
                        api_sample_len,
                        api_input,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerNode_into_fields_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerNode_into_fields",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <AudioListenerNode>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::spatial::AudioListenerNode::into_fields(
                        api_that,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerNode_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerNode_new", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_context = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_context_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_context, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_context_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_context)),
                _ => unreachable!(),
            }
        }
        let api_context = api_context_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListenerNode::new(&api_context))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_forward_x_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_forward_x",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.forward_x.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_forward_y_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_forward_y",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.forward_y.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_forward_z_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_forward_z",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.forward_z.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_position_x_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_position_x",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.position_x.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_position_y_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_position_y",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.position_y.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_position_z_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_position_z",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.position_z.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_up_x_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_up_x",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.up_x.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_up_y_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_up_y",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.up_y.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_get_up_z_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioListenerParams_get_up_z",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.up_z.clone())
            })())
        },
    )
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_forward_x_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_forward_x", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_forward_x = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.forward_x = api_forward_x; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_forward_y_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_forward_y", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_forward_y = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.forward_y = api_forward_y; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_forward_z_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_forward_z", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_forward_z = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.forward_z = api_forward_z; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_position_x_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_position_x", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_position_x = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.position_x = api_position_x; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_position_y_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_position_y", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_position_y = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.position_y = api_position_y; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_position_z_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_position_z", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_position_z = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.position_z = api_position_z; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_up_x_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_up_x", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_up_x = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.up_x = api_up_x; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_up_y_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_up_y", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_up_y = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.up_y = api_up_y; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListenerParams_set_up_z_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListenerParams_set_up_z", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_decode(&mut deserializer);
let api_up_z = <AudioParamInner>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.up_z = api_up_z; })
                })()) })
}
fn wire__web_audio_api__spatial__AudioListener_forward_x_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_forward_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::forward_x(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_forward_y_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_forward_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::forward_y(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_forward_z_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_forward_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::forward_z(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_position_x_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_position_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::position_x(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_position_y_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_position_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::position_y(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_position_z_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_position_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::position_z(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_up_x_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_up_x", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::up_x(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_up_y_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_up_y", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::up_y(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__AudioListener_up_z_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioListener_up_z", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::spatial::AudioListener::up_z(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__spatial__angle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "angle",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source_position = <Vector3<f32>>::sse_decode(&mut deserializer);
            let api_source_orientation = <Vector3<f32>>::sse_decode(&mut deserializer);
            let api_listener_position = <Vector3<f32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::spatial::angle(
                        api_source_position,
                        api_source_orientation,
                        api_listener_position,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__spatial__azimuth_and_elevation_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "azimuth_and_elevation",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source_position = <Vector3<f32>>::sse_decode(&mut deserializer);
            let api_listener_position = <Vector3<f32>>::sse_decode(&mut deserializer);
            let api_listener_forward = <Vector3<f32>>::sse_decode(&mut deserializer);
            let api_listener_up = <Vector3<f32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::spatial::azimuth_and_elevation(
                        api_source_position,
                        api_listener_position,
                        api_listener_forward,
                        api_listener_up,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__spatial__distance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "distance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source_position = <Vector3<f32>>::sse_decode(&mut deserializer);
            let api_listener_position = <Vector3<f32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse((move || {
                    Result::<_, ()>::Ok(web_audio_api::spatial::distance(
                        api_source_position,
                        api_listener_position,
                    ))
                })())
            }
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_audio_node_options_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletNodeOptions_get_audio_node_options",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.audio_node_options.clone())
            })())
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_number_of_inputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletNodeOptions_get_number_of_inputs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.number_of_inputs.clone())
            })())
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_number_of_outputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletNodeOptions_get_number_of_outputs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.number_of_outputs.clone())
            })())
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_output_channel_count_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletNodeOptions_get_output_channel_count",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.output_channel_count.clone())
            })())
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_parameter_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletNodeOptions_get_parameter_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.parameter_data.clone())
            })())
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_processor_options_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AudioWorkletNodeOptions_get_processor_options",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse((move || {
                let mut api_that_decoded = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(
                        vec![
                            flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(
                                &api_that, 0, false,
                            ),
                        ],
                    );
                for i in decode_indices_ {
                    match i {
                        0 => api_that_decoded = Some(
                            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(
                                &api_that,
                            ),
                        ),
                        _ => unreachable!(),
                    }
                }
                let api_that = api_that_decoded.unwrap();
                Result::<_, ()>::Ok(api_that.processor_options.clone())
            })())
        },
    )
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_audio_node_options_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNodeOptions_set_audio_node_options", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>>>::sse_decode(&mut deserializer);
let api_audio_node_options = <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.audio_node_options = api_audio_node_options; })
                })()) })
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_number_of_inputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNodeOptions_set_number_of_inputs", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>>>::sse_decode(&mut deserializer);
let api_number_of_inputs = <usize>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.number_of_inputs = api_number_of_inputs; })
                })()) })
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_number_of_outputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNodeOptions_set_number_of_outputs", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>>>::sse_decode(&mut deserializer);
let api_number_of_outputs = <usize>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.number_of_outputs = api_number_of_outputs; })
                })()) })
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_output_channel_count_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNodeOptions_set_output_channel_count", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>>>::sse_decode(&mut deserializer);
let api_output_channel_count = <Vec<usize>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.output_channel_count = api_output_channel_count; })
                })()) })
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_parameter_data_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNodeOptions_set_parameter_data", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>>>::sse_decode(&mut deserializer);
let api_parameter_data = <std::collections::HashMap<String, f64>>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.parameter_data = api_parameter_data; })
                })()) })
}
fn wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_processor_options_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNodeOptions_set_processor_options", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>>>::sse_decode(&mut deserializer);
let api_processor_options = <C>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse((move || {
                    let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref_mut(&api_that)),
                _ => unreachable!(),
            }
        }
        let mut api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok({ api_that.processor_options = api_processor_options; })
                })()) })
}
fn wire__web_audio_api__worklet__AudioWorkletNode_parameters_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNode_parameters", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::worklet::AudioWorkletNode::parameters(&api_that))
                    })())
                } })
}
fn wire__web_audio_api__worklet__AudioWorkletNode_port_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "AudioWorkletNode_port", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>>>::sse_decode(&mut deserializer);deserializer.end(); move |context|  {
                    transform_result_sse((move ||  {
                        let mut api_that_decoded = None;
let decode_indices_ = flutter_rust_bridge::for_generated::rust_auto_opaque_decode_compute_order(vec![flutter_rust_bridge::for_generated::rust_auto_opaque_lock_order_info(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_decoded = Some(flutter_rust_bridge::for_generated::rust_auto_opaque_decode_sync_ref(&api_that)),
                _ => unreachable!(),
            }
        }
        let api_that = api_that_decoded.unwrap();
 Result::<_,()>::Ok(web_audio_api::worklet::AudioWorkletNode::port(&api_that))
                    })())
                } })
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU64>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU8>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParamInner>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send + 'static>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn AudioProcessor>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Error>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
        Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
    >
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
        Box<dyn std::error::Error + Send + Sync>,
    >
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventDispatch>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventHandler>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HashMap<String, AudioParam>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceOptions>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceOptions>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceOptions>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MicrophoneRender>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<AudioRenderCapacityLoad>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<ControlMessage>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<EventDispatch>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThread>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[S]>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioBuffer>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioRenderCapacityLoad>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<ControlMessage>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<EventDispatch>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stream>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<T>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3<f32>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<dyn Any>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<llq::Producer<AudioNodeId>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<mpsc::Receiver<()>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<oneshot::Sender<()>>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>
);

// Section: dart2rust

impl SseDecode for Alloc {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Analyser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AnalyserNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AnalyserRingBuffer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Arc<AtomicU64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU64>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Arc<AtomicU8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU8>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AtomicF32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AtomicF64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioBufferSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioDestinationNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioListener {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioListenerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioListenerParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioParam {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioParamInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParamInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioRenderCapacity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioRenderCapacityEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioRenderQuantum {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioRenderQuantumChannel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioWorkletGlobalScope {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioWorkletNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AudioWorkletNodeOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BiquadFilterNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BlobEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Box<dyn Any + Send> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Box<dyn Any + Send + 'static> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send + 'static>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Box<dyn AudioProcessor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn AudioProcessor>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Box<dyn Error> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Error>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Box<dyn std::error::Error + Send + Sync> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Box<dyn std::error::Error + Send + Sync>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for C {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_decode(
                deserializer,
            );
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelMergerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelSplitterNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConcreteBaseAudioContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConstantSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ControlThreadInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConvolverNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for DelayNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for DynamicsCompressorNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ErrorEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EventDispatch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventDispatch>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EventHandler {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventHandler>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EventLoop {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for F {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>>>::sse_decode(
                deserializer,
            );
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GainNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Graph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for IIRFilterNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for M {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>>>::sse_decode(
                deserializer,
            );
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaDecoder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaElement {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaElementAudioSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaElementAudioSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceOptions>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaRecorder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaStreamAudioDestinationNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                MediaStreamAudioDestinationNode,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaStreamAudioSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaStreamAudioSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceOptions>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaStreamTrackAudioSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                MediaStreamTrackAudioSourceNode,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MediaStreamTrackAudioSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                MediaStreamTrackAudioSourceOptions,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MessagePort {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MicrophoneRender {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MicrophoneRender>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OfflineAudioCompletionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OfflineAudioContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OneshotNotify {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Ordering {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OscillatorNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for P {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>>>::sse_decode(
                deserializer,
            );
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PannerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PeriodicWave {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for R {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>>>::sse_decode(
                deserializer,
            );
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Receiver<AudioRenderCapacityLoad> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Receiver<AudioRenderCapacityLoad>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Receiver<ControlMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<ControlMessage>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Receiver<EventDispatch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<EventDispatch>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for RefCell<Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for RenderThread {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThread>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for RenderThreadInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Resampler {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ScriptProcessorNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Sender<AudioBuffer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioBuffer>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Sender<AudioRenderCapacityLoad> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Sender<AudioRenderCapacityLoad>,
            >,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Sender<ControlMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<ControlMessage>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Sender<EventDispatch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<EventDispatch>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for StereoPannerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Stream {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stream>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for T {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner =
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<T>>>::sse_decode(
                deserializer,
            );
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ThreadSafeClosableStream {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Vector3<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3<f32>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for WaveShaperNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for llq::Producer<AudioNodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<llq::Producer<AudioNodeId>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for mpsc::Receiver<()> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<mpsc::Receiver<()>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for oneshot::Sender<()> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<oneshot::Sender<()>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, f64)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU64>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU8>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParamInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send + 'static>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn AudioProcessor>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Error>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            Box<dyn std::error::Error + Send + Sync>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventDispatch>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventHandler>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HashMap<String, AudioParam>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MicrophoneRender>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<AudioRenderCapacityLoad>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<ControlMessage>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<EventDispatch>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThread>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[S]>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioBuffer>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioRenderCapacityLoad>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<ControlMessage>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<EventDispatch>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stream>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<T>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3<f32>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<dyn Any>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<llq::Producer<AudioNodeId>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<mpsc::Receiver<()>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<oneshot::Sender<()>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for web_audio_api::node::analyser::AnalyserOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fftSize = <usize>::sse_decode(deserializer);
        let mut var_maxDecibels = <f64>::sse_decode(deserializer);
        let mut var_minDecibels = <f64>::sse_decode(deserializer);
        let mut var_smoothingTimeConstant = <f64>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::analyser::AnalyserOptions {
            fft_size: var_fftSize,
            max_decibels: var_maxDecibels,
            min_decibels: var_minDecibels,
            smoothing_time_constant: var_smoothingTimeConstant,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::buffer::AudioBuffer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channels = <Vec<ChannelData>>::sse_decode(deserializer);
        let mut var_sampleRate = <f32>::sse_decode(deserializer);
        return web_audio_api::buffer::AudioBuffer {
            channels: var_channels,
            sample_rate: var_sampleRate,
        };
    }
}

impl SseDecode for web_audio_api::buffer::AudioBufferOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_numberOfChannels = <usize>::sse_decode(deserializer);
        let mut var_length = <usize>::sse_decode(deserializer);
        let mut var_sampleRate = <f32>::sse_decode(deserializer);
        return web_audio_api::buffer::AudioBufferOptions {
            number_of_channels: var_numberOfChannels,
            length: var_length,
            sample_rate: var_sampleRate,
        };
    }
}

impl SseDecode for web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_buffer = <Option<web_audio_api::buffer::AudioBuffer>>::sse_decode(deserializer);
        let mut var_detune = <f32>::sse_decode(deserializer);
        let mut var_loop = <bool>::sse_decode(deserializer);
        let mut var_loopStart = <f64>::sse_decode(deserializer);
        let mut var_loopEnd = <f64>::sse_decode(deserializer);
        let mut var_playbackRate = <f32>::sse_decode(deserializer);
        return web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions {
            buffer: var_buffer,
            detune: var_detune,
            loop_: var_loop,
            loop_start: var_loopStart,
            loop_end: var_loopEnd,
            playback_rate: var_playbackRate,
        };
    }
}

impl SseDecode for web_audio_api::context::online::AudioContextLatencyCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return web_audio_api::context::online::AudioContextLatencyCategory::Balanced;
            }
            1 => {
                return web_audio_api::context::online::AudioContextLatencyCategory::Interactive;
            }
            2 => {
                return web_audio_api::context::online::AudioContextLatencyCategory::Playback;
            }
            3 => {
                let mut var_field0 = <f64>::sse_decode(deserializer);
                return web_audio_api::context::online::AudioContextLatencyCategory::Custom(
                    var_field0,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for web_audio_api::context::online::AudioContextOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_latencyHint =
            <web_audio_api::context::online::AudioContextLatencyCategory>::sse_decode(deserializer);
        let mut var_sampleRate = <Option<f32>>::sse_decode(deserializer);
        let mut var_sinkId = <String>::sse_decode(deserializer);
        let mut var_renderSizeHint =
            <web_audio_api::context::online::AudioContextRenderSizeCategory>::sse_decode(
                deserializer,
            );
        return web_audio_api::context::online::AudioContextOptions {
            latency_hint: var_latencyHint,
            sample_rate: var_sampleRate,
            sink_id: var_sinkId,
            render_size_hint: var_renderSizeHint,
        };
    }
}

impl SseDecode for web_audio_api::context::online::AudioContextRenderSizeCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::context::online::AudioContextRenderSizeCategory::Default,
            _ => unreachable!(
                "Invalid variant for AudioContextRenderSizeCategory: {}",
                inner
            ),
        };
    }
}

impl SseDecode for web_audio_api::context::AudioContextState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::context::AudioContextState::Suspended,
            1 => web_audio_api::context::AudioContextState::Running,
            2 => web_audio_api::context::AudioContextState::Closed,
            _ => unreachable!("Invalid variant for AudioContextState: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::context::AudioNodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <u64>::sse_decode(deserializer);
        return web_audio_api::context::AudioNodeId(var_field0);
    }
}

impl SseDecode for web_audio_api::node::audio_node::AudioNodeOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channelCount = <usize>::sse_decode(deserializer);
        let mut var_channelCountMode =
            <web_audio_api::node::audio_node::ChannelCountMode>::sse_decode(deserializer);
        let mut var_channelInterpretation =
            <web_audio_api::node::audio_node::ChannelInterpretation>::sse_decode(deserializer);
        return web_audio_api::node::audio_node::AudioNodeOptions {
            channel_count: var_channelCount,
            channel_count_mode: var_channelCountMode,
            channel_interpretation: var_channelInterpretation,
        };
    }
}

impl SseDecode for web_audio_api::events::AudioProcessingEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inputBuffer = <web_audio_api::buffer::AudioBuffer>::sse_decode(deserializer);
        let mut var_outputBuffer = <web_audio_api::buffer::AudioBuffer>::sse_decode(deserializer);
        let mut var_playbackTime = <f64>::sse_decode(deserializer);
        let mut var_registration = <Option<(
            ConcreteBaseAudioContext,
            web_audio_api::context::AudioNodeId,
        )>>::sse_decode(deserializer);
        return web_audio_api::events::AudioProcessingEvent {
            input_buffer: var_inputBuffer,
            output_buffer: var_outputBuffer,
            playback_time: var_playbackTime,
            registration: var_registration,
        };
    }
}

impl SseDecode for web_audio_api::capacity::AudioRenderCapacityOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_updateInterval = <f64>::sse_decode(deserializer);
        return web_audio_api::capacity::AudioRenderCapacityOptions {
            update_interval: var_updateInterval,
        };
    }
}

impl SseDecode for web_audio_api::param::AutomationRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::param::AutomationRate::A,
            1 => web_audio_api::param::AutomationRate::K,
            _ => unreachable!("Invalid variant for AutomationRate: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::node::biquad_filter::BiquadFilterOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_q = <f32>::sse_decode(deserializer);
        let mut var_detune = <f32>::sse_decode(deserializer);
        let mut var_frequency = <f32>::sse_decode(deserializer);
        let mut var_gain = <f32>::sse_decode(deserializer);
        let mut var_type =
            <web_audio_api::node::biquad_filter::BiquadFilterType>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::biquad_filter::BiquadFilterOptions {
            q: var_q,
            detune: var_detune,
            frequency: var_frequency,
            gain: var_gain,
            type_: var_type,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::biquad_filter::BiquadFilterType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::biquad_filter::BiquadFilterType::Lowpass,
            1 => web_audio_api::node::biquad_filter::BiquadFilterType::Highpass,
            2 => web_audio_api::node::biquad_filter::BiquadFilterType::Bandpass,
            3 => web_audio_api::node::biquad_filter::BiquadFilterType::Notch,
            4 => web_audio_api::node::biquad_filter::BiquadFilterType::Allpass,
            5 => web_audio_api::node::biquad_filter::BiquadFilterType::Peaking,
            6 => web_audio_api::node::biquad_filter::BiquadFilterType::Lowshelf,
            7 => web_audio_api::node::biquad_filter::BiquadFilterType::Highshelf,
            _ => unreachable!("Invalid variant for BiquadFilterType: {}", inner),
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for web_audio_api::node::audio_node::ChannelConfigInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_count = <usize>::sse_decode(deserializer);
        let mut var_countMode =
            <web_audio_api::node::audio_node::ChannelCountMode>::sse_decode(deserializer);
        let mut var_interpretation =
            <web_audio_api::node::audio_node::ChannelInterpretation>::sse_decode(deserializer);
        return web_audio_api::node::audio_node::ChannelConfigInner {
            count: var_count,
            count_mode: var_countMode,
            interpretation: var_interpretation,
        };
    }
}

impl SseDecode for web_audio_api::node::audio_node::ChannelCountMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::audio_node::ChannelCountMode::Max,
            1 => web_audio_api::node::audio_node::ChannelCountMode::ClampedMax,
            2 => web_audio_api::node::audio_node::ChannelCountMode::Explicit,
            _ => unreachable!("Invalid variant for ChannelCountMode: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::node::audio_node::ChannelInterpretation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::audio_node::ChannelInterpretation::Speakers,
            1 => web_audio_api::node::audio_node::ChannelInterpretation::Discrete,
            _ => unreachable!("Invalid variant for ChannelInterpretation: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::node::channel_merger::ChannelMergerOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_numberOfInputs = <usize>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::channel_merger::ChannelMergerOptions {
            number_of_inputs: var_numberOfInputs,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::channel_splitter::ChannelSplitterOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_numberOfOutputs = <usize>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::channel_splitter::ChannelSplitterOptions {
            number_of_outputs: var_numberOfOutputs,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::constant_source::ConstantSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_offset = <f32>::sse_decode(deserializer);
        return web_audio_api::node::constant_source::ConstantSourceOptions { offset: var_offset };
    }
}

impl SseDecode for web_audio_api::node::convolver::ConvolverOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_buffer = <Option<web_audio_api::buffer::AudioBuffer>>::sse_decode(deserializer);
        let mut var_disableNormalization = <bool>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::convolver::ConvolverOptions {
            buffer: var_buffer,
            disable_normalization: var_disableNormalization,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::delay::DelayOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxDelayTime = <f64>::sse_decode(deserializer);
        let mut var_delayTime = <f64>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::delay::DelayOptions {
            max_delay_time: var_maxDelayTime,
            delay_time: var_delayTime,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::panner::DistanceModelType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::panner::DistanceModelType::Linear,
            1 => web_audio_api::node::panner::DistanceModelType::Inverse,
            2 => web_audio_api::node::panner::DistanceModelType::Exponential,
            _ => unreachable!("Invalid variant for DistanceModelType: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_attack = <f32>::sse_decode(deserializer);
        let mut var_knee = <f32>::sse_decode(deserializer);
        let mut var_ratio = <f32>::sse_decode(deserializer);
        let mut var_release = <f32>::sse_decode(deserializer);
        let mut var_threshold = <f32>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions {
            attack: var_attack,
            knee: var_knee,
            ratio: var_ratio,
            release: var_release,
            threshold: var_threshold,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::events::EventType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <web_audio_api::context::AudioNodeId>::sse_decode(deserializer);
                return web_audio_api::events::EventType::Ended(var_field0);
            }
            1 => {
                return web_audio_api::events::EventType::SinkChange;
            }
            2 => {
                return web_audio_api::events::EventType::StateChange;
            }
            3 => {
                return web_audio_api::events::EventType::RenderCapacity;
            }
            4 => {
                let mut var_field0 =
                    <web_audio_api::context::AudioNodeId>::sse_decode(deserializer);
                return web_audio_api::events::EventType::ProcessorError(var_field0);
            }
            5 => {
                return web_audio_api::events::EventType::Diagnostics;
            }
            6 => {
                let mut var_field0 =
                    <web_audio_api::context::AudioNodeId>::sse_decode(deserializer);
                return web_audio_api::events::EventType::Message(var_field0);
            }
            7 => {
                return web_audio_api::events::EventType::Complete;
            }
            8 => {
                let mut var_field0 =
                    <web_audio_api::context::AudioNodeId>::sse_decode(deserializer);
                return web_audio_api::events::EventType::AudioProcessing(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for web_audio_api::node::gain::GainOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_gain = <f32>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::gain::GainOptions {
            gain: var_gain,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for web_audio_api::node::iir_filter::IIRFilterOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        let mut var_feedforward = <Vec<f64>>::sse_decode(deserializer);
        let mut var_feedback = <Vec<f64>>::sse_decode(deserializer);
        return web_audio_api::node::iir_filter::IIRFilterOptions {
            audio_node_options: var_audioNodeOptions,
            feedforward: var_feedforward,
            feedback: var_feedback,
        };
    }
}

impl SseDecode for Vec<ChannelData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ChannelData>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<MediaDeviceInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<MediaStreamTrack>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<f32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<f32>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<RefCell<Node>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<RefCell<Node>>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<usize>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, f64)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode
    for Vec<(
        usize,
        Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(
                usize,
                Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
            )>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(usize, oneshot::Sender<()>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(usize, oneshot::Sender<()>)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for web_audio_api::media_devices::MediaDeviceInfoKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::media_devices::MediaDeviceInfoKind::VideoInput,
            1 => web_audio_api::media_devices::MediaDeviceInfoKind::AudioInput,
            2 => web_audio_api::media_devices::MediaDeviceInfoKind::AudioOutput,
            _ => unreachable!("Invalid variant for MediaDeviceInfoKind: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::media_streams::MediaStream {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tracks = <Vec<MediaStreamTrack>>::sse_decode(deserializer);
        return web_audio_api::media_streams::MediaStream { tracks: var_tracks };
    }
}

impl SseDecode for web_audio_api::media_devices::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return web_audio_api::media_devices::MediaStreamConstraints::Audio;
            }
            1 => {
                let mut var_field0 =
                    <web_audio_api::media_devices::MediaTrackConstraints>::sse_decode(deserializer);
                return web_audio_api::media_devices::MediaStreamConstraints::AudioWithConstraints(
                    var_field0,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for web_audio_api::media_streams::MediaStreamTrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::media_streams::MediaStreamTrackState::Live,
            1 => web_audio_api::media_streams::MediaStreamTrackState::Ended,
            _ => unreachable!("Invalid variant for MediaStreamTrackState: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::media_devices::MediaTrackConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sampleRate = <Option<f32>>::sse_decode(deserializer);
        let mut var_latency = <Option<f64>>::sse_decode(deserializer);
        let mut var_channelCount = <Option<u32>>::sse_decode(deserializer);
        let mut var_deviceId = <Option<String>>::sse_decode(deserializer);
        return web_audio_api::media_devices::MediaTrackConstraints {
            sample_rate: var_sampleRate,
            latency: var_latency,
            channel_count: var_channelCount,
            device_id: var_deviceId,
        };
    }
}

impl SseDecode for web_audio_api::render::node_collection::NodeCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodes = <Vec<Option<RefCell<Node>>>>::sse_decode(deserializer);
        return web_audio_api::render::node_collection::NodeCollection { nodes: var_nodes };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<PeriodicWave> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<PeriodicWave>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<RefCell<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<RefCell<Node>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>,
            >>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<web_audio_api::buffer::AudioBuffer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<web_audio_api::buffer::AudioBuffer>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode
    for Option<(
        ConcreteBaseAudioContext,
        web_audio_api::context::AudioNodeId,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<(
                ConcreteBaseAudioContext,
                web_audio_api::context::AudioNodeId,
            )>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<f32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<f32>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for web_audio_api::node::oscillator::OscillatorOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_type =
            <web_audio_api::node::oscillator::OscillatorType>::sse_decode(deserializer);
        let mut var_frequency = <f32>::sse_decode(deserializer);
        let mut var_detune = <f32>::sse_decode(deserializer);
        let mut var_periodicWave = <Option<PeriodicWave>>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::oscillator::OscillatorOptions {
            type_: var_type,
            frequency: var_frequency,
            detune: var_detune,
            periodic_wave: var_periodicWave,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::oscillator::OscillatorType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::oscillator::OscillatorType::Sine,
            1 => web_audio_api::node::oscillator::OscillatorType::Square,
            2 => web_audio_api::node::oscillator::OscillatorType::Sawtooth,
            3 => web_audio_api::node::oscillator::OscillatorType::Triangle,
            4 => web_audio_api::node::oscillator::OscillatorType::Custom,
            _ => unreachable!("Invalid variant for OscillatorType: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::node::waveshaper::OverSampleType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::waveshaper::OverSampleType::None,
            1 => web_audio_api::node::waveshaper::OverSampleType::X2,
            2 => web_audio_api::node::waveshaper::OverSampleType::X4,
            _ => unreachable!("Invalid variant for OverSampleType: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::node::panner::PannerOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_panningModel =
            <web_audio_api::node::panner::PanningModelType>::sse_decode(deserializer);
        let mut var_distanceModel =
            <web_audio_api::node::panner::DistanceModelType>::sse_decode(deserializer);
        let mut var_positionX = <f32>::sse_decode(deserializer);
        let mut var_positionY = <f32>::sse_decode(deserializer);
        let mut var_positionZ = <f32>::sse_decode(deserializer);
        let mut var_orientationX = <f32>::sse_decode(deserializer);
        let mut var_orientationY = <f32>::sse_decode(deserializer);
        let mut var_orientationZ = <f32>::sse_decode(deserializer);
        let mut var_refDistance = <f64>::sse_decode(deserializer);
        let mut var_maxDistance = <f64>::sse_decode(deserializer);
        let mut var_rolloffFactor = <f64>::sse_decode(deserializer);
        let mut var_coneInnerAngle = <f64>::sse_decode(deserializer);
        let mut var_coneOuterAngle = <f64>::sse_decode(deserializer);
        let mut var_coneOuterGain = <f64>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::panner::PannerOptions {
            panning_model: var_panningModel,
            distance_model: var_distanceModel,
            position_x: var_positionX,
            position_y: var_positionY,
            position_z: var_positionZ,
            orientation_x: var_orientationX,
            orientation_y: var_orientationY,
            orientation_z: var_orientationZ,
            ref_distance: var_refDistance,
            max_distance: var_maxDistance,
            rolloff_factor: var_rolloffFactor,
            cone_inner_angle: var_coneInnerAngle,
            cone_outer_angle: var_coneOuterAngle,
            cone_outer_gain: var_coneOuterGain,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for web_audio_api::node::panner::PanningModelType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => web_audio_api::node::panner::PanningModelType::EqualPower,
            1 => web_audio_api::node::panner::PanningModelType::HRTF,
            _ => unreachable!("Invalid variant for PanningModelType: {}", inner),
        };
    }
}

impl SseDecode for web_audio_api::periodic_wave::PeriodicWaveOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_real = <Option<Vec<f32>>>::sse_decode(deserializer);
        let mut var_imag = <Option<Vec<f32>>>::sse_decode(deserializer);
        let mut var_disableNormalization = <bool>::sse_decode(deserializer);
        return web_audio_api::periodic_wave::PeriodicWaveOptions {
            real: var_real,
            imag: var_imag,
            disable_normalization: var_disableNormalization,
        };
    }
}

impl SseDecode for (web_audio_api::context::AudioNodeId, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <web_audio_api::context::AudioNodeId>::sse_decode(deserializer);
        let mut var_field1 = <usize>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        ConcreteBaseAudioContext,
        web_audio_api::context::AudioNodeId,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <ConcreteBaseAudioContext>::sse_decode(deserializer);
        let mut var_field1 = <web_audio_api::context::AudioNodeId>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (f32, f32) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <f32>::sse_decode(deserializer);
        let mut var_field1 = <f32>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <f64>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode
    for (
        usize,
        Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 =
            <Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>>::sse_decode(
                deserializer,
            );
        return (var_field0, var_field1);
    }
}

impl SseDecode for (usize, oneshot::Sender<()>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <usize>::sse_decode(deserializer);
        let mut var_field1 = <oneshot::Sender<()>>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for web_audio_api::node::script_processor::ScriptProcessorOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bufferSize = <usize>::sse_decode(deserializer);
        let mut var_numberOfInputChannels = <usize>::sse_decode(deserializer);
        let mut var_numberOfOutputChannels = <usize>::sse_decode(deserializer);
        return web_audio_api::node::script_processor::ScriptProcessorOptions {
            buffer_size: var_bufferSize,
            number_of_input_channels: var_numberOfInputChannels,
            number_of_output_channels: var_numberOfOutputChannels,
        };
    }
}

impl SseDecode for web_audio_api::node::stereo_panner::StereoPannerOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pan = <f32>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::stereo_panner::StereoPannerOptions {
            pan: var_pan,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for web_audio_api::node::waveshaper::WaveShaperOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_curve = <Option<Vec<f32>>>::sse_decode(deserializer);
        let mut var_oversample =
            <web_audio_api::node::waveshaper::OverSampleType>::sse_decode(deserializer);
        let mut var_audioNodeOptions =
            <web_audio_api::node::audio_node::AudioNodeOptions>::sse_decode(deserializer);
        return web_audio_api::node::waveshaper::WaveShaperOptions {
            curve: var_curve,
            oversample: var_oversample,
            audio_node_options: var_audioNodeOptions,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        2 => wire__crate__api__simple__init_app_impl(port, ptr, rust_vec_len, data_len),
3 => wire__web_audio_api__AtomicF32_load_impl(port, ptr, rust_vec_len, data_len),
4 => wire__web_audio_api__AtomicF32_new_impl(port, ptr, rust_vec_len, data_len),
5 => wire__web_audio_api__AtomicF32_store_impl(port, ptr, rust_vec_len, data_len),
6 => wire__web_audio_api__AtomicF64_load_impl(port, ptr, rust_vec_len, data_len),
7 => wire__web_audio_api__AtomicF64_new_impl(port, ptr, rust_vec_len, data_len),
8 => wire__web_audio_api__AtomicF64_store_impl(port, ptr, rust_vec_len, data_len),
9 => wire__web_audio_api__analysis__AnalyserRingBuffer_new_impl(port, ptr, rust_vec_len, data_len),
10 => wire__web_audio_api__analysis__AnalyserRingBuffer_read_impl(port, ptr, rust_vec_len, data_len),
11 => wire__web_audio_api__analysis__AnalyserRingBuffer_write_impl(port, ptr, rust_vec_len, data_len),
12 => wire__web_audio_api__analysis__Analyser_fft_size_impl(port, ptr, rust_vec_len, data_len),
13 => wire__web_audio_api__analysis__Analyser_frequency_bin_count_impl(port, ptr, rust_vec_len, data_len),
14 => wire__web_audio_api__analysis__Analyser_get_byte_frequency_data_impl(port, ptr, rust_vec_len, data_len),
15 => wire__web_audio_api__analysis__Analyser_get_byte_time_domain_data_impl(port, ptr, rust_vec_len, data_len),
16 => wire__web_audio_api__analysis__Analyser_get_float_frequency_data_impl(port, ptr, rust_vec_len, data_len),
17 => wire__web_audio_api__analysis__Analyser_get_float_time_domain_data_impl(port, ptr, rust_vec_len, data_len),
18 => wire__web_audio_api__analysis__Analyser_get_ring_buffer_clone_impl(port, ptr, rust_vec_len, data_len),
19 => wire__web_audio_api__analysis__Analyser_max_decibels_impl(port, ptr, rust_vec_len, data_len),
20 => wire__web_audio_api__analysis__Analyser_min_decibels_impl(port, ptr, rust_vec_len, data_len),
21 => wire__web_audio_api__analysis__Analyser_new_impl(port, ptr, rust_vec_len, data_len),
22 => wire__web_audio_api__analysis__Analyser_set_decibels_impl(port, ptr, rust_vec_len, data_len),
23 => wire__web_audio_api__analysis__Analyser_set_fft_size_impl(port, ptr, rust_vec_len, data_len),
24 => wire__web_audio_api__analysis__Analyser_set_smoothing_time_constant_impl(port, ptr, rust_vec_len, data_len),
25 => wire__web_audio_api__analysis__Analyser_smoothing_time_constant_impl(port, ptr, rust_vec_len, data_len),
26 => wire__web_audio_api__buffer__ChannelData_as_mut_slice_impl(port, ptr, rust_vec_len, data_len),
27 => wire__web_audio_api__buffer__ChannelData_as_slice_impl(port, ptr, rust_vec_len, data_len),
28 => wire__web_audio_api__buffer__ChannelData_from_impl(port, ptr, rust_vec_len, data_len),
29 => wire__web_audio_api__buffer__ChannelData_is_empty_impl(port, ptr, rust_vec_len, data_len),
30 => wire__web_audio_api__buffer__ChannelData_len_impl(port, ptr, rust_vec_len, data_len),
31 => wire__web_audio_api__buffer__ChannelData_new_impl(port, ptr, rust_vec_len, data_len),
32 => wire__web_audio_api__buffer__audio_buffer_copy_from_channel_impl(port, ptr, rust_vec_len, data_len),
33 => wire__web_audio_api__buffer__audio_buffer_copy_from_channel_with_offset_impl(port, ptr, rust_vec_len, data_len),
34 => wire__web_audio_api__buffer__audio_buffer_copy_to_channel_impl(port, ptr, rust_vec_len, data_len),
35 => wire__web_audio_api__buffer__audio_buffer_copy_to_channel_with_offset_impl(port, ptr, rust_vec_len, data_len),
36 => wire__web_audio_api__buffer__audio_buffer_duration_impl(port, ptr, rust_vec_len, data_len),
37 => wire__web_audio_api__buffer__audio_buffer_from_impl(port, ptr, rust_vec_len, data_len),
38 => wire__web_audio_api__buffer__audio_buffer_get_channel_data_impl(port, ptr, rust_vec_len, data_len),
39 => wire__web_audio_api__buffer__audio_buffer_get_channel_data_mut_impl(port, ptr, rust_vec_len, data_len),
40 => wire__web_audio_api__buffer__audio_buffer_length_impl(port, ptr, rust_vec_len, data_len),
41 => wire__web_audio_api__buffer__audio_buffer_new_impl(port, ptr, rust_vec_len, data_len),
42 => wire__web_audio_api__buffer__audio_buffer_number_of_channels_impl(port, ptr, rust_vec_len, data_len),
43 => wire__web_audio_api__buffer__audio_buffer_sample_rate_impl(port, ptr, rust_vec_len, data_len),
54 => wire__web_audio_api__capacity__AudioRenderCapacity_clear_onupdate_impl(port, ptr, rust_vec_len, data_len),
55 => wire__web_audio_api__capacity__AudioRenderCapacity_set_onupdate_impl(port, ptr, rust_vec_len, data_len),
56 => wire__web_audio_api__capacity__AudioRenderCapacity_start_impl(port, ptr, rust_vec_len, data_len),
57 => wire__web_audio_api__capacity__AudioRenderCapacity_stop_impl(port, ptr, rust_vec_len, data_len),
58 => wire__web_audio_api__context__concrete_base__ConcreteBaseAudioContext_mark_cycle_breaker_impl(port, ptr, rust_vec_len, data_len),
59 => wire__web_audio_api__context__offline__OfflineAudioContext_clear_oncomplete_impl(port, ptr, rust_vec_len, data_len),
60 => wire__web_audio_api__context__offline__OfflineAudioContext_length_impl(port, ptr, rust_vec_len, data_len),
61 => wire__web_audio_api__context__offline__OfflineAudioContext_new_impl(port, ptr, rust_vec_len, data_len),
62 => wire__web_audio_api__context__offline__OfflineAudioContext_resume_impl(port, ptr, rust_vec_len, data_len),
63 => wire__web_audio_api__context__offline__OfflineAudioContext_set_oncomplete_impl(port, ptr, rust_vec_len, data_len),
64 => wire__web_audio_api__context__offline__OfflineAudioContext_start_rendering_impl(port, ptr, rust_vec_len, data_len),
65 => wire__web_audio_api__context__offline__OfflineAudioContext_start_rendering_sync_impl(port, ptr, rust_vec_len, data_len),
66 => wire__web_audio_api__context__offline__OfflineAudioContext_suspend_impl(port, ptr, rust_vec_len, data_len),
67 => wire__web_audio_api__context__offline__OfflineAudioContext_suspend_sync_impl(port, ptr, rust_vec_len, data_len),
68 => wire__web_audio_api__context__online__AudioContext_base_latency_impl(port, ptr, rust_vec_len, data_len),
69 => wire__web_audio_api__context__online__AudioContext_clear_onsinkchange_impl(port, ptr, rust_vec_len, data_len),
70 => wire__web_audio_api__context__online__AudioContext_close_impl(port, ptr, rust_vec_len, data_len),
71 => wire__web_audio_api__context__online__AudioContext_close_sync_impl(port, ptr, rust_vec_len, data_len),
72 => wire__web_audio_api__context__online__AudioContext_create_media_element_source_impl(port, ptr, rust_vec_len, data_len),
73 => wire__web_audio_api__context__online__AudioContext_create_media_stream_destination_impl(port, ptr, rust_vec_len, data_len),
74 => wire__web_audio_api__context__online__AudioContext_create_media_stream_source_impl(port, ptr, rust_vec_len, data_len),
75 => wire__web_audio_api__context__online__AudioContext_create_media_stream_track_source_impl(port, ptr, rust_vec_len, data_len),
76 => wire__web_audio_api__context__online__AudioContext_new_impl(port, ptr, rust_vec_len, data_len),
77 => wire__web_audio_api__context__online__AudioContext_output_latency_impl(port, ptr, rust_vec_len, data_len),
78 => wire__web_audio_api__context__online__AudioContext_render_capacity_impl(port, ptr, rust_vec_len, data_len),
79 => wire__web_audio_api__context__online__AudioContext_resume_impl(port, ptr, rust_vec_len, data_len),
80 => wire__web_audio_api__context__online__AudioContext_resume_sync_impl(port, ptr, rust_vec_len, data_len),
81 => wire__web_audio_api__context__online__AudioContext_run_diagnostics_impl(port, ptr, rust_vec_len, data_len),
82 => wire__web_audio_api__context__online__AudioContext_set_onsinkchange_impl(port, ptr, rust_vec_len, data_len),
83 => wire__web_audio_api__context__online__AudioContext_set_sink_id_sync_impl(port, ptr, rust_vec_len, data_len),
84 => wire__web_audio_api__context__online__AudioContext_sink_id_impl(port, ptr, rust_vec_len, data_len),
85 => wire__web_audio_api__context__online__AudioContext_suspend_impl(port, ptr, rust_vec_len, data_len),
86 => wire__web_audio_api__context__online__AudioContext_suspend_sync_impl(port, ptr, rust_vec_len, data_len),
87 => wire__web_audio_api__decoding__MediaDecoder_try_new_impl(port, ptr, rust_vec_len, data_len),
88 => wire__web_audio_api__decoding__MediaInput_new_impl(port, ptr, rust_vec_len, data_len),
95 => wire__web_audio_api__events__EventDispatch_audio_processing_impl(port, ptr, rust_vec_len, data_len),
96 => wire__web_audio_api__events__EventDispatch_complete_impl(port, ptr, rust_vec_len, data_len),
97 => wire__web_audio_api__events__EventDispatch_diagnostics_impl(port, ptr, rust_vec_len, data_len),
98 => wire__web_audio_api__events__EventDispatch_ended_impl(port, ptr, rust_vec_len, data_len),
99 => wire__web_audio_api__events__EventDispatch_message_impl(port, ptr, rust_vec_len, data_len),
100 => wire__web_audio_api__events__EventDispatch_processor_error_impl(port, ptr, rust_vec_len, data_len),
101 => wire__web_audio_api__events__EventDispatch_render_capacity_impl(port, ptr, rust_vec_len, data_len),
102 => wire__web_audio_api__events__EventDispatch_sink_change_impl(port, ptr, rust_vec_len, data_len),
103 => wire__web_audio_api__events__EventDispatch_state_change_impl(port, ptr, rust_vec_len, data_len),
104 => wire__web_audio_api__events__EventLoop_clear_handler_impl(port, ptr, rust_vec_len, data_len),
105 => wire__web_audio_api__events__EventLoop_handle_pending_events_impl(port, ptr, rust_vec_len, data_len),
106 => wire__web_audio_api__events__EventLoop_new_impl(port, ptr, rust_vec_len, data_len),
107 => wire__web_audio_api__events__EventLoop_run_in_thread_impl(port, ptr, rust_vec_len, data_len),
108 => wire__web_audio_api__events__EventLoop_set_handler_impl(port, ptr, rust_vec_len, data_len),
137 => wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_close_impl(port, ptr, rust_vec_len, data_len),
138 => wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_new_impl(port, ptr, rust_vec_len, data_len),
139 => wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_resume_impl(port, ptr, rust_vec_len, data_len),
140 => wire__web_audio_api__io__cpal__private__ThreadSafeClosableStream_suspend_impl(port, ptr, rust_vec_len, data_len),
141 => wire__web_audio_api__io__microphone__MicrophoneRender_new_impl(port, ptr, rust_vec_len, data_len),
142 => wire__web_audio_api__io__microphone__MicrophoneRender_render_impl(port, ptr, rust_vec_len, data_len),
143 => wire__web_audio_api__media_devices__MediaDeviceInfo_device_id_impl(port, ptr, rust_vec_len, data_len),
144 => wire__web_audio_api__media_devices__MediaDeviceInfo_group_id_impl(port, ptr, rust_vec_len, data_len),
145 => wire__web_audio_api__media_devices__MediaDeviceInfo_kind_impl(port, ptr, rust_vec_len, data_len),
146 => wire__web_audio_api__media_devices__MediaDeviceInfo_label_impl(port, ptr, rust_vec_len, data_len),
147 => wire__web_audio_api__media_devices__enumerate_devices_sync_impl(port, ptr, rust_vec_len, data_len),
148 => wire__web_audio_api__media_devices__get_user_media_sync_impl(port, ptr, rust_vec_len, data_len),
149 => wire__web_audio_api__media_element__MediaElement_current_time_impl(port, ptr, rust_vec_len, data_len),
150 => wire__web_audio_api__media_element__MediaElement_loop__impl(port, ptr, rust_vec_len, data_len),
151 => wire__web_audio_api__media_element__MediaElement_new_impl(port, ptr, rust_vec_len, data_len),
152 => wire__web_audio_api__media_element__MediaElement_pause_impl(port, ptr, rust_vec_len, data_len),
153 => wire__web_audio_api__media_element__MediaElement_paused_impl(port, ptr, rust_vec_len, data_len),
154 => wire__web_audio_api__media_element__MediaElement_play_impl(port, ptr, rust_vec_len, data_len),
155 => wire__web_audio_api__media_element__MediaElement_playback_rate_impl(port, ptr, rust_vec_len, data_len),
156 => wire__web_audio_api__media_element__MediaElement_set_current_time_impl(port, ptr, rust_vec_len, data_len),
157 => wire__web_audio_api__media_element__MediaElement_set_loop_impl(port, ptr, rust_vec_len, data_len),
158 => wire__web_audio_api__media_element__MediaElement_set_playback_rate_impl(port, ptr, rust_vec_len, data_len),
165 => wire__web_audio_api__media_recorder__MediaRecorder_clear_ondataavailable_impl(port, ptr, rust_vec_len, data_len),
166 => wire__web_audio_api__media_recorder__MediaRecorder_clear_onerror_impl(port, ptr, rust_vec_len, data_len),
167 => wire__web_audio_api__media_recorder__MediaRecorder_clear_onstop_impl(port, ptr, rust_vec_len, data_len),
168 => wire__web_audio_api__media_recorder__MediaRecorder_new_impl(port, ptr, rust_vec_len, data_len),
169 => wire__web_audio_api__media_recorder__MediaRecorder_set_ondataavailable_impl(port, ptr, rust_vec_len, data_len),
170 => wire__web_audio_api__media_recorder__MediaRecorder_set_onerror_impl(port, ptr, rust_vec_len, data_len),
171 => wire__web_audio_api__media_recorder__MediaRecorder_set_onstop_impl(port, ptr, rust_vec_len, data_len),
172 => wire__web_audio_api__media_recorder__MediaRecorder_start_impl(port, ptr, rust_vec_len, data_len),
173 => wire__web_audio_api__media_recorder__MediaRecorder_stop_impl(port, ptr, rust_vec_len, data_len),
174 => wire__web_audio_api__media_streams__MediaStreamTrack_close_impl(port, ptr, rust_vec_len, data_len),
175 => wire__web_audio_api__media_streams__MediaStreamTrack_from_iter_impl(port, ptr, rust_vec_len, data_len),
176 => wire__web_audio_api__media_streams__MediaStreamTrack_ready_state_impl(port, ptr, rust_vec_len, data_len),
177 => wire__web_audio_api__media_streams__media_stream_from_tracks_impl(port, ptr, rust_vec_len, data_len),
178 => wire__web_audio_api__media_streams__media_stream_get_tracks_impl(port, ptr, rust_vec_len, data_len),
179 => wire__web_audio_api__message__OneshotNotify_send_impl(port, ptr, rust_vec_len, data_len),
180 => wire__web_audio_api__message_port__MessagePort_clear_onmessage_impl(port, ptr, rust_vec_len, data_len),
181 => wire__web_audio_api__message_port__MessagePort_post_message_impl(port, ptr, rust_vec_len, data_len),
182 => wire__web_audio_api__message_port__MessagePort_set_onmessage_impl(port, ptr, rust_vec_len, data_len),
183 => wire__web_audio_api__node__analyser__AnalyserNode_fft_size_impl(port, ptr, rust_vec_len, data_len),
184 => wire__web_audio_api__node__analyser__AnalyserNode_frequency_bin_count_impl(port, ptr, rust_vec_len, data_len),
185 => wire__web_audio_api__node__analyser__AnalyserNode_get_byte_frequency_data_impl(port, ptr, rust_vec_len, data_len),
186 => wire__web_audio_api__node__analyser__AnalyserNode_get_byte_time_domain_data_impl(port, ptr, rust_vec_len, data_len),
187 => wire__web_audio_api__node__analyser__AnalyserNode_get_float_frequency_data_impl(port, ptr, rust_vec_len, data_len),
188 => wire__web_audio_api__node__analyser__AnalyserNode_get_float_time_domain_data_impl(port, ptr, rust_vec_len, data_len),
189 => wire__web_audio_api__node__analyser__AnalyserNode_max_decibels_impl(port, ptr, rust_vec_len, data_len),
190 => wire__web_audio_api__node__analyser__AnalyserNode_min_decibels_impl(port, ptr, rust_vec_len, data_len),
191 => wire__web_audio_api__node__analyser__AnalyserNode_new_impl(port, ptr, rust_vec_len, data_len),
192 => wire__web_audio_api__node__analyser__AnalyserNode_set_fft_size_impl(port, ptr, rust_vec_len, data_len),
193 => wire__web_audio_api__node__analyser__AnalyserNode_set_max_decibels_impl(port, ptr, rust_vec_len, data_len),
194 => wire__web_audio_api__node__analyser__AnalyserNode_set_min_decibels_impl(port, ptr, rust_vec_len, data_len),
195 => wire__web_audio_api__node__analyser__AnalyserNode_set_smoothing_time_constant_impl(port, ptr, rust_vec_len, data_len),
196 => wire__web_audio_api__node__analyser__AnalyserNode_smoothing_time_constant_impl(port, ptr, rust_vec_len, data_len),
197 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_buffer_impl(port, ptr, rust_vec_len, data_len),
198 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_detune_impl(port, ptr, rust_vec_len, data_len),
199 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_loop__impl(port, ptr, rust_vec_len, data_len),
200 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_loop_end_impl(port, ptr, rust_vec_len, data_len),
201 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_loop_start_impl(port, ptr, rust_vec_len, data_len),
202 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_new_impl(port, ptr, rust_vec_len, data_len),
203 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_playback_rate_impl(port, ptr, rust_vec_len, data_len),
204 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_position_impl(port, ptr, rust_vec_len, data_len),
205 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_buffer_impl(port, ptr, rust_vec_len, data_len),
206 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_loop_impl(port, ptr, rust_vec_len, data_len),
207 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_loop_end_impl(port, ptr, rust_vec_len, data_len),
208 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_set_loop_start_impl(port, ptr, rust_vec_len, data_len),
209 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_start_at_with_offset_impl(port, ptr, rust_vec_len, data_len),
210 => wire__web_audio_api__node__audio_buffer_source__AudioBufferSourceNode_start_at_with_offset_and_duration_impl(port, ptr, rust_vec_len, data_len),
211 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_detune_impl(port, ptr, rust_vec_len, data_len),
212 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_frequency_impl(port, ptr, rust_vec_len, data_len),
213 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_gain_impl(port, ptr, rust_vec_len, data_len),
214 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_get_frequency_response_impl(port, ptr, rust_vec_len, data_len),
215 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_new_impl(port, ptr, rust_vec_len, data_len),
216 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_q_impl(port, ptr, rust_vec_len, data_len),
217 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_set_type_impl(port, ptr, rust_vec_len, data_len),
218 => wire__web_audio_api__node__biquad_filter__BiquadFilterNode_type__impl(port, ptr, rust_vec_len, data_len),
219 => wire__web_audio_api__node__channel_merger__ChannelMergerNode_new_impl(port, ptr, rust_vec_len, data_len),
220 => wire__web_audio_api__node__channel_splitter__ChannelSplitterNode_new_impl(port, ptr, rust_vec_len, data_len),
221 => wire__web_audio_api__node__constant_source__ConstantSourceNode_new_impl(port, ptr, rust_vec_len, data_len),
222 => wire__web_audio_api__node__constant_source__ConstantSourceNode_offset_impl(port, ptr, rust_vec_len, data_len),
223 => wire__web_audio_api__node__convolver__ConvolverNode_buffer_impl(port, ptr, rust_vec_len, data_len),
224 => wire__web_audio_api__node__convolver__ConvolverNode_new_impl(port, ptr, rust_vec_len, data_len),
225 => wire__web_audio_api__node__convolver__ConvolverNode_normalize_impl(port, ptr, rust_vec_len, data_len),
226 => wire__web_audio_api__node__convolver__ConvolverNode_set_buffer_impl(port, ptr, rust_vec_len, data_len),
227 => wire__web_audio_api__node__convolver__ConvolverNode_set_normalize_impl(port, ptr, rust_vec_len, data_len),
228 => wire__web_audio_api__node__delay__DelayNode_delay_time_impl(port, ptr, rust_vec_len, data_len),
229 => wire__web_audio_api__node__delay__DelayNode_new_impl(port, ptr, rust_vec_len, data_len),
230 => wire__web_audio_api__node__destination__AudioDestinationNode_max_channel_count_impl(port, ptr, rust_vec_len, data_len),
231 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_attack_impl(port, ptr, rust_vec_len, data_len),
232 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_knee_impl(port, ptr, rust_vec_len, data_len),
233 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_new_impl(port, ptr, rust_vec_len, data_len),
234 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_ratio_impl(port, ptr, rust_vec_len, data_len),
235 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_reduction_impl(port, ptr, rust_vec_len, data_len),
236 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_release_impl(port, ptr, rust_vec_len, data_len),
237 => wire__web_audio_api__node__dynamics_compressor__DynamicsCompressorNode_threshold_impl(port, ptr, rust_vec_len, data_len),
238 => wire__web_audio_api__node__gain__GainNode_gain_impl(port, ptr, rust_vec_len, data_len),
239 => wire__web_audio_api__node__gain__GainNode_new_impl(port, ptr, rust_vec_len, data_len),
240 => wire__web_audio_api__node__iir_filter__IirFilterNode_get_frequency_response_impl(port, ptr, rust_vec_len, data_len),
241 => wire__web_audio_api__node__iir_filter__IirFilterNode_new_impl(port, ptr, rust_vec_len, data_len),
242 => wire__web_audio_api__node__media_element_source__MediaElementAudioSourceNode_new_impl(port, ptr, rust_vec_len, data_len),
245 => wire__web_audio_api__node__media_stream_destination__MediaStreamAudioDestinationNode_new_impl(port, ptr, rust_vec_len, data_len),
246 => wire__web_audio_api__node__media_stream_destination__MediaStreamAudioDestinationNode_stream_impl(port, ptr, rust_vec_len, data_len),
247 => wire__web_audio_api__node__media_stream_source__MediaStreamAudioSourceNode_new_impl(port, ptr, rust_vec_len, data_len),
250 => wire__web_audio_api__node__media_stream_track_source__MediaStreamTrackAudioSourceNode_new_impl(port, ptr, rust_vec_len, data_len),
253 => wire__web_audio_api__node__oscillator__OscillatorNode_detune_impl(port, ptr, rust_vec_len, data_len),
254 => wire__web_audio_api__node__oscillator__OscillatorNode_frequency_impl(port, ptr, rust_vec_len, data_len),
255 => wire__web_audio_api__node__oscillator__OscillatorNode_new_impl(port, ptr, rust_vec_len, data_len),
256 => wire__web_audio_api__node__oscillator__OscillatorNode_set_periodic_wave_impl(port, ptr, rust_vec_len, data_len),
257 => wire__web_audio_api__node__oscillator__OscillatorNode_set_type_impl(port, ptr, rust_vec_len, data_len),
258 => wire__web_audio_api__node__oscillator__OscillatorNode_type__impl(port, ptr, rust_vec_len, data_len),
259 => wire__web_audio_api__node__panner__PannerNode_cone_inner_angle_impl(port, ptr, rust_vec_len, data_len),
260 => wire__web_audio_api__node__panner__PannerNode_cone_outer_angle_impl(port, ptr, rust_vec_len, data_len),
261 => wire__web_audio_api__node__panner__PannerNode_cone_outer_gain_impl(port, ptr, rust_vec_len, data_len),
262 => wire__web_audio_api__node__panner__PannerNode_distance_model_impl(port, ptr, rust_vec_len, data_len),
263 => wire__web_audio_api__node__panner__PannerNode_max_distance_impl(port, ptr, rust_vec_len, data_len),
264 => wire__web_audio_api__node__panner__PannerNode_new_impl(port, ptr, rust_vec_len, data_len),
265 => wire__web_audio_api__node__panner__PannerNode_orientation_x_impl(port, ptr, rust_vec_len, data_len),
266 => wire__web_audio_api__node__panner__PannerNode_orientation_y_impl(port, ptr, rust_vec_len, data_len),
267 => wire__web_audio_api__node__panner__PannerNode_orientation_z_impl(port, ptr, rust_vec_len, data_len),
268 => wire__web_audio_api__node__panner__PannerNode_panning_model_impl(port, ptr, rust_vec_len, data_len),
269 => wire__web_audio_api__node__panner__PannerNode_position_x_impl(port, ptr, rust_vec_len, data_len),
270 => wire__web_audio_api__node__panner__PannerNode_position_y_impl(port, ptr, rust_vec_len, data_len),
271 => wire__web_audio_api__node__panner__PannerNode_position_z_impl(port, ptr, rust_vec_len, data_len),
272 => wire__web_audio_api__node__panner__PannerNode_ref_distance_impl(port, ptr, rust_vec_len, data_len),
273 => wire__web_audio_api__node__panner__PannerNode_rolloff_factor_impl(port, ptr, rust_vec_len, data_len),
274 => wire__web_audio_api__node__panner__PannerNode_set_cone_inner_angle_impl(port, ptr, rust_vec_len, data_len),
275 => wire__web_audio_api__node__panner__PannerNode_set_cone_outer_angle_impl(port, ptr, rust_vec_len, data_len),
276 => wire__web_audio_api__node__panner__PannerNode_set_cone_outer_gain_impl(port, ptr, rust_vec_len, data_len),
277 => wire__web_audio_api__node__panner__PannerNode_set_distance_model_impl(port, ptr, rust_vec_len, data_len),
278 => wire__web_audio_api__node__panner__PannerNode_set_max_distance_impl(port, ptr, rust_vec_len, data_len),
279 => wire__web_audio_api__node__panner__PannerNode_set_orientation_impl(port, ptr, rust_vec_len, data_len),
280 => wire__web_audio_api__node__panner__PannerNode_set_panning_model_impl(port, ptr, rust_vec_len, data_len),
281 => wire__web_audio_api__node__panner__PannerNode_set_position_impl(port, ptr, rust_vec_len, data_len),
282 => wire__web_audio_api__node__panner__PannerNode_set_ref_distance_impl(port, ptr, rust_vec_len, data_len),
283 => wire__web_audio_api__node__panner__PannerNode_set_rolloff_factor_impl(port, ptr, rust_vec_len, data_len),
284 => wire__web_audio_api__node__script_processor__ScriptProcessorNode_buffer_size_impl(port, ptr, rust_vec_len, data_len),
285 => wire__web_audio_api__node__script_processor__ScriptProcessorNode_clear_onaudioprocess_impl(port, ptr, rust_vec_len, data_len),
286 => wire__web_audio_api__node__script_processor__ScriptProcessorNode_new_impl(port, ptr, rust_vec_len, data_len),
287 => wire__web_audio_api__node__script_processor__ScriptProcessorNode_set_onaudioprocess_impl(port, ptr, rust_vec_len, data_len),
288 => wire__web_audio_api__node__stereo_panner__StereoPannerNode_new_impl(port, ptr, rust_vec_len, data_len),
289 => wire__web_audio_api__node__stereo_panner__StereoPannerNode_pan_impl(port, ptr, rust_vec_len, data_len),
290 => wire__web_audio_api__node__waveshaper__WaveShaperNode_curve_impl(port, ptr, rust_vec_len, data_len),
291 => wire__web_audio_api__node__waveshaper__WaveShaperNode_new_impl(port, ptr, rust_vec_len, data_len),
292 => wire__web_audio_api__node__waveshaper__WaveShaperNode_oversample_impl(port, ptr, rust_vec_len, data_len),
293 => wire__web_audio_api__node__waveshaper__WaveShaperNode_set_curve_impl(port, ptr, rust_vec_len, data_len),
294 => wire__web_audio_api__node__waveshaper__WaveShaperNode_set_oversample_impl(port, ptr, rust_vec_len, data_len),
295 => wire__web_audio_api__param__AudioParam_automation_rate_impl(port, ptr, rust_vec_len, data_len),
296 => wire__web_audio_api__param__AudioParam_cancel_and_hold_at_time_impl(port, ptr, rust_vec_len, data_len),
297 => wire__web_audio_api__param__AudioParam_cancel_scheduled_values_impl(port, ptr, rust_vec_len, data_len),
298 => wire__web_audio_api__param__AudioParam_default_value_impl(port, ptr, rust_vec_len, data_len),
299 => wire__web_audio_api__param__AudioParam_exponential_ramp_to_value_at_time_impl(port, ptr, rust_vec_len, data_len),
300 => wire__web_audio_api__param__AudioParam_linear_ramp_to_value_at_time_impl(port, ptr, rust_vec_len, data_len),
301 => wire__web_audio_api__param__AudioParam_max_value_impl(port, ptr, rust_vec_len, data_len),
302 => wire__web_audio_api__param__AudioParam_min_value_impl(port, ptr, rust_vec_len, data_len),
303 => wire__web_audio_api__param__AudioParam_set_automation_rate_impl(port, ptr, rust_vec_len, data_len),
304 => wire__web_audio_api__param__AudioParam_set_target_at_time_impl(port, ptr, rust_vec_len, data_len),
305 => wire__web_audio_api__param__AudioParam_set_value_impl(port, ptr, rust_vec_len, data_len),
306 => wire__web_audio_api__param__AudioParam_set_value_at_time_impl(port, ptr, rust_vec_len, data_len),
307 => wire__web_audio_api__param__AudioParam_set_value_curve_at_time_impl(port, ptr, rust_vec_len, data_len),
308 => wire__web_audio_api__param__AudioParam_value_impl(port, ptr, rust_vec_len, data_len),
309 => wire__web_audio_api__periodic_wave__PeriodicWave_new_impl(port, ptr, rust_vec_len, data_len),
310 => wire__web_audio_api__render__graph__Graph_add_edge_impl(port, ptr, rust_vec_len, data_len),
311 => wire__web_audio_api__render__graph__Graph_add_node_impl(port, ptr, rust_vec_len, data_len),
312 => wire__web_audio_api__render__graph__Graph_before_drop_impl(port, ptr, rust_vec_len, data_len),
313 => wire__web_audio_api__render__graph__Graph_is_active_impl(port, ptr, rust_vec_len, data_len),
314 => wire__web_audio_api__render__graph__Graph_mark_control_handle_dropped_impl(port, ptr, rust_vec_len, data_len),
315 => wire__web_audio_api__render__graph__Graph_mark_cycle_breaker_impl(port, ptr, rust_vec_len, data_len),
316 => wire__web_audio_api__render__graph__Graph_new_impl(port, ptr, rust_vec_len, data_len),
317 => wire__web_audio_api__render__graph__Graph_remove_edge_impl(port, ptr, rust_vec_len, data_len),
318 => wire__web_audio_api__render__graph__Graph_render_impl(port, ptr, rust_vec_len, data_len),
319 => wire__web_audio_api__render__graph__Graph_route_message_impl(port, ptr, rust_vec_len, data_len),
320 => wire__web_audio_api__render__graph__Graph_set_channel_count_impl(port, ptr, rust_vec_len, data_len),
321 => wire__web_audio_api__render__graph__Graph_set_channel_count_mode_impl(port, ptr, rust_vec_len, data_len),
322 => wire__web_audio_api__render__graph__Graph_set_channel_interpretation_impl(port, ptr, rust_vec_len, data_len),
323 => wire__web_audio_api__render__graph__Node_get_buffer_impl(port, ptr, rust_vec_len, data_len),
324 => wire__web_audio_api__render__node_collection__node_collection_contains_impl(port, ptr, rust_vec_len, data_len),
325 => wire__web_audio_api__render__node_collection__node_collection_get_mut_impl(port, ptr, rust_vec_len, data_len),
326 => wire__web_audio_api__render__node_collection__node_collection_get_unchecked_impl(port, ptr, rust_vec_len, data_len),
327 => wire__web_audio_api__render__node_collection__node_collection_get_unchecked_mut_impl(port, ptr, rust_vec_len, data_len),
328 => wire__web_audio_api__render__node_collection__node_collection_insert_impl(port, ptr, rust_vec_len, data_len),
329 => wire__web_audio_api__render__node_collection__node_collection_is_empty_impl(port, ptr, rust_vec_len, data_len),
330 => wire__web_audio_api__render__node_collection__node_collection_new_impl(port, ptr, rust_vec_len, data_len),
331 => wire__web_audio_api__render__node_collection__node_collection_remove_impl(port, ptr, rust_vec_len, data_len),
335 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_post_message_impl(port, ptr, rust_vec_len, data_len),
339 => wire__web_audio_api__render__quantum__Alloc_silence_impl(port, ptr, rust_vec_len, data_len),
340 => wire__web_audio_api__render__quantum__Alloc_with_capacity_impl(port, ptr, rust_vec_len, data_len),
341 => wire__web_audio_api__render__quantum__AudioRenderQuantum_channel_data_impl(port, ptr, rust_vec_len, data_len),
342 => wire__web_audio_api__render__quantum__AudioRenderQuantum_channel_data_mut_impl(port, ptr, rust_vec_len, data_len),
343 => wire__web_audio_api__render__quantum__AudioRenderQuantum_channels_impl(port, ptr, rust_vec_len, data_len),
344 => wire__web_audio_api__render__quantum__AudioRenderQuantum_channels_mut_impl(port, ptr, rust_vec_len, data_len),
345 => wire__web_audio_api__render__quantum__AudioRenderQuantum_is_silent_impl(port, ptr, rust_vec_len, data_len),
346 => wire__web_audio_api__render__quantum__AudioRenderQuantum_make_silent_impl(port, ptr, rust_vec_len, data_len),
347 => wire__web_audio_api__render__quantum__AudioRenderQuantum_number_of_channels_impl(port, ptr, rust_vec_len, data_len),
348 => wire__web_audio_api__render__quantum__AudioRenderQuantum_set_number_of_channels_impl(port, ptr, rust_vec_len, data_len),
349 => wire__web_audio_api__render__thread__RenderThread_new_impl(port, ptr, rust_vec_len, data_len),
350 => wire__web_audio_api__render__thread__RenderThread_render_impl(port, ptr, rust_vec_len, data_len),
351 => wire__web_audio_api__render__thread__RenderThread_render_audiobuffer_impl(port, ptr, rust_vec_len, data_len),
352 => wire__web_audio_api__render__thread__RenderThread_render_audiobuffer_sync_impl(port, ptr, rust_vec_len, data_len),
353 => wire__web_audio_api__resampling__Resampler_new_impl(port, ptr, rust_vec_len, data_len),
354 => wire__web_audio_api__spatial__AudioListenerNode_into_fields_impl(port, ptr, rust_vec_len, data_len),
355 => wire__web_audio_api__spatial__AudioListenerNode_new_impl(port, ptr, rust_vec_len, data_len),
374 => wire__web_audio_api__spatial__AudioListener_forward_x_impl(port, ptr, rust_vec_len, data_len),
375 => wire__web_audio_api__spatial__AudioListener_forward_y_impl(port, ptr, rust_vec_len, data_len),
376 => wire__web_audio_api__spatial__AudioListener_forward_z_impl(port, ptr, rust_vec_len, data_len),
377 => wire__web_audio_api__spatial__AudioListener_position_x_impl(port, ptr, rust_vec_len, data_len),
378 => wire__web_audio_api__spatial__AudioListener_position_y_impl(port, ptr, rust_vec_len, data_len),
379 => wire__web_audio_api__spatial__AudioListener_position_z_impl(port, ptr, rust_vec_len, data_len),
380 => wire__web_audio_api__spatial__AudioListener_up_x_impl(port, ptr, rust_vec_len, data_len),
381 => wire__web_audio_api__spatial__AudioListener_up_y_impl(port, ptr, rust_vec_len, data_len),
382 => wire__web_audio_api__spatial__AudioListener_up_z_impl(port, ptr, rust_vec_len, data_len),
383 => wire__web_audio_api__spatial__angle_impl(port, ptr, rust_vec_len, data_len),
384 => wire__web_audio_api__spatial__azimuth_and_elevation_impl(port, ptr, rust_vec_len, data_len),
385 => wire__web_audio_api__spatial__distance_impl(port, ptr, rust_vec_len, data_len),
398 => wire__web_audio_api__worklet__AudioWorkletNode_parameters_impl(port, ptr, rust_vec_len, data_len),
399 => wire__web_audio_api__worklet__AudioWorkletNode_port_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        1 => wire__crate__api__simple__greet_impl(ptr, rust_vec_len, data_len),
44 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_average_load_impl(ptr, rust_vec_len, data_len),
45 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_event_impl(ptr, rust_vec_len, data_len),
46 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_peak_load_impl(ptr, rust_vec_len, data_len),
47 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_timestamp_impl(ptr, rust_vec_len, data_len),
48 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_get_underrun_ratio_impl(ptr, rust_vec_len, data_len),
49 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_average_load_impl(ptr, rust_vec_len, data_len),
50 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_event_impl(ptr, rust_vec_len, data_len),
51 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_peak_load_impl(ptr, rust_vec_len, data_len),
52 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_timestamp_impl(ptr, rust_vec_len, data_len),
53 => wire__web_audio_api__capacity__AudioRenderCapacityEvent_set_underrun_ratio_impl(ptr, rust_vec_len, data_len),
89 => wire__web_audio_api__events__ErrorEvent_get_error_impl(ptr, rust_vec_len, data_len),
90 => wire__web_audio_api__events__ErrorEvent_get_event_impl(ptr, rust_vec_len, data_len),
91 => wire__web_audio_api__events__ErrorEvent_get_message_impl(ptr, rust_vec_len, data_len),
92 => wire__web_audio_api__events__ErrorEvent_set_error_impl(ptr, rust_vec_len, data_len),
93 => wire__web_audio_api__events__ErrorEvent_set_event_impl(ptr, rust_vec_len, data_len),
94 => wire__web_audio_api__events__ErrorEvent_set_message_impl(ptr, rust_vec_len, data_len),
109 => wire__web_audio_api__events__Event_get_type__impl(ptr, rust_vec_len, data_len),
110 => wire__web_audio_api__events__Event_set_type__impl(ptr, rust_vec_len, data_len),
111 => wire__web_audio_api__events__OfflineAudioCompletionEvent_get_event_impl(ptr, rust_vec_len, data_len),
112 => wire__web_audio_api__events__OfflineAudioCompletionEvent_get_rendered_buffer_impl(ptr, rust_vec_len, data_len),
113 => wire__web_audio_api__events__OfflineAudioCompletionEvent_set_event_impl(ptr, rust_vec_len, data_len),
114 => wire__web_audio_api__events__OfflineAudioCompletionEvent_set_rendered_buffer_impl(ptr, rust_vec_len, data_len),
115 => wire__web_audio_api__io__ControlThreadInit_get_ctrl_msg_send_impl(ptr, rust_vec_len, data_len),
116 => wire__web_audio_api__io__ControlThreadInit_get_event_recv_impl(ptr, rust_vec_len, data_len),
117 => wire__web_audio_api__io__ControlThreadInit_get_event_send_impl(ptr, rust_vec_len, data_len),
118 => wire__web_audio_api__io__ControlThreadInit_get_frames_played_impl(ptr, rust_vec_len, data_len),
119 => wire__web_audio_api__io__ControlThreadInit_get_load_value_recv_impl(ptr, rust_vec_len, data_len),
120 => wire__web_audio_api__io__ControlThreadInit_get_state_impl(ptr, rust_vec_len, data_len),
121 => wire__web_audio_api__io__ControlThreadInit_set_ctrl_msg_send_impl(ptr, rust_vec_len, data_len),
122 => wire__web_audio_api__io__ControlThreadInit_set_event_recv_impl(ptr, rust_vec_len, data_len),
123 => wire__web_audio_api__io__ControlThreadInit_set_event_send_impl(ptr, rust_vec_len, data_len),
124 => wire__web_audio_api__io__ControlThreadInit_set_frames_played_impl(ptr, rust_vec_len, data_len),
125 => wire__web_audio_api__io__ControlThreadInit_set_load_value_recv_impl(ptr, rust_vec_len, data_len),
126 => wire__web_audio_api__io__ControlThreadInit_set_state_impl(ptr, rust_vec_len, data_len),
127 => wire__web_audio_api__io__RenderThreadInit_get_ctrl_msg_recv_impl(ptr, rust_vec_len, data_len),
128 => wire__web_audio_api__io__RenderThreadInit_get_event_send_impl(ptr, rust_vec_len, data_len),
129 => wire__web_audio_api__io__RenderThreadInit_get_frames_played_impl(ptr, rust_vec_len, data_len),
130 => wire__web_audio_api__io__RenderThreadInit_get_load_value_send_impl(ptr, rust_vec_len, data_len),
131 => wire__web_audio_api__io__RenderThreadInit_get_state_impl(ptr, rust_vec_len, data_len),
132 => wire__web_audio_api__io__RenderThreadInit_set_ctrl_msg_recv_impl(ptr, rust_vec_len, data_len),
133 => wire__web_audio_api__io__RenderThreadInit_set_event_send_impl(ptr, rust_vec_len, data_len),
134 => wire__web_audio_api__io__RenderThreadInit_set_frames_played_impl(ptr, rust_vec_len, data_len),
135 => wire__web_audio_api__io__RenderThreadInit_set_load_value_send_impl(ptr, rust_vec_len, data_len),
136 => wire__web_audio_api__io__RenderThreadInit_set_state_impl(ptr, rust_vec_len, data_len),
159 => wire__web_audio_api__media_recorder__BlobEvent_get_blob_impl(ptr, rust_vec_len, data_len),
160 => wire__web_audio_api__media_recorder__BlobEvent_get_event_impl(ptr, rust_vec_len, data_len),
161 => wire__web_audio_api__media_recorder__BlobEvent_get_timecode_impl(ptr, rust_vec_len, data_len),
162 => wire__web_audio_api__media_recorder__BlobEvent_set_blob_impl(ptr, rust_vec_len, data_len),
163 => wire__web_audio_api__media_recorder__BlobEvent_set_event_impl(ptr, rust_vec_len, data_len),
164 => wire__web_audio_api__media_recorder__BlobEvent_set_timecode_impl(ptr, rust_vec_len, data_len),
243 => wire__web_audio_api__node__media_element_source__MediaElementAudioSourceOptions_get_media_element_impl(ptr, rust_vec_len, data_len),
244 => wire__web_audio_api__node__media_element_source__MediaElementAudioSourceOptions_set_media_element_impl(ptr, rust_vec_len, data_len),
248 => wire__web_audio_api__node__media_stream_source__MediaStreamAudioSourceOptions_get_media_stream_impl(ptr, rust_vec_len, data_len),
249 => wire__web_audio_api__node__media_stream_source__MediaStreamAudioSourceOptions_set_media_stream_impl(ptr, rust_vec_len, data_len),
251 => wire__web_audio_api__node__media_stream_track_source__MediaStreamTrackAudioSourceOptions_get_media_stream_track_impl(ptr, rust_vec_len, data_len),
252 => wire__web_audio_api__node__media_stream_track_source__MediaStreamTrackAudioSourceOptions_set_media_stream_track_impl(ptr, rust_vec_len, data_len),
332 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_get_current_frame_impl(ptr, rust_vec_len, data_len),
333 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_get_current_time_impl(ptr, rust_vec_len, data_len),
334 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_get_sample_rate_impl(ptr, rust_vec_len, data_len),
336 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_set_current_frame_impl(ptr, rust_vec_len, data_len),
337 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_set_current_time_impl(ptr, rust_vec_len, data_len),
338 => wire__web_audio_api__render__processor__AudioWorkletGlobalScope_set_sample_rate_impl(ptr, rust_vec_len, data_len),
356 => wire__web_audio_api__spatial__AudioListenerParams_get_forward_x_impl(ptr, rust_vec_len, data_len),
357 => wire__web_audio_api__spatial__AudioListenerParams_get_forward_y_impl(ptr, rust_vec_len, data_len),
358 => wire__web_audio_api__spatial__AudioListenerParams_get_forward_z_impl(ptr, rust_vec_len, data_len),
359 => wire__web_audio_api__spatial__AudioListenerParams_get_position_x_impl(ptr, rust_vec_len, data_len),
360 => wire__web_audio_api__spatial__AudioListenerParams_get_position_y_impl(ptr, rust_vec_len, data_len),
361 => wire__web_audio_api__spatial__AudioListenerParams_get_position_z_impl(ptr, rust_vec_len, data_len),
362 => wire__web_audio_api__spatial__AudioListenerParams_get_up_x_impl(ptr, rust_vec_len, data_len),
363 => wire__web_audio_api__spatial__AudioListenerParams_get_up_y_impl(ptr, rust_vec_len, data_len),
364 => wire__web_audio_api__spatial__AudioListenerParams_get_up_z_impl(ptr, rust_vec_len, data_len),
365 => wire__web_audio_api__spatial__AudioListenerParams_set_forward_x_impl(ptr, rust_vec_len, data_len),
366 => wire__web_audio_api__spatial__AudioListenerParams_set_forward_y_impl(ptr, rust_vec_len, data_len),
367 => wire__web_audio_api__spatial__AudioListenerParams_set_forward_z_impl(ptr, rust_vec_len, data_len),
368 => wire__web_audio_api__spatial__AudioListenerParams_set_position_x_impl(ptr, rust_vec_len, data_len),
369 => wire__web_audio_api__spatial__AudioListenerParams_set_position_y_impl(ptr, rust_vec_len, data_len),
370 => wire__web_audio_api__spatial__AudioListenerParams_set_position_z_impl(ptr, rust_vec_len, data_len),
371 => wire__web_audio_api__spatial__AudioListenerParams_set_up_x_impl(ptr, rust_vec_len, data_len),
372 => wire__web_audio_api__spatial__AudioListenerParams_set_up_y_impl(ptr, rust_vec_len, data_len),
373 => wire__web_audio_api__spatial__AudioListenerParams_set_up_z_impl(ptr, rust_vec_len, data_len),
386 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_audio_node_options_impl(ptr, rust_vec_len, data_len),
387 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_number_of_inputs_impl(ptr, rust_vec_len, data_len),
388 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_number_of_outputs_impl(ptr, rust_vec_len, data_len),
389 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_output_channel_count_impl(ptr, rust_vec_len, data_len),
390 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_parameter_data_impl(ptr, rust_vec_len, data_len),
391 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_get_processor_options_impl(ptr, rust_vec_len, data_len),
392 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_audio_node_options_impl(ptr, rust_vec_len, data_len),
393 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_number_of_inputs_impl(ptr, rust_vec_len, data_len),
394 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_number_of_outputs_impl(ptr, rust_vec_len, data_len),
395 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_output_channel_count_impl(ptr, rust_vec_len, data_len),
396 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_parameter_data_impl(ptr, rust_vec_len, data_len),
397 => wire__web_audio_api__worklet__AudioWorkletNodeOptions_set_processor_options_impl(ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Alloc> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Alloc> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Alloc>> for Alloc {
    fn into_into_dart(self) -> FrbWrapper<Alloc> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Analyser> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Analyser> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Analyser>> for Analyser {
    fn into_into_dart(self) -> FrbWrapper<Analyser> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AnalyserNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AnalyserNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AnalyserNode>> for AnalyserNode {
    fn into_into_dart(self) -> FrbWrapper<AnalyserNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AnalyserRingBuffer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AnalyserRingBuffer>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AnalyserRingBuffer>> for AnalyserRingBuffer {
    fn into_into_dart(self) -> FrbWrapper<AnalyserRingBuffer> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<AtomicU64>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Arc<AtomicU64>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<AtomicU64>>> for Arc<AtomicU64> {
    fn into_into_dart(self) -> FrbWrapper<Arc<AtomicU64>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Arc<AtomicU8>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Arc<AtomicU8>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Arc<AtomicU8>>> for Arc<AtomicU8> {
    fn into_into_dart(self) -> FrbWrapper<Arc<AtomicU8>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AtomicF32> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AtomicF32> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AtomicF32>> for AtomicF32 {
    fn into_into_dart(self) -> FrbWrapper<AtomicF32> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AtomicF64> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AtomicF64> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AtomicF64>> for AtomicF64 {
    fn into_into_dart(self) -> FrbWrapper<AtomicF64> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioBufferSourceNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioBufferSourceNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioBufferSourceNode>>
    for AudioBufferSourceNode
{
    fn into_into_dart(self) -> FrbWrapper<AudioBufferSourceNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioContext> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioContext> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioContext>> for AudioContext {
    fn into_into_dart(self) -> FrbWrapper<AudioContext> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioDestinationNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioDestinationNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioDestinationNode>> for AudioDestinationNode {
    fn into_into_dart(self) -> FrbWrapper<AudioDestinationNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioListener> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioListener> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioListener>> for AudioListener {
    fn into_into_dart(self) -> FrbWrapper<AudioListener> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioListenerNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioListenerNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioListenerNode>> for AudioListenerNode {
    fn into_into_dart(self) -> FrbWrapper<AudioListenerNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioListenerParams> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioListenerParams>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioListenerParams>> for AudioListenerParams {
    fn into_into_dart(self) -> FrbWrapper<AudioListenerParams> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioParam> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioParam> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioParam>> for AudioParam {
    fn into_into_dart(self) -> FrbWrapper<AudioParam> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioParamInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioParamInner> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioParamInner>> for AudioParamInner {
    fn into_into_dart(self) -> FrbWrapper<AudioParamInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioRenderCapacity> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioRenderCapacity>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioRenderCapacity>> for AudioRenderCapacity {
    fn into_into_dart(self) -> FrbWrapper<AudioRenderCapacity> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioRenderCapacityEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioRenderCapacityEvent>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioRenderCapacityEvent>>
    for AudioRenderCapacityEvent
{
    fn into_into_dart(self) -> FrbWrapper<AudioRenderCapacityEvent> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioRenderQuantum> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioRenderQuantum>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioRenderQuantum>> for AudioRenderQuantum {
    fn into_into_dart(self) -> FrbWrapper<AudioRenderQuantum> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioRenderQuantumChannel> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioRenderQuantumChannel>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioRenderQuantumChannel>>
    for AudioRenderQuantumChannel
{
    fn into_into_dart(self) -> FrbWrapper<AudioRenderQuantumChannel> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioWorkletGlobalScope> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioWorkletGlobalScope>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioWorkletGlobalScope>>
    for AudioWorkletGlobalScope
{
    fn into_into_dart(self) -> FrbWrapper<AudioWorkletGlobalScope> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioWorkletNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AudioWorkletNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioWorkletNode>> for AudioWorkletNode {
    fn into_into_dart(self) -> FrbWrapper<AudioWorkletNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AudioWorkletNodeOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AudioWorkletNodeOptions>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AudioWorkletNodeOptions>>
    for AudioWorkletNodeOptions
{
    fn into_into_dart(self) -> FrbWrapper<AudioWorkletNodeOptions> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BiquadFilterNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BiquadFilterNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BiquadFilterNode>> for BiquadFilterNode {
    fn into_into_dart(self) -> FrbWrapper<BiquadFilterNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BlobEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BlobEvent> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BlobEvent>> for BlobEvent {
    fn into_into_dart(self) -> FrbWrapper<BlobEvent> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Box<dyn Any + Send>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Box<dyn Any + Send>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box<dyn Any + Send>>> for Box<dyn Any + Send> {
    fn into_into_dart(self) -> FrbWrapper<Box<dyn Any + Send>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Box<dyn Any + Send + 'static>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Box<dyn Any + Send + 'static>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box<dyn Any + Send + 'static>>>
    for Box<dyn Any + Send + 'static>
{
    fn into_into_dart(self) -> FrbWrapper<Box<dyn Any + Send + 'static>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Box<dyn AudioProcessor>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Box<dyn AudioProcessor>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box<dyn AudioProcessor>>>
    for Box<dyn AudioProcessor>
{
    fn into_into_dart(self) -> FrbWrapper<Box<dyn AudioProcessor>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Box<dyn Error>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Box<dyn Error>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box<dyn Error>>> for Box<dyn Error> {
    fn into_into_dart(self) -> FrbWrapper<Box<dyn Error>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>>
{
}

impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>>,
    > for Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Box<dyn std::error::Error + Send + Sync>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Box<dyn std::error::Error + Send + Sync>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Box<dyn std::error::Error + Send + Sync>>>
    for Box<dyn std::error::Error + Send + Sync>
{
    fn into_into_dart(self) -> FrbWrapper<Box<dyn std::error::Error + Send + Sync>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<C> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<C> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<C>> for C {
    fn into_into_dart(self) -> FrbWrapper<C> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelData> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelData>> for ChannelData {
    fn into_into_dart(self) -> FrbWrapper<ChannelData> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelMergerNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelMergerNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelMergerNode>> for ChannelMergerNode {
    fn into_into_dart(self) -> FrbWrapper<ChannelMergerNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelSplitterNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ChannelSplitterNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelSplitterNode>> for ChannelSplitterNode {
    fn into_into_dart(self) -> FrbWrapper<ChannelSplitterNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConcreteBaseAudioContext> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ConcreteBaseAudioContext>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConcreteBaseAudioContext>>
    for ConcreteBaseAudioContext
{
    fn into_into_dart(self) -> FrbWrapper<ConcreteBaseAudioContext> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConstantSourceNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ConstantSourceNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConstantSourceNode>> for ConstantSourceNode {
    fn into_into_dart(self) -> FrbWrapper<ConstantSourceNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ControlThreadInit> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ControlThreadInit> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ControlThreadInit>> for ControlThreadInit {
    fn into_into_dart(self) -> FrbWrapper<ControlThreadInit> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConvolverNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ConvolverNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConvolverNode>> for ConvolverNode {
    fn into_into_dart(self) -> FrbWrapper<ConvolverNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DelayNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<DelayNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DelayNode>> for DelayNode {
    fn into_into_dart(self) -> FrbWrapper<DelayNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DynamicsCompressorNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<DynamicsCompressorNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DynamicsCompressorNode>>
    for DynamicsCompressorNode
{
    fn into_into_dart(self) -> FrbWrapper<DynamicsCompressorNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ErrorEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ErrorEvent> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ErrorEvent>> for ErrorEvent {
    fn into_into_dart(self) -> FrbWrapper<ErrorEvent> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Event> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Event> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Event>> for Event {
    fn into_into_dart(self) -> FrbWrapper<Event> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EventDispatch> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EventDispatch> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EventDispatch>> for EventDispatch {
    fn into_into_dart(self) -> FrbWrapper<EventDispatch> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EventHandler> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EventHandler> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EventHandler>> for EventHandler {
    fn into_into_dart(self) -> FrbWrapper<EventHandler> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EventLoop> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<EventLoop> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EventLoop>> for EventLoop {
    fn into_into_dart(self) -> FrbWrapper<EventLoop> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<F> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<F> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<F>> for F {
    fn into_into_dart(self) -> FrbWrapper<F> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GainNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<GainNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GainNode>> for GainNode {
    fn into_into_dart(self) -> FrbWrapper<GainNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Graph> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Graph> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Graph>> for Graph {
    fn into_into_dart(self) -> FrbWrapper<Graph> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<IIRFilterNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<IIRFilterNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<IIRFilterNode>> for IIRFilterNode {
    fn into_into_dart(self) -> FrbWrapper<IIRFilterNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<M> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<M> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<M>> for M {
    fn into_into_dart(self) -> FrbWrapper<M> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaDecoder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaDecoder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaDecoder>> for MediaDecoder {
    fn into_into_dart(self) -> FrbWrapper<MediaDecoder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaDeviceInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaDeviceInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaDeviceInfo>> for MediaDeviceInfo {
    fn into_into_dart(self) -> FrbWrapper<MediaDeviceInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaElement> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaElement> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaElement>> for MediaElement {
    fn into_into_dart(self) -> FrbWrapper<MediaElement> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaElementAudioSourceNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaElementAudioSourceNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaElementAudioSourceNode>>
    for MediaElementAudioSourceNode
{
    fn into_into_dart(self) -> FrbWrapper<MediaElementAudioSourceNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaElementAudioSourceOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaElementAudioSourceOptions>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaElementAudioSourceOptions>>
    for MediaElementAudioSourceOptions
{
    fn into_into_dart(self) -> FrbWrapper<MediaElementAudioSourceOptions> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaInput> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaInput> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaInput>> for MediaInput {
    fn into_into_dart(self) -> FrbWrapper<MediaInput> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaRecorder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaRecorder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaRecorder>> for MediaRecorder {
    fn into_into_dart(self) -> FrbWrapper<MediaRecorder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaStreamAudioDestinationNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaStreamAudioDestinationNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaStreamAudioDestinationNode>>
    for MediaStreamAudioDestinationNode
{
    fn into_into_dart(self) -> FrbWrapper<MediaStreamAudioDestinationNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaStreamAudioSourceNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaStreamAudioSourceNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaStreamAudioSourceNode>>
    for MediaStreamAudioSourceNode
{
    fn into_into_dart(self) -> FrbWrapper<MediaStreamAudioSourceNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaStreamAudioSourceOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaStreamAudioSourceOptions>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaStreamAudioSourceOptions>>
    for MediaStreamAudioSourceOptions
{
    fn into_into_dart(self) -> FrbWrapper<MediaStreamAudioSourceOptions> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaStreamTrack> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MediaStreamTrack> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaStreamTrack>> for MediaStreamTrack {
    fn into_into_dart(self) -> FrbWrapper<MediaStreamTrack> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaStreamTrackAudioSourceNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaStreamTrackAudioSourceNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaStreamTrackAudioSourceNode>>
    for MediaStreamTrackAudioSourceNode
{
    fn into_into_dart(self) -> FrbWrapper<MediaStreamTrackAudioSourceNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MediaStreamTrackAudioSourceOptions> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MediaStreamTrackAudioSourceOptions>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MediaStreamTrackAudioSourceOptions>>
    for MediaStreamTrackAudioSourceOptions
{
    fn into_into_dart(self) -> FrbWrapper<MediaStreamTrackAudioSourceOptions> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MessagePort> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MessagePort> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MessagePort>> for MessagePort {
    fn into_into_dart(self) -> FrbWrapper<MessagePort> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MicrophoneRender> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MicrophoneRender> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MicrophoneRender>> for MicrophoneRender {
    fn into_into_dart(self) -> FrbWrapper<MicrophoneRender> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Node> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Node> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Node>> for Node {
    fn into_into_dart(self) -> FrbWrapper<Node> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OfflineAudioCompletionEvent> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<OfflineAudioCompletionEvent>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OfflineAudioCompletionEvent>>
    for OfflineAudioCompletionEvent
{
    fn into_into_dart(self) -> FrbWrapper<OfflineAudioCompletionEvent> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OfflineAudioContext> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<OfflineAudioContext>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OfflineAudioContext>> for OfflineAudioContext {
    fn into_into_dart(self) -> FrbWrapper<OfflineAudioContext> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OneshotNotify> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OneshotNotify> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OneshotNotify>> for OneshotNotify {
    fn into_into_dart(self) -> FrbWrapper<OneshotNotify> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Ordering> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Ordering> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Ordering>> for Ordering {
    fn into_into_dart(self) -> FrbWrapper<Ordering> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OscillatorNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OscillatorNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OscillatorNode>> for OscillatorNode {
    fn into_into_dart(self) -> FrbWrapper<OscillatorNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<P> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<P> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<P>> for P {
    fn into_into_dart(self) -> FrbWrapper<P> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PannerNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PannerNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PannerNode>> for PannerNode {
    fn into_into_dart(self) -> FrbWrapper<PannerNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PeriodicWave> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PeriodicWave> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PeriodicWave>> for PeriodicWave {
    fn into_into_dart(self) -> FrbWrapper<PeriodicWave> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<R> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<R> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<R>> for R {
    fn into_into_dart(self) -> FrbWrapper<R> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Receiver<AudioRenderCapacityLoad>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Receiver<AudioRenderCapacityLoad>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Receiver<AudioRenderCapacityLoad>>>
    for Receiver<AudioRenderCapacityLoad>
{
    fn into_into_dart(self) -> FrbWrapper<Receiver<AudioRenderCapacityLoad>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Receiver<ControlMessage>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Receiver<ControlMessage>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Receiver<ControlMessage>>>
    for Receiver<ControlMessage>
{
    fn into_into_dart(self) -> FrbWrapper<Receiver<ControlMessage>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Receiver<EventDispatch>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Receiver<EventDispatch>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Receiver<EventDispatch>>>
    for Receiver<EventDispatch>
{
    fn into_into_dart(self) -> FrbWrapper<Receiver<EventDispatch>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<RefCell<Node>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<RefCell<Node>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<RefCell<Node>>> for RefCell<Node> {
    fn into_into_dart(self) -> FrbWrapper<RefCell<Node>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<RenderThread> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<RenderThread> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<RenderThread>> for RenderThread {
    fn into_into_dart(self) -> FrbWrapper<RenderThread> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<RenderThreadInit> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<RenderThreadInit> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<RenderThreadInit>> for RenderThreadInit {
    fn into_into_dart(self) -> FrbWrapper<RenderThreadInit> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Resampler> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Resampler> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Resampler>> for Resampler {
    fn into_into_dart(self) -> FrbWrapper<Resampler> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ScriptProcessorNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ScriptProcessorNode>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ScriptProcessorNode>> for ScriptProcessorNode {
    fn into_into_dart(self) -> FrbWrapper<ScriptProcessorNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Sender<AudioBuffer>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Sender<AudioBuffer>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Sender<AudioBuffer>>> for Sender<AudioBuffer> {
    fn into_into_dart(self) -> FrbWrapper<Sender<AudioBuffer>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Sender<AudioRenderCapacityLoad>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Sender<AudioRenderCapacityLoad>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Sender<AudioRenderCapacityLoad>>>
    for Sender<AudioRenderCapacityLoad>
{
    fn into_into_dart(self) -> FrbWrapper<Sender<AudioRenderCapacityLoad>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Sender<ControlMessage>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Sender<ControlMessage>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Sender<ControlMessage>>>
    for Sender<ControlMessage>
{
    fn into_into_dart(self) -> FrbWrapper<Sender<ControlMessage>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Sender<EventDispatch>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<Sender<EventDispatch>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Sender<EventDispatch>>>
    for Sender<EventDispatch>
{
    fn into_into_dart(self) -> FrbWrapper<Sender<EventDispatch>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<StereoPannerNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<StereoPannerNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<StereoPannerNode>> for StereoPannerNode {
    fn into_into_dart(self) -> FrbWrapper<StereoPannerNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Stream> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Stream> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Stream>> for Stream {
    fn into_into_dart(self) -> FrbWrapper<Stream> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<T> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<T> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<T>> for T {
    fn into_into_dart(self) -> FrbWrapper<T> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ThreadSafeClosableStream> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ThreadSafeClosableStream>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ThreadSafeClosableStream>>
    for ThreadSafeClosableStream
{
    fn into_into_dart(self) -> FrbWrapper<ThreadSafeClosableStream> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Vector3<f32>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Vector3<f32>> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Vector3<f32>>> for Vector3<f32> {
    fn into_into_dart(self) -> FrbWrapper<Vector3<f32>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<WaveShaperNode> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<WaveShaperNode> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<WaveShaperNode>> for WaveShaperNode {
    fn into_into_dart(self) -> FrbWrapper<WaveShaperNode> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<llq::Producer<AudioNodeId>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<llq::Producer<AudioNodeId>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<llq::Producer<AudioNodeId>>>
    for llq::Producer<AudioNodeId>
{
    fn into_into_dart(self) -> FrbWrapper<llq::Producer<AudioNodeId>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<mpsc::Receiver<()>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<mpsc::Receiver<()>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<mpsc::Receiver<()>>> for mpsc::Receiver<()> {
    fn into_into_dart(self) -> FrbWrapper<mpsc::Receiver<()>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<oneshot::Sender<()>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<oneshot::Sender<()>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<oneshot::Sender<()>>> for oneshot::Sender<()> {
    fn into_into_dart(self) -> FrbWrapper<oneshot::Sender<()>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::analyser::AnalyserOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.fft_size.into_into_dart().into_dart(),
            self.max_decibels.into_into_dart().into_dart(),
            self.min_decibels.into_into_dart().into_dart(),
            self.smoothing_time_constant.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::analyser::AnalyserOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::analyser::AnalyserOptions>
    for web_audio_api::node::analyser::AnalyserOptions
{
    fn into_into_dart(self) -> web_audio_api::node::analyser::AnalyserOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::buffer::AudioBuffer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channels.into_into_dart().into_dart(),
            self.sample_rate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::buffer::AudioBuffer
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::buffer::AudioBuffer>
    for web_audio_api::buffer::AudioBuffer
{
    fn into_into_dart(self) -> web_audio_api::buffer::AudioBuffer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::buffer::AudioBufferOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.number_of_channels.into_into_dart().into_dart(),
            self.length.into_into_dart().into_dart(),
            self.sample_rate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::buffer::AudioBufferOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::buffer::AudioBufferOptions>
    for web_audio_api::buffer::AudioBufferOptions
{
    fn into_into_dart(self) -> web_audio_api::buffer::AudioBufferOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.buffer.into_into_dart().into_dart(),
            self.detune.into_into_dart().into_dart(),
            self.loop_.into_into_dart().into_dart(),
            self.loop_start.into_into_dart().into_dart(),
            self.loop_end.into_into_dart().into_dart(),
            self.playback_rate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions,
    > for web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions
{
    fn into_into_dart(self) -> web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::context::online::AudioContextLatencyCategory {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            web_audio_api::context::online::AudioContextLatencyCategory::Balanced => {
                [0.into_dart()].into_dart()
            }
            web_audio_api::context::online::AudioContextLatencyCategory::Interactive => {
                [1.into_dart()].into_dart()
            }
            web_audio_api::context::online::AudioContextLatencyCategory::Playback => {
                [2.into_dart()].into_dart()
            }
            web_audio_api::context::online::AudioContextLatencyCategory::Custom(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::context::online::AudioContextLatencyCategory
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::context::online::AudioContextLatencyCategory>
    for web_audio_api::context::online::AudioContextLatencyCategory
{
    fn into_into_dart(self) -> web_audio_api::context::online::AudioContextLatencyCategory {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::context::online::AudioContextOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.latency_hint.into_into_dart().into_dart(),
            self.sample_rate.into_into_dart().into_dart(),
            self.sink_id.into_into_dart().into_dart(),
            self.render_size_hint.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::context::online::AudioContextOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::context::online::AudioContextOptions>
    for web_audio_api::context::online::AudioContextOptions
{
    fn into_into_dart(self) -> web_audio_api::context::online::AudioContextOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for web_audio_api::context::online::AudioContextRenderSizeCategory
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Default => 0.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::context::online::AudioContextRenderSizeCategory
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        web_audio_api::context::online::AudioContextRenderSizeCategory,
    > for web_audio_api::context::online::AudioContextRenderSizeCategory
{
    fn into_into_dart(self) -> web_audio_api::context::online::AudioContextRenderSizeCategory {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::context::AudioContextState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Suspended => 0.into_dart(),
            Self::Running => 1.into_dart(),
            Self::Closed => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::context::AudioContextState
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::context::AudioContextState>
    for web_audio_api::context::AudioContextState
{
    fn into_into_dart(self) -> web_audio_api::context::AudioContextState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::context::AudioNodeId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::context::AudioNodeId
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::context::AudioNodeId>
    for web_audio_api::context::AudioNodeId
{
    fn into_into_dart(self) -> web_audio_api::context::AudioNodeId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::audio_node::AudioNodeOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channel_count.into_into_dart().into_dart(),
            self.channel_count_mode.into_into_dart().into_dart(),
            self.channel_interpretation.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::audio_node::AudioNodeOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::audio_node::AudioNodeOptions>
    for web_audio_api::node::audio_node::AudioNodeOptions
{
    fn into_into_dart(self) -> web_audio_api::node::audio_node::AudioNodeOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::events::AudioProcessingEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.input_buffer.into_into_dart().into_dart(),
            self.output_buffer.into_into_dart().into_dart(),
            self.playback_time.into_into_dart().into_dart(),
            self.registration.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::events::AudioProcessingEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::events::AudioProcessingEvent>
    for web_audio_api::events::AudioProcessingEvent
{
    fn into_into_dart(self) -> web_audio_api::events::AudioProcessingEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::capacity::AudioRenderCapacityOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.update_interval.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::capacity::AudioRenderCapacityOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::capacity::AudioRenderCapacityOptions>
    for web_audio_api::capacity::AudioRenderCapacityOptions
{
    fn into_into_dart(self) -> web_audio_api::capacity::AudioRenderCapacityOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::param::AutomationRate {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::A => 0.into_dart(),
            Self::K => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::param::AutomationRate
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::param::AutomationRate>
    for web_audio_api::param::AutomationRate
{
    fn into_into_dart(self) -> web_audio_api::param::AutomationRate {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::biquad_filter::BiquadFilterOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.q.into_into_dart().into_dart(),
            self.detune.into_into_dart().into_dart(),
            self.frequency.into_into_dart().into_dart(),
            self.gain.into_into_dart().into_dart(),
            self.type_.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::biquad_filter::BiquadFilterOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::biquad_filter::BiquadFilterOptions>
    for web_audio_api::node::biquad_filter::BiquadFilterOptions
{
    fn into_into_dart(self) -> web_audio_api::node::biquad_filter::BiquadFilterOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::biquad_filter::BiquadFilterType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Lowpass => 0.into_dart(),
            Self::Highpass => 1.into_dart(),
            Self::Bandpass => 2.into_dart(),
            Self::Notch => 3.into_dart(),
            Self::Allpass => 4.into_dart(),
            Self::Peaking => 5.into_dart(),
            Self::Lowshelf => 6.into_dart(),
            Self::Highshelf => 7.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::biquad_filter::BiquadFilterType
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::biquad_filter::BiquadFilterType>
    for web_audio_api::node::biquad_filter::BiquadFilterType
{
    fn into_into_dart(self) -> web_audio_api::node::biquad_filter::BiquadFilterType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::audio_node::ChannelConfigInner {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.count.into_into_dart().into_dart(),
            self.count_mode.into_into_dart().into_dart(),
            self.interpretation.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::audio_node::ChannelConfigInner
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::audio_node::ChannelConfigInner>
    for web_audio_api::node::audio_node::ChannelConfigInner
{
    fn into_into_dart(self) -> web_audio_api::node::audio_node::ChannelConfigInner {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::audio_node::ChannelCountMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Max => 0.into_dart(),
            Self::ClampedMax => 1.into_dart(),
            Self::Explicit => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::audio_node::ChannelCountMode
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::audio_node::ChannelCountMode>
    for web_audio_api::node::audio_node::ChannelCountMode
{
    fn into_into_dart(self) -> web_audio_api::node::audio_node::ChannelCountMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::audio_node::ChannelInterpretation {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Speakers => 0.into_dart(),
            Self::Discrete => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::audio_node::ChannelInterpretation
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::audio_node::ChannelInterpretation>
    for web_audio_api::node::audio_node::ChannelInterpretation
{
    fn into_into_dart(self) -> web_audio_api::node::audio_node::ChannelInterpretation {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::channel_merger::ChannelMergerOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.number_of_inputs.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::channel_merger::ChannelMergerOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::channel_merger::ChannelMergerOptions>
    for web_audio_api::node::channel_merger::ChannelMergerOptions
{
    fn into_into_dart(self) -> web_audio_api::node::channel_merger::ChannelMergerOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for web_audio_api::node::channel_splitter::ChannelSplitterOptions
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.number_of_outputs.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::channel_splitter::ChannelSplitterOptions
{
}
impl
    flutter_rust_bridge::IntoIntoDart<web_audio_api::node::channel_splitter::ChannelSplitterOptions>
    for web_audio_api::node::channel_splitter::ChannelSplitterOptions
{
    fn into_into_dart(self) -> web_audio_api::node::channel_splitter::ChannelSplitterOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::constant_source::ConstantSourceOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.offset.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::constant_source::ConstantSourceOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::constant_source::ConstantSourceOptions>
    for web_audio_api::node::constant_source::ConstantSourceOptions
{
    fn into_into_dart(self) -> web_audio_api::node::constant_source::ConstantSourceOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::convolver::ConvolverOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.buffer.into_into_dart().into_dart(),
            self.disable_normalization.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::convolver::ConvolverOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::convolver::ConvolverOptions>
    for web_audio_api::node::convolver::ConvolverOptions
{
    fn into_into_dart(self) -> web_audio_api::node::convolver::ConvolverOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::delay::DelayOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_delay_time.into_into_dart().into_dart(),
            self.delay_time.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::delay::DelayOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::delay::DelayOptions>
    for web_audio_api::node::delay::DelayOptions
{
    fn into_into_dart(self) -> web_audio_api::node::delay::DelayOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::panner::DistanceModelType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Linear => 0.into_dart(),
            Self::Inverse => 1.into_dart(),
            Self::Exponential => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::panner::DistanceModelType
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::panner::DistanceModelType>
    for web_audio_api::node::panner::DistanceModelType
{
    fn into_into_dart(self) -> web_audio_api::node::panner::DistanceModelType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.attack.into_into_dart().into_dart(),
            self.knee.into_into_dart().into_dart(),
            self.ratio.into_into_dart().into_dart(),
            self.release.into_into_dart().into_dart(),
            self.threshold.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions,
    > for web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions
{
    fn into_into_dart(self) -> web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::events::EventType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            web_audio_api::events::EventType::Ended(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            web_audio_api::events::EventType::SinkChange => [1.into_dart()].into_dart(),
            web_audio_api::events::EventType::StateChange => [2.into_dart()].into_dart(),
            web_audio_api::events::EventType::RenderCapacity => [3.into_dart()].into_dart(),
            web_audio_api::events::EventType::ProcessorError(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            web_audio_api::events::EventType::Diagnostics => [5.into_dart()].into_dart(),
            web_audio_api::events::EventType::Message(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            web_audio_api::events::EventType::Complete => [7.into_dart()].into_dart(),
            web_audio_api::events::EventType::AudioProcessing(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::events::EventType
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::events::EventType>
    for web_audio_api::events::EventType
{
    fn into_into_dart(self) -> web_audio_api::events::EventType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::gain::GainOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.gain.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::gain::GainOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::gain::GainOptions>
    for web_audio_api::node::gain::GainOptions
{
    fn into_into_dart(self) -> web_audio_api::node::gain::GainOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::iir_filter::IIRFilterOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.audio_node_options.into_into_dart().into_dart(),
            self.feedforward.into_into_dart().into_dart(),
            self.feedback.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::iir_filter::IIRFilterOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::iir_filter::IIRFilterOptions>
    for web_audio_api::node::iir_filter::IIRFilterOptions
{
    fn into_into_dart(self) -> web_audio_api::node::iir_filter::IIRFilterOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::media_devices::MediaDeviceInfoKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::VideoInput => 0.into_dart(),
            Self::AudioInput => 1.into_dart(),
            Self::AudioOutput => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::media_devices::MediaDeviceInfoKind
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::media_devices::MediaDeviceInfoKind>
    for web_audio_api::media_devices::MediaDeviceInfoKind
{
    fn into_into_dart(self) -> web_audio_api::media_devices::MediaDeviceInfoKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::media_streams::MediaStream {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.tracks.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::media_streams::MediaStream
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::media_streams::MediaStream>
    for web_audio_api::media_streams::MediaStream
{
    fn into_into_dart(self) -> web_audio_api::media_streams::MediaStream {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::media_devices::MediaStreamConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            web_audio_api::media_devices::MediaStreamConstraints::Audio => {
                [0.into_dart()].into_dart()
            }
            web_audio_api::media_devices::MediaStreamConstraints::AudioWithConstraints(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::media_devices::MediaStreamConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::media_devices::MediaStreamConstraints>
    for web_audio_api::media_devices::MediaStreamConstraints
{
    fn into_into_dart(self) -> web_audio_api::media_devices::MediaStreamConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::media_streams::MediaStreamTrackState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Live => 0.into_dart(),
            Self::Ended => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::media_streams::MediaStreamTrackState
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::media_streams::MediaStreamTrackState>
    for web_audio_api::media_streams::MediaStreamTrackState
{
    fn into_into_dart(self) -> web_audio_api::media_streams::MediaStreamTrackState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::media_devices::MediaTrackConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sample_rate.into_into_dart().into_dart(),
            self.latency.into_into_dart().into_dart(),
            self.channel_count.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::media_devices::MediaTrackConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::media_devices::MediaTrackConstraints>
    for web_audio_api::media_devices::MediaTrackConstraints
{
    fn into_into_dart(self) -> web_audio_api::media_devices::MediaTrackConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::render::node_collection::NodeCollection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.nodes.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::render::node_collection::NodeCollection
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::render::node_collection::NodeCollection>
    for web_audio_api::render::node_collection::NodeCollection
{
    fn into_into_dart(self) -> web_audio_api::render::node_collection::NodeCollection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::oscillator::OscillatorOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.type_.into_into_dart().into_dart(),
            self.frequency.into_into_dart().into_dart(),
            self.detune.into_into_dart().into_dart(),
            self.periodic_wave.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::oscillator::OscillatorOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::oscillator::OscillatorOptions>
    for web_audio_api::node::oscillator::OscillatorOptions
{
    fn into_into_dart(self) -> web_audio_api::node::oscillator::OscillatorOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::oscillator::OscillatorType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Sine => 0.into_dart(),
            Self::Square => 1.into_dart(),
            Self::Sawtooth => 2.into_dart(),
            Self::Triangle => 3.into_dart(),
            Self::Custom => 4.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::oscillator::OscillatorType
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::oscillator::OscillatorType>
    for web_audio_api::node::oscillator::OscillatorType
{
    fn into_into_dart(self) -> web_audio_api::node::oscillator::OscillatorType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::waveshaper::OverSampleType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::None => 0.into_dart(),
            Self::X2 => 1.into_dart(),
            Self::X4 => 2.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::waveshaper::OverSampleType
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::waveshaper::OverSampleType>
    for web_audio_api::node::waveshaper::OverSampleType
{
    fn into_into_dart(self) -> web_audio_api::node::waveshaper::OverSampleType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::panner::PannerOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.panning_model.into_into_dart().into_dart(),
            self.distance_model.into_into_dart().into_dart(),
            self.position_x.into_into_dart().into_dart(),
            self.position_y.into_into_dart().into_dart(),
            self.position_z.into_into_dart().into_dart(),
            self.orientation_x.into_into_dart().into_dart(),
            self.orientation_y.into_into_dart().into_dart(),
            self.orientation_z.into_into_dart().into_dart(),
            self.ref_distance.into_into_dart().into_dart(),
            self.max_distance.into_into_dart().into_dart(),
            self.rolloff_factor.into_into_dart().into_dart(),
            self.cone_inner_angle.into_into_dart().into_dart(),
            self.cone_outer_angle.into_into_dart().into_dart(),
            self.cone_outer_gain.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::panner::PannerOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::panner::PannerOptions>
    for web_audio_api::node::panner::PannerOptions
{
    fn into_into_dart(self) -> web_audio_api::node::panner::PannerOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::panner::PanningModelType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::EqualPower => 0.into_dart(),
            Self::HRTF => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::panner::PanningModelType
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::panner::PanningModelType>
    for web_audio_api::node::panner::PanningModelType
{
    fn into_into_dart(self) -> web_audio_api::node::panner::PanningModelType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::periodic_wave::PeriodicWaveOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.real.into_into_dart().into_dart(),
            self.imag.into_into_dart().into_dart(),
            self.disable_normalization.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::periodic_wave::PeriodicWaveOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::periodic_wave::PeriodicWaveOptions>
    for web_audio_api::periodic_wave::PeriodicWaveOptions
{
    fn into_into_dart(self) -> web_audio_api::periodic_wave::PeriodicWaveOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for web_audio_api::node::script_processor::ScriptProcessorOptions
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.buffer_size.into_into_dart().into_dart(),
            self.number_of_input_channels.into_into_dart().into_dart(),
            self.number_of_output_channels.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::script_processor::ScriptProcessorOptions
{
}
impl
    flutter_rust_bridge::IntoIntoDart<web_audio_api::node::script_processor::ScriptProcessorOptions>
    for web_audio_api::node::script_processor::ScriptProcessorOptions
{
    fn into_into_dart(self) -> web_audio_api::node::script_processor::ScriptProcessorOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::stereo_panner::StereoPannerOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pan.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::stereo_panner::StereoPannerOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::stereo_panner::StereoPannerOptions>
    for web_audio_api::node::stereo_panner::StereoPannerOptions
{
    fn into_into_dart(self) -> web_audio_api::node::stereo_panner::StereoPannerOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for web_audio_api::node::waveshaper::WaveShaperOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.curve.into_into_dart().into_dart(),
            self.oversample.into_into_dart().into_dart(),
            self.audio_node_options.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for web_audio_api::node::waveshaper::WaveShaperOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<web_audio_api::node::waveshaper::WaveShaperOptions>
    for web_audio_api::node::waveshaper::WaveShaperOptions
{
    fn into_into_dart(self) -> web_audio_api::node::waveshaper::WaveShaperOptions {
        self
    }
}

impl SseEncode for Alloc {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Analyser {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AnalyserNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AnalyserRingBuffer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Arc<AtomicU64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < AtomicU64 >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Arc<AtomicU8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < AtomicU8 >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AtomicF32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AtomicF64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioBufferSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for AudioContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioDestinationNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for AudioListener {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioListenerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioListenerParams {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioParam {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioParamInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParamInner>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioRenderCapacity {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioRenderCapacityEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for AudioRenderQuantum {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioRenderQuantumChannel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for AudioWorkletGlobalScope {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for AudioWorkletNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for AudioWorkletNodeOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for BiquadFilterNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for BlobEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Box<dyn Any + Send> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Any + Send >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Box<dyn Any + Send + 'static> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send + 'static>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Box<dyn AudioProcessor> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn AudioProcessor>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Box<dyn Error> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box < dyn Error >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Box<dyn std::error::Error + Send + Sync> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Box<dyn std::error::Error + Send + Sync>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for C {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ChannelData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelMergerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelSplitterNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ConcreteBaseAudioContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ConstantSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ControlThreadInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ConvolverNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for DelayNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for DynamicsCompressorNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ErrorEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for EventDispatch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventDispatch>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EventHandler {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventHandler>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for EventLoop {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for F {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GainNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Graph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for IIRFilterNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for M {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaDecoder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MediaDeviceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MediaElement {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MediaElementAudioSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaElementAudioSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceOptions>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaInput {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MediaRecorder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MediaStreamAudioDestinationNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                MediaStreamAudioDestinationNode,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaStreamAudioSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaStreamAudioSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceOptions>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaStreamTrack {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MediaStreamTrackAudioSourceNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                MediaStreamTrackAudioSourceNode,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MediaStreamTrackAudioSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                MediaStreamTrackAudioSourceOptions,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MessagePort {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for MicrophoneRender {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MicrophoneRender>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for OfflineAudioCompletionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for OfflineAudioContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for OneshotNotify {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Ordering {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for OscillatorNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for P {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for PannerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for PeriodicWave {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for R {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Receiver<AudioRenderCapacityLoad> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Receiver<AudioRenderCapacityLoad>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Receiver<ControlMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<ControlMessage>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Receiver<EventDispatch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<EventDispatch>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for RefCell<Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell < Node >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for RenderThread {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThread>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for RenderThreadInit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Resampler {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for ScriptProcessorNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Sender<AudioBuffer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < AudioBuffer >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Sender<AudioRenderCapacityLoad> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                Sender<AudioRenderCapacityLoad>,
            >,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Sender<ControlMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<ControlMessage>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Sender<EventDispatch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<EventDispatch>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for StereoPannerNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Stream {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stream>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for T {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<T>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ThreadSafeClosableStream {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Vector3<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3 < f32 >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for WaveShaperNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for llq::Producer<AudioNodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<llq::Producer<AudioNodeId>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for mpsc::Receiver<()> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<mpsc :: Receiver < () >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for oneshot::Sender<()> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<oneshot :: Sender < () >>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, f64)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Analyser>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserRingBuffer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU64>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc<AtomicU8>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF32>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AtomicF64>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContext>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioContextRegistration>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListener>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioListenerParams>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParam>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioParamInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacity>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderCapacityEvent>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletGlobalScope>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioWorkletNodeOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BlobEvent>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Any + Send + 'static>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn AudioProcessor>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Box<dyn Error>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
            Box<dyn std::error::Error + Send + Sync>,
        >,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<C>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConcreteBaseAudioContext>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ErrorEvent>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventDispatch>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventHandler>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventLoop>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<F>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Graph>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HashMap<String, AudioParam>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<M>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDecoder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaDeviceInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElement>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaInput>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaRecorder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStream>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrack>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceNode>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceOptions>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MessagePort>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MicrophoneRender>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeCollection>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioCompletionEvent>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OfflineAudioContext>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OneshotNotify>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Ordering>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeriodicWave>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<R>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<AudioRenderCapacityLoad>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<ControlMessage>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Receiver<EventDispatch>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThread>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Resampler>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[S]>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Self>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioBuffer>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<AudioRenderCapacityLoad>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<ControlMessage>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender<EventDispatch>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Stream>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<T>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ThreadSafeClosableStream>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Vector3<f32>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<dyn Any>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<llq::Producer<AudioNodeId>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<mpsc::Receiver<()>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<oneshot::Sender<()>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[u8]>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for web_audio_api::node::analyser::AnalyserOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.fft_size, serializer);
        <f64>::sse_encode(self.max_decibels, serializer);
        <f64>::sse_encode(self.min_decibels, serializer);
        <f64>::sse_encode(self.smoothing_time_constant, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::buffer::AudioBuffer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<ChannelData>>::sse_encode(self.channels, serializer);
        <f32>::sse_encode(self.sample_rate, serializer);
    }
}

impl SseEncode for web_audio_api::buffer::AudioBufferOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.number_of_channels, serializer);
        <usize>::sse_encode(self.length, serializer);
        <f32>::sse_encode(self.sample_rate, serializer);
    }
}

impl SseEncode for web_audio_api::node::audio_buffer_source::AudioBufferSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<web_audio_api::buffer::AudioBuffer>>::sse_encode(self.buffer, serializer);
        <f32>::sse_encode(self.detune, serializer);
        <bool>::sse_encode(self.loop_, serializer);
        <f64>::sse_encode(self.loop_start, serializer);
        <f64>::sse_encode(self.loop_end, serializer);
        <f32>::sse_encode(self.playback_rate, serializer);
    }
}

impl SseEncode for web_audio_api::context::online::AudioContextLatencyCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            web_audio_api::context::online::AudioContextLatencyCategory::Balanced => {
                <i32>::sse_encode(0, serializer);
            }
            web_audio_api::context::online::AudioContextLatencyCategory::Interactive => {
                <i32>::sse_encode(1, serializer);
            }
            web_audio_api::context::online::AudioContextLatencyCategory::Playback => {
                <i32>::sse_encode(2, serializer);
            }
            web_audio_api::context::online::AudioContextLatencyCategory::Custom(field0) => {
                <i32>::sse_encode(3, serializer);
                <f64>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for web_audio_api::context::online::AudioContextOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <web_audio_api::context::online::AudioContextLatencyCategory>::sse_encode(
            self.latency_hint,
            serializer,
        );
        <Option<f32>>::sse_encode(self.sample_rate, serializer);
        <String>::sse_encode(self.sink_id, serializer);
        <web_audio_api::context::online::AudioContextRenderSizeCategory>::sse_encode(
            self.render_size_hint,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::context::online::AudioContextRenderSizeCategory {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::context::online::AudioContextRenderSizeCategory::Default => 0,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::context::AudioContextState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::context::AudioContextState::Suspended => 0,
                web_audio_api::context::AudioContextState::Running => 1,
                web_audio_api::context::AudioContextState::Closed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::context::AudioNodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for web_audio_api::node::audio_node::AudioNodeOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.channel_count, serializer);
        <web_audio_api::node::audio_node::ChannelCountMode>::sse_encode(
            self.channel_count_mode,
            serializer,
        );
        <web_audio_api::node::audio_node::ChannelInterpretation>::sse_encode(
            self.channel_interpretation,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::events::AudioProcessingEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <web_audio_api::buffer::AudioBuffer>::sse_encode(self.input_buffer, serializer);
        <web_audio_api::buffer::AudioBuffer>::sse_encode(self.output_buffer, serializer);
        <f64>::sse_encode(self.playback_time, serializer);
        <Option<(
            ConcreteBaseAudioContext,
            web_audio_api::context::AudioNodeId,
        )>>::sse_encode(self.registration, serializer);
    }
}

impl SseEncode for web_audio_api::capacity::AudioRenderCapacityOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.update_interval, serializer);
    }
}

impl SseEncode for web_audio_api::param::AutomationRate {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::param::AutomationRate::A => 0,
                web_audio_api::param::AutomationRate::K => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::biquad_filter::BiquadFilterOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.q, serializer);
        <f32>::sse_encode(self.detune, serializer);
        <f32>::sse_encode(self.frequency, serializer);
        <f32>::sse_encode(self.gain, serializer);
        <web_audio_api::node::biquad_filter::BiquadFilterType>::sse_encode(self.type_, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::biquad_filter::BiquadFilterType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::biquad_filter::BiquadFilterType::Lowpass => 0,
                web_audio_api::node::biquad_filter::BiquadFilterType::Highpass => 1,
                web_audio_api::node::biquad_filter::BiquadFilterType::Bandpass => 2,
                web_audio_api::node::biquad_filter::BiquadFilterType::Notch => 3,
                web_audio_api::node::biquad_filter::BiquadFilterType::Allpass => 4,
                web_audio_api::node::biquad_filter::BiquadFilterType::Peaking => 5,
                web_audio_api::node::biquad_filter::BiquadFilterType::Lowshelf => 6,
                web_audio_api::node::biquad_filter::BiquadFilterType::Highshelf => 7,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for web_audio_api::node::audio_node::ChannelConfigInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.count, serializer);
        <web_audio_api::node::audio_node::ChannelCountMode>::sse_encode(
            self.count_mode,
            serializer,
        );
        <web_audio_api::node::audio_node::ChannelInterpretation>::sse_encode(
            self.interpretation,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::audio_node::ChannelCountMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::audio_node::ChannelCountMode::Max => 0,
                web_audio_api::node::audio_node::ChannelCountMode::ClampedMax => 1,
                web_audio_api::node::audio_node::ChannelCountMode::Explicit => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::audio_node::ChannelInterpretation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::audio_node::ChannelInterpretation::Speakers => 0,
                web_audio_api::node::audio_node::ChannelInterpretation::Discrete => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::channel_merger::ChannelMergerOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.number_of_inputs, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::channel_splitter::ChannelSplitterOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.number_of_outputs, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::constant_source::ConstantSourceOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for web_audio_api::node::convolver::ConvolverOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<web_audio_api::buffer::AudioBuffer>>::sse_encode(self.buffer, serializer);
        <bool>::sse_encode(self.disable_normalization, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::delay::DelayOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.max_delay_time, serializer);
        <f64>::sse_encode(self.delay_time, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::panner::DistanceModelType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::panner::DistanceModelType::Linear => 0,
                web_audio_api::node::panner::DistanceModelType::Inverse => 1,
                web_audio_api::node::panner::DistanceModelType::Exponential => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::dynamics_compressor::DynamicsCompressorOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.attack, serializer);
        <f32>::sse_encode(self.knee, serializer);
        <f32>::sse_encode(self.ratio, serializer);
        <f32>::sse_encode(self.release, serializer);
        <f32>::sse_encode(self.threshold, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::events::EventType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            web_audio_api::events::EventType::Ended(field0) => {
                <i32>::sse_encode(0, serializer);
                <web_audio_api::context::AudioNodeId>::sse_encode(field0, serializer);
            }
            web_audio_api::events::EventType::SinkChange => {
                <i32>::sse_encode(1, serializer);
            }
            web_audio_api::events::EventType::StateChange => {
                <i32>::sse_encode(2, serializer);
            }
            web_audio_api::events::EventType::RenderCapacity => {
                <i32>::sse_encode(3, serializer);
            }
            web_audio_api::events::EventType::ProcessorError(field0) => {
                <i32>::sse_encode(4, serializer);
                <web_audio_api::context::AudioNodeId>::sse_encode(field0, serializer);
            }
            web_audio_api::events::EventType::Diagnostics => {
                <i32>::sse_encode(5, serializer);
            }
            web_audio_api::events::EventType::Message(field0) => {
                <i32>::sse_encode(6, serializer);
                <web_audio_api::context::AudioNodeId>::sse_encode(field0, serializer);
            }
            web_audio_api::events::EventType::Complete => {
                <i32>::sse_encode(7, serializer);
            }
            web_audio_api::events::EventType::AudioProcessing(field0) => {
                <i32>::sse_encode(8, serializer);
                <web_audio_api::context::AudioNodeId>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for web_audio_api::node::gain::GainOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.gain, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for web_audio_api::node::iir_filter::IIRFilterOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
        <Vec<f64>>::sse_encode(self.feedforward, serializer);
        <Vec<f64>>::sse_encode(self.feedback, serializer);
    }
}

impl SseEncode for Vec<ChannelData> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ChannelData>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<MediaDeviceInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <MediaDeviceInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<MediaStreamTrack> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <MediaStreamTrack>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<f32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<f32>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<RefCell<Node>>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<RefCell<Node>>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <usize>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, f64)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, f64)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode
    for Vec<(
        usize,
        Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(
                usize,
                Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
            )>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(usize, oneshot::Sender<()>)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(usize, oneshot::Sender<()>)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for web_audio_api::media_devices::MediaDeviceInfoKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::media_devices::MediaDeviceInfoKind::VideoInput => 0,
                web_audio_api::media_devices::MediaDeviceInfoKind::AudioInput => 1,
                web_audio_api::media_devices::MediaDeviceInfoKind::AudioOutput => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::media_streams::MediaStream {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<MediaStreamTrack>>::sse_encode(self.tracks, serializer);
    }
}

impl SseEncode for web_audio_api::media_devices::MediaStreamConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            web_audio_api::media_devices::MediaStreamConstraints::Audio => {
                <i32>::sse_encode(0, serializer);
            }
            web_audio_api::media_devices::MediaStreamConstraints::AudioWithConstraints(field0) => {
                <i32>::sse_encode(1, serializer);
                <web_audio_api::media_devices::MediaTrackConstraints>::sse_encode(
                    field0, serializer,
                );
            }
        }
    }
}

impl SseEncode for web_audio_api::media_streams::MediaStreamTrackState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::media_streams::MediaStreamTrackState::Live => 0,
                web_audio_api::media_streams::MediaStreamTrackState::Ended => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::media_devices::MediaTrackConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<f32>>::sse_encode(self.sample_rate, serializer);
        <Option<f64>>::sse_encode(self.latency, serializer);
        <Option<u32>>::sse_encode(self.channel_count, serializer);
        <Option<String>>::sse_encode(self.device_id, serializer);
    }
}

impl SseEncode for web_audio_api::render::node_collection::NodeCollection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<Option<RefCell<Node>>>>::sse_encode(self.nodes, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<PeriodicWave> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <PeriodicWave>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<RefCell<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <RefCell<Node>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<
        RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell<Node>>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefCell < Node >>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<[f32]>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<str>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<web_audio_api::buffer::AudioBuffer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <web_audio_api::buffer::AudioBuffer>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode
    for Option<(
        ConcreteBaseAudioContext,
        web_audio_api::context::AudioNodeId,
    )>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <(
                ConcreteBaseAudioContext,
                web_audio_api::context::AudioNodeId,
            )>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<f32>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<f32>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for web_audio_api::node::oscillator::OscillatorOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <web_audio_api::node::oscillator::OscillatorType>::sse_encode(self.type_, serializer);
        <f32>::sse_encode(self.frequency, serializer);
        <f32>::sse_encode(self.detune, serializer);
        <Option<PeriodicWave>>::sse_encode(self.periodic_wave, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::oscillator::OscillatorType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::oscillator::OscillatorType::Sine => 0,
                web_audio_api::node::oscillator::OscillatorType::Square => 1,
                web_audio_api::node::oscillator::OscillatorType::Sawtooth => 2,
                web_audio_api::node::oscillator::OscillatorType::Triangle => 3,
                web_audio_api::node::oscillator::OscillatorType::Custom => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::waveshaper::OverSampleType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::waveshaper::OverSampleType::None => 0,
                web_audio_api::node::waveshaper::OverSampleType::X2 => 1,
                web_audio_api::node::waveshaper::OverSampleType::X4 => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::panner::PannerOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <web_audio_api::node::panner::PanningModelType>::sse_encode(self.panning_model, serializer);
        <web_audio_api::node::panner::DistanceModelType>::sse_encode(
            self.distance_model,
            serializer,
        );
        <f32>::sse_encode(self.position_x, serializer);
        <f32>::sse_encode(self.position_y, serializer);
        <f32>::sse_encode(self.position_z, serializer);
        <f32>::sse_encode(self.orientation_x, serializer);
        <f32>::sse_encode(self.orientation_y, serializer);
        <f32>::sse_encode(self.orientation_z, serializer);
        <f64>::sse_encode(self.ref_distance, serializer);
        <f64>::sse_encode(self.max_distance, serializer);
        <f64>::sse_encode(self.rolloff_factor, serializer);
        <f64>::sse_encode(self.cone_inner_angle, serializer);
        <f64>::sse_encode(self.cone_outer_angle, serializer);
        <f64>::sse_encode(self.cone_outer_gain, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::node::panner::PanningModelType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                web_audio_api::node::panner::PanningModelType::EqualPower => 0,
                web_audio_api::node::panner::PanningModelType::HRTF => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for web_audio_api::periodic_wave::PeriodicWaveOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<f32>>>::sse_encode(self.real, serializer);
        <Option<Vec<f32>>>::sse_encode(self.imag, serializer);
        <bool>::sse_encode(self.disable_normalization, serializer);
    }
}

impl SseEncode for (web_audio_api::context::AudioNodeId, usize) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <web_audio_api::context::AudioNodeId>::sse_encode(self.0, serializer);
        <usize>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        ConcreteBaseAudioContext,
        web_audio_api::context::AudioNodeId,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ConcreteBaseAudioContext>::sse_encode(self.0, serializer);
        <web_audio_api::context::AudioNodeId>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (f32, f32) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.0, serializer);
        <f32>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for (String, f64) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <f64>::sse_encode(self.1, serializer);
    }
}

impl SseEncode
    for (
        usize,
        Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <Box<dyn FnOnce(&mut OfflineAudioContext) + Send + Sync + 'static>>::sse_encode(
            self.1, serializer,
        );
    }
}

impl SseEncode for (usize, oneshot::Sender<()>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.0, serializer);
        <oneshot::Sender<()>>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for web_audio_api::node::script_processor::ScriptProcessorOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.buffer_size, serializer);
        <usize>::sse_encode(self.number_of_input_channels, serializer);
        <usize>::sse_encode(self.number_of_output_channels, serializer);
    }
}

impl SseEncode for web_audio_api::node::stereo_panner::StereoPannerOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f32>::sse_encode(self.pan, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for web_audio_api::node::waveshaper::WaveShaperOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<f32>>>::sse_encode(self.curve, serializer);
        <web_audio_api::node::waveshaper::OverSampleType>::sse_encode(self.oversample, serializer);
        <web_audio_api::node::audio_node::AudioNodeOptions>::sse_encode(
            self.audio_node_options,
            serializer,
        );
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
