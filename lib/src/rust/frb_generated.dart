// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import '../web_audio_api.dart';
import '../web_audio_api/context.dart';
import '../web_audio_api/media_devices.dart';
import '../web_audio_api/media_recorder.dart';
import '../web_audio_api/media_streams.dart';
import '../web_audio_api/node.dart';
import '../web_audio_api/worklet.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'web_audio_api.dart';
import 'web_audio_api/context.dart';
import 'web_audio_api/media_devices.dart';
import 'web_audio_api/media_recorder.dart';
import 'web_audio_api/media_streams.dart';
import 'web_audio_api/node.dart';
import 'web_audio_api/worklet.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.37';

  @override
  int get rustContentHash => 853404976;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_demo_web_audio_api_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  String crateApiSimpleGreet({required String name});

  Future<void> crateApiSimpleInitApp();

  Future<double> webAudioApiAtomicF32Load(
      {required AtomicF32 that, required Ordering ordering});

  Future<AtomicF32> webAudioApiAtomicF32New({required double value});

  Future<void> webAudioApiAtomicF32Store(
      {required AtomicF32 that,
      required double value,
      required Ordering ordering});

  Future<double> webAudioApiAtomicF64Load(
      {required AtomicF64 that, required Ordering ordering});

  Future<AtomicF64> webAudioApiAtomicF64New({required double value});

  Future<void> webAudioApiAtomicF64Store(
      {required AtomicF64 that,
      required double value,
      required Ordering ordering});

  Future<AutomationRate> webAudioApiAudioParamAutomationRate(
      {required AudioParam that});

  Future<Self> webAudioApiAudioParamCancelAndHoldAtTime(
      {required AudioParam that, required double cancelTime});

  Future<Self> webAudioApiAudioParamCancelScheduledValues(
      {required AudioParam that, required double cancelTime});

  Future<double> webAudioApiAudioParamDefaultValue({required AudioParam that});

  Future<Self> webAudioApiAudioParamExponentialRampToValueAtTime(
      {required AudioParam that,
      required double value,
      required double endTime});

  Future<Self> webAudioApiAudioParamLinearRampToValueAtTime(
      {required AudioParam that,
      required double value,
      required double endTime});

  Future<double> webAudioApiAudioParamMaxValue({required AudioParam that});

  Future<double> webAudioApiAudioParamMinValue({required AudioParam that});

  Future<void> webAudioApiAudioParamSetAutomationRate(
      {required AudioParam that, required AutomationRate value});

  Future<Self> webAudioApiAudioParamSetTargetAtTime(
      {required AudioParam that,
      required double value,
      required double startTime,
      required double timeConstant});

  Future<Self> webAudioApiAudioParamSetValue(
      {required AudioParam that, required double value});

  Future<Self> webAudioApiAudioParamSetValueAtTime(
      {required AudioParam that,
      required double value,
      required double startTime});

  Future<Self> webAudioApiAudioParamSetValueCurveAtTime(
      {required AudioParam that,
      required F32 values,
      required double startTime,
      required double duration});

  Future<double> webAudioApiAudioParamValue({required AudioParam that});

  double webAudioApiAudioRenderCapacityEventGetAverageLoad(
      {required AudioRenderCapacityEvent that});

  Event webAudioApiAudioRenderCapacityEventGetEvent(
      {required AudioRenderCapacityEvent that});

  double webAudioApiAudioRenderCapacityEventGetPeakLoad(
      {required AudioRenderCapacityEvent that});

  double webAudioApiAudioRenderCapacityEventGetTimestamp(
      {required AudioRenderCapacityEvent that});

  double webAudioApiAudioRenderCapacityEventGetUnderrunRatio(
      {required AudioRenderCapacityEvent that});

  void webAudioApiAudioRenderCapacityEventSetAverageLoad(
      {required AudioRenderCapacityEvent that, required double averageLoad});

  void webAudioApiAudioRenderCapacityEventSetEvent(
      {required AudioRenderCapacityEvent that, required Event event});

  void webAudioApiAudioRenderCapacityEventSetPeakLoad(
      {required AudioRenderCapacityEvent that, required double peakLoad});

  void webAudioApiAudioRenderCapacityEventSetTimestamp(
      {required AudioRenderCapacityEvent that, required double timestamp});

  void webAudioApiAudioRenderCapacityEventSetUnderrunRatio(
      {required AudioRenderCapacityEvent that, required double underrunRatio});

  Future<void> webAudioApiAudioRenderCapacityClearOnupdate(
      {required AudioRenderCapacity that});

  Future<void> webAudioApiAudioRenderCapacitySetOnupdate(
      {required AudioRenderCapacity that, required F callback});

  Future<void> webAudioApiAudioRenderCapacityStart(
      {required AudioRenderCapacity that,
      required AudioRenderCapacityOptions options});

  Future<void> webAudioApiAudioRenderCapacityStop(
      {required AudioRenderCapacity that});

  Future<F32> webAudioApiChannelDataAsMutSlice({required ChannelData that});

  Future<F32> webAudioApiChannelDataAsSlice({required ChannelData that});

  Future<ChannelData> webAudioApiChannelDataFrom({required List<double> data});

  Future<bool> webAudioApiChannelDataIsEmpty({required ChannelData that});

  Future<BigInt> webAudioApiChannelDataLen({required ChannelData that});

  Future<ChannelData> webAudioApiChannelDataNew({required BigInt length});

  BoxAny webAudioApiErrorEventGetError({required ErrorEvent that});

  Event webAudioApiErrorEventGetEvent({required ErrorEvent that});

  String webAudioApiErrorEventGetMessage({required ErrorEvent that});

  void webAudioApiErrorEventSetError(
      {required ErrorEvent that, required BoxAny error});

  void webAudioApiErrorEventSetEvent(
      {required ErrorEvent that, required Event event});

  void webAudioApiErrorEventSetMessage(
      {required ErrorEvent that, required String message});

  Future<EventDispatch> webAudioApiEventDispatchAudioProcessing(
      {required AudioNodeId id, required AudioProcessingEvent value});

  Future<EventDispatch> webAudioApiEventDispatchComplete(
      {required AudioBuffer buffer});

  Future<EventDispatch> webAudioApiEventDispatchDiagnostics(
      {required List<int> value});

  Future<EventDispatch> webAudioApiEventDispatchEnded(
      {required AudioNodeId id});

  Future<EventDispatch> webAudioApiEventDispatchMessage(
      {required AudioNodeId id, required BoxAny value});

  Future<EventDispatch> webAudioApiEventDispatchProcessorError(
      {required AudioNodeId id, required ErrorEvent value});

  Future<EventDispatch> webAudioApiEventDispatchRenderCapacity(
      {required AudioRenderCapacityEvent value});

  Future<EventDispatch> webAudioApiEventDispatchSinkChange();

  Future<EventDispatch> webAudioApiEventDispatchStateChange(
      {required AudioContextState state});

  Future<void> webAudioApiEventLoopClearHandler(
      {required EventLoop that, required EventType event});

  Future<bool> webAudioApiEventLoopHandlePendingEvents(
      {required EventLoop that});

  Future<EventLoop> webAudioApiEventLoopNew(
      {required ReceiverEventDispatch eventRecv});

  Future<void> webAudioApiEventLoopRunInThread({required EventLoop that});

  Future<void> webAudioApiEventLoopSetHandler(
      {required EventLoop that,
      required EventType event,
      required EventHandler callback});

  Str webAudioApiEventGetType({required Event that});

  void webAudioApiEventSetType({required Event that, required Str type});

  Event webAudioApiOfflineAudioCompletionEventGetEvent(
      {required OfflineAudioCompletionEvent that});

  AudioBuffer webAudioApiOfflineAudioCompletionEventGetRenderedBuffer(
      {required OfflineAudioCompletionEvent that});

  void webAudioApiOfflineAudioCompletionEventSetEvent(
      {required OfflineAudioCompletionEvent that, required Event event});

  void webAudioApiOfflineAudioCompletionEventSetRenderedBuffer(
      {required OfflineAudioCompletionEvent that,
      required AudioBuffer renderedBuffer});

  Future<PeriodicWave> webAudioApiPeriodicWaveNew(
      {required C context, required PeriodicWaveOptions options});

  Future<void> webAudioApiAudioBufferCopyFromChannel(
      {required AudioBuffer that,
      required F32 destination,
      required BigInt channelNumber});

  Future<void> webAudioApiAudioBufferCopyFromChannelWithOffset(
      {required AudioBuffer that,
      required F32 destination,
      required BigInt channelNumber,
      required BigInt offset});

  Future<void> webAudioApiAudioBufferCopyToChannel(
      {required AudioBuffer that,
      required F32 source,
      required BigInt channelNumber});

  Future<void> webAudioApiAudioBufferCopyToChannelWithOffset(
      {required AudioBuffer that,
      required F32 source,
      required BigInt channelNumber,
      required BigInt offset});

  Future<double> webAudioApiAudioBufferDuration({required AudioBuffer that});

  Future<AudioBuffer> webAudioApiAudioBufferFrom(
      {required List<Float32List> samples, required double sampleRate});

  Future<F32> webAudioApiAudioBufferGetChannelData(
      {required AudioBuffer that, required BigInt channelNumber});

  Future<F32> webAudioApiAudioBufferGetChannelDataMut(
      {required AudioBuffer that, required BigInt channelNumber});

  Future<BigInt> webAudioApiAudioBufferLength({required AudioBuffer that});

  Future<AudioBuffer> webAudioApiAudioBufferNew(
      {required AudioBufferOptions options});

  Future<BigInt> webAudioApiAudioBufferNumberOfChannels(
      {required AudioBuffer that});

  Future<double> webAudioApiAudioBufferSampleRate({required AudioBuffer that});

  Future<double> webAudioApiContextAudioContextBaseLatency(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextClearOnsinkchange(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextClose(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextCloseSync(
      {required AudioContext that});

  Future<MediaElementAudioSourceNode>
      webAudioApiContextAudioContextCreateMediaElementSource(
          {required AudioContext that, required MediaElement mediaElement});

  Future<MediaStreamAudioDestinationNode>
      webAudioApiContextAudioContextCreateMediaStreamDestination(
          {required AudioContext that});

  Future<MediaStreamAudioSourceNode>
      webAudioApiContextAudioContextCreateMediaStreamSource(
          {required AudioContext that, required MediaStream media});

  Future<MediaStreamTrackAudioSourceNode>
      webAudioApiContextAudioContextCreateMediaStreamTrackSource(
          {required AudioContext that, required MediaStreamTrack media});

  Future<AudioContext> webAudioApiContextAudioContextNew(
      {required AudioContextOptions options});

  Future<double> webAudioApiContextAudioContextOutputLatency(
      {required AudioContext that});

  Future<AudioRenderCapacity> webAudioApiContextAudioContextRenderCapacity(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextResume(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextResumeSync(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextRunDiagnostics(
      {required AudioContext that, required F callback});

  Future<void> webAudioApiContextAudioContextSetOnsinkchange(
      {required AudioContext that, required F callback});

  Future<void> webAudioApiContextAudioContextSetSinkIdSync(
      {required AudioContext that, required String sinkId});

  Future<String> webAudioApiContextAudioContextSinkId(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextSuspend(
      {required AudioContext that});

  Future<void> webAudioApiContextAudioContextSuspendSync(
      {required AudioContext that});

  Future<void> webAudioApiContextConcreteBaseAudioContextMarkCycleBreaker(
      {required ConcreteBaseAudioContext that,
      required AudioContextRegistration reg});

  Future<void> webAudioApiContextOfflineAudioContextClearOncomplete(
      {required OfflineAudioContext that});

  Future<BigInt> webAudioApiContextOfflineAudioContextLength(
      {required OfflineAudioContext that});

  Future<OfflineAudioContext> webAudioApiContextOfflineAudioContextNew(
      {required BigInt numberOfChannels,
      required BigInt length,
      required double sampleRate});

  Future<void> webAudioApiContextOfflineAudioContextResume(
      {required OfflineAudioContext that});

  Future<void> webAudioApiContextOfflineAudioContextSetOncomplete(
      {required OfflineAudioContext that, required F callback});

  Future<AudioBuffer> webAudioApiContextOfflineAudioContextStartRendering(
      {required OfflineAudioContext that});

  Future<AudioBuffer> webAudioApiContextOfflineAudioContextStartRenderingSync(
      {required OfflineAudioContext that});

  Future<void> webAudioApiContextOfflineAudioContextSuspend(
      {required OfflineAudioContext that, required double suspendTime});

  Future<void> webAudioApiContextOfflineAudioContextSuspendSync(
      {required OfflineAudioContext that,
      required double suspendTime,
      required F callback});

  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoDeviceId(
      {required MediaDeviceInfo that});

  Future<Str?> webAudioApiMediaDevicesMediaDeviceInfoGroupId(
      {required MediaDeviceInfo that});

  Future<MediaDeviceInfoKind> webAudioApiMediaDevicesMediaDeviceInfoKind(
      {required MediaDeviceInfo that});

  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoLabel(
      {required MediaDeviceInfo that});

  Future<List<MediaDeviceInfo>> webAudioApiMediaDevicesEnumerateDevicesSync();

  Future<MediaStream> webAudioApiMediaDevicesGetUserMediaSync(
      {required MediaStreamConstraints constraints});

  Uint8List webAudioApiMediaRecorderBlobEventGetBlob({required BlobEvent that});

  Event webAudioApiMediaRecorderBlobEventGetEvent({required BlobEvent that});

  double webAudioApiMediaRecorderBlobEventGetTimecode(
      {required BlobEvent that});

  void webAudioApiMediaRecorderBlobEventSetBlob(
      {required BlobEvent that, required Uint8List blob});

  void webAudioApiMediaRecorderBlobEventSetEvent(
      {required BlobEvent that, required Event event});

  void webAudioApiMediaRecorderBlobEventSetTimecode(
      {required BlobEvent that, required double timecode});

  Future<void> webAudioApiMediaRecorderMediaRecorderClearOndataavailable(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnerror(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnstop(
      {required MediaRecorder that});

  Future<MediaRecorder> webAudioApiMediaRecorderMediaRecorderNew(
      {required MediaStream stream});

  Future<void> webAudioApiMediaRecorderMediaRecorderSetOndataavailable(
      {required MediaRecorder that, required F callback});

  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnerror(
      {required MediaRecorder that, required F callback});

  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnstop(
      {required MediaRecorder that, required F callback});

  Future<void> webAudioApiMediaRecorderMediaRecorderStart(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaRecorderMediaRecorderStop(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaStreamsMediaStreamTrackClose(
      {required MediaStreamTrack that});

  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamTrackFromIter(
      {required T iter});

  Future<MediaStreamTrackState>
      webAudioApiMediaStreamsMediaStreamTrackReadyState(
          {required MediaStreamTrack that});

  Future<MediaStream> webAudioApiMediaStreamsMediaStreamFromTracks(
      {required List<MediaStreamTrack> tracks});

  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamGetTracks(
      {required MediaStream that});

  Future<BigInt> webAudioApiNodeAnalyserNodeFftSize(
      {required AnalyserNode that});

  Future<BigInt> webAudioApiNodeAnalyserNodeFrequencyBinCount(
      {required AnalyserNode that});

  Future<void> webAudioApiNodeAnalyserNodeGetByteFrequencyData(
      {required AnalyserNode that, required U8 buffer});

  Future<void> webAudioApiNodeAnalyserNodeGetByteTimeDomainData(
      {required AnalyserNode that, required U8 buffer});

  Future<void> webAudioApiNodeAnalyserNodeGetFloatFrequencyData(
      {required AnalyserNode that, required F32 buffer});

  Future<void> webAudioApiNodeAnalyserNodeGetFloatTimeDomainData(
      {required AnalyserNode that, required F32 buffer});

  Future<double> webAudioApiNodeAnalyserNodeMaxDecibels(
      {required AnalyserNode that});

  Future<double> webAudioApiNodeAnalyserNodeMinDecibels(
      {required AnalyserNode that});

  Future<AnalyserNode> webAudioApiNodeAnalyserNodeNew(
      {required C context, required AnalyserOptions options});

  Future<void> webAudioApiNodeAnalyserNodeSetFftSize(
      {required AnalyserNode that, required BigInt fftSize});

  Future<void> webAudioApiNodeAnalyserNodeSetMaxDecibels(
      {required AnalyserNode that, required double value});

  Future<void> webAudioApiNodeAnalyserNodeSetMinDecibels(
      {required AnalyserNode that, required double value});

  Future<void> webAudioApiNodeAnalyserNodeSetSmoothingTimeConstant(
      {required AnalyserNode that, required double value});

  Future<double> webAudioApiNodeAnalyserNodeSmoothingTimeConstant(
      {required AnalyserNode that});

  Future<AudioBuffer?> webAudioApiNodeAudioBufferSourceNodeBuffer(
      {required AudioBufferSourceNode that});

  Future<AudioParam> webAudioApiNodeAudioBufferSourceNodeDetune(
      {required AudioBufferSourceNode that});

  Future<bool> webAudioApiNodeAudioBufferSourceNodeLoop(
      {required AudioBufferSourceNode that});

  Future<double> webAudioApiNodeAudioBufferSourceNodeLoopEnd(
      {required AudioBufferSourceNode that});

  Future<double> webAudioApiNodeAudioBufferSourceNodeLoopStart(
      {required AudioBufferSourceNode that});

  Future<AudioBufferSourceNode> webAudioApiNodeAudioBufferSourceNodeNew(
      {required C context, required AudioBufferSourceOptions options});

  Future<AudioParam> webAudioApiNodeAudioBufferSourceNodePlaybackRate(
      {required AudioBufferSourceNode that});

  Future<double> webAudioApiNodeAudioBufferSourceNodePosition(
      {required AudioBufferSourceNode that});

  Future<void> webAudioApiNodeAudioBufferSourceNodeSetBuffer(
      {required AudioBufferSourceNode that, required AudioBuffer audioBuffer});

  Future<void> webAudioApiNodeAudioBufferSourceNodeSetLoop(
      {required AudioBufferSourceNode that, required bool value});

  Future<void> webAudioApiNodeAudioBufferSourceNodeSetLoopEnd(
      {required AudioBufferSourceNode that, required double value});

  Future<void> webAudioApiNodeAudioBufferSourceNodeSetLoopStart(
      {required AudioBufferSourceNode that, required double value});

  Future<void> webAudioApiNodeAudioBufferSourceNodeStartAtWithOffset(
      {required AudioBufferSourceNode that,
      required double start,
      required double offset});

  Future<void> webAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetAndDuration(
      {required AudioBufferSourceNode that,
      required double start,
      required double offset,
      required double duration});

  Future<BigInt> webAudioApiNodeAudioDestinationNodeMaxChannelCount(
      {required AudioDestinationNode that});

  Future<AudioParam> webAudioApiNodeBiquadFilterNodeDetune(
      {required BiquadFilterNode that});

  Future<AudioParam> webAudioApiNodeBiquadFilterNodeFrequency(
      {required BiquadFilterNode that});

  Future<AudioParam> webAudioApiNodeBiquadFilterNodeGain(
      {required BiquadFilterNode that});

  Future<void> webAudioApiNodeBiquadFilterNodeGetFrequencyResponse(
      {required BiquadFilterNode that,
      required F32 frequencyHz,
      required F32 magResponse,
      required F32 phaseResponse});

  Future<BiquadFilterNode> webAudioApiNodeBiquadFilterNodeNew(
      {required C context, required BiquadFilterOptions options});

  Future<AudioParam> webAudioApiNodeBiquadFilterNodeQ(
      {required BiquadFilterNode that});

  Future<void> webAudioApiNodeBiquadFilterNodeSetType(
      {required BiquadFilterNode that, required BiquadFilterType type});

  Future<BiquadFilterType> webAudioApiNodeBiquadFilterNodeType(
      {required BiquadFilterNode that});

  Future<ChannelMergerNode> webAudioApiNodeChannelMergerNodeNew(
      {required C context, required ChannelMergerOptions options});

  Future<ChannelSplitterNode> webAudioApiNodeChannelSplitterNodeNew(
      {required C context, required ChannelSplitterOptions options});

  Future<ConstantSourceNode> webAudioApiNodeConstantSourceNodeNew(
      {required C context, required ConstantSourceOptions options});

  Future<AudioParam> webAudioApiNodeConstantSourceNodeOffset(
      {required ConstantSourceNode that});

  Future<AudioBuffer?> webAudioApiNodeConvolverNodeBuffer(
      {required ConvolverNode that});

  Future<ConvolverNode> webAudioApiNodeConvolverNodeNew(
      {required C context, required ConvolverOptions options});

  Future<bool> webAudioApiNodeConvolverNodeNormalize(
      {required ConvolverNode that});

  Future<void> webAudioApiNodeConvolverNodeSetBuffer(
      {required ConvolverNode that, required AudioBuffer buffer});

  Future<void> webAudioApiNodeConvolverNodeSetNormalize(
      {required ConvolverNode that, required bool value});

  Future<AudioParam> webAudioApiNodeDelayNodeDelayTime(
      {required DelayNode that});

  Future<DelayNode> webAudioApiNodeDelayNodeNew(
      {required C context, required DelayOptions options});

  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeAttack(
      {required DynamicsCompressorNode that});

  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeKnee(
      {required DynamicsCompressorNode that});

  Future<DynamicsCompressorNode> webAudioApiNodeDynamicsCompressorNodeNew(
      {required C context, required DynamicsCompressorOptions options});

  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeRatio(
      {required DynamicsCompressorNode that});

  Future<double> webAudioApiNodeDynamicsCompressorNodeReduction(
      {required DynamicsCompressorNode that});

  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeRelease(
      {required DynamicsCompressorNode that});

  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeThreshold(
      {required DynamicsCompressorNode that});

  Future<AudioParam> webAudioApiNodeGainNodeGain({required GainNode that});

  Future<GainNode> webAudioApiNodeGainNodeNew(
      {required C context, required GainOptions options});

  Future<void> webAudioApiNodeIirFilterNodeGetFrequencyResponse(
      {required IirFilterNode that,
      required F32 frequencyHz,
      required F32 magResponse,
      required F32 phaseResponse});

  Future<IirFilterNode> webAudioApiNodeIirFilterNodeNew(
      {required C context, required IIRFilterOptions options});

  Future<MediaElementAudioSourceNode>
      webAudioApiNodeMediaElementAudioSourceNodeNew(
          {required C context,
          required MediaElementAudioSourceOptions options});

  MediaElement webAudioApiNodeMediaElementAudioSourceOptionsGetMediaElement(
      {required MediaElementAudioSourceOptions that});

  void webAudioApiNodeMediaElementAudioSourceOptionsSetMediaElement(
      {required MediaElementAudioSourceOptions that,
      required MediaElement mediaElement});

  Future<MediaStreamAudioDestinationNode>
      webAudioApiNodeMediaStreamAudioDestinationNodeNew(
          {required C context, required AudioNodeOptions options});

  Future<MediaStream> webAudioApiNodeMediaStreamAudioDestinationNodeStream(
      {required MediaStreamAudioDestinationNode that});

  Future<MediaStreamAudioSourceNode>
      webAudioApiNodeMediaStreamAudioSourceNodeNew(
          {required C context, required MediaStreamAudioSourceOptions options});

  MediaStream webAudioApiNodeMediaStreamAudioSourceOptionsGetMediaStream(
      {required MediaStreamAudioSourceOptions that});

  void webAudioApiNodeMediaStreamAudioSourceOptionsSetMediaStream(
      {required MediaStreamAudioSourceOptions that,
      required MediaStream mediaStream});

  Future<MediaStreamTrackAudioSourceNode>
      webAudioApiNodeMediaStreamTrackAudioSourceNodeNew(
          {required C context,
          required MediaStreamTrackAudioSourceOptions options});

  MediaStreamTrack
      webAudioApiNodeMediaStreamTrackAudioSourceOptionsGetMediaStreamTrack(
          {required MediaStreamTrackAudioSourceOptions that});

  void webAudioApiNodeMediaStreamTrackAudioSourceOptionsSetMediaStreamTrack(
      {required MediaStreamTrackAudioSourceOptions that,
      required MediaStreamTrack mediaStreamTrack});

  Future<AudioParam> webAudioApiNodeOscillatorNodeDetune(
      {required OscillatorNode that});

  Future<AudioParam> webAudioApiNodeOscillatorNodeFrequency(
      {required OscillatorNode that});

  Future<OscillatorNode> webAudioApiNodeOscillatorNodeNew(
      {required C context, required OscillatorOptions options});

  Future<void> webAudioApiNodeOscillatorNodeSetPeriodicWave(
      {required OscillatorNode that, required PeriodicWave periodicWave});

  Future<void> webAudioApiNodeOscillatorNodeSetType(
      {required OscillatorNode that, required OscillatorType type});

  Future<OscillatorType> webAudioApiNodeOscillatorNodeType(
      {required OscillatorNode that});

  Future<double> webAudioApiNodePannerNodeConeInnerAngle(
      {required PannerNode that});

  Future<double> webAudioApiNodePannerNodeConeOuterAngle(
      {required PannerNode that});

  Future<double> webAudioApiNodePannerNodeConeOuterGain(
      {required PannerNode that});

  Future<DistanceModelType> webAudioApiNodePannerNodeDistanceModel(
      {required PannerNode that});

  Future<double> webAudioApiNodePannerNodeMaxDistance(
      {required PannerNode that});

  Future<PannerNode> webAudioApiNodePannerNodeNew(
      {required C context, required PannerOptions options});

  Future<AudioParam> webAudioApiNodePannerNodeOrientationX(
      {required PannerNode that});

  Future<AudioParam> webAudioApiNodePannerNodeOrientationY(
      {required PannerNode that});

  Future<AudioParam> webAudioApiNodePannerNodeOrientationZ(
      {required PannerNode that});

  Future<PanningModelType> webAudioApiNodePannerNodePanningModel(
      {required PannerNode that});

  Future<AudioParam> webAudioApiNodePannerNodePositionX(
      {required PannerNode that});

  Future<AudioParam> webAudioApiNodePannerNodePositionY(
      {required PannerNode that});

  Future<AudioParam> webAudioApiNodePannerNodePositionZ(
      {required PannerNode that});

  Future<double> webAudioApiNodePannerNodeRefDistance(
      {required PannerNode that});

  Future<double> webAudioApiNodePannerNodeRolloffFactor(
      {required PannerNode that});

  Future<void> webAudioApiNodePannerNodeSetConeInnerAngle(
      {required PannerNode that, required double value});

  Future<void> webAudioApiNodePannerNodeSetConeOuterAngle(
      {required PannerNode that, required double value});

  Future<void> webAudioApiNodePannerNodeSetConeOuterGain(
      {required PannerNode that, required double value});

  Future<void> webAudioApiNodePannerNodeSetDistanceModel(
      {required PannerNode that, required DistanceModelType value});

  Future<void> webAudioApiNodePannerNodeSetMaxDistance(
      {required PannerNode that, required double value});

  Future<void> webAudioApiNodePannerNodeSetOrientation(
      {required PannerNode that,
      required double x,
      required double y,
      required double z});

  Future<void> webAudioApiNodePannerNodeSetPanningModel(
      {required PannerNode that, required PanningModelType value});

  Future<void> webAudioApiNodePannerNodeSetPosition(
      {required PannerNode that,
      required double x,
      required double y,
      required double z});

  Future<void> webAudioApiNodePannerNodeSetRefDistance(
      {required PannerNode that, required double value});

  Future<void> webAudioApiNodePannerNodeSetRolloffFactor(
      {required PannerNode that, required double value});

  Future<BigInt> webAudioApiNodeScriptProcessorNodeBufferSize(
      {required ScriptProcessorNode that});

  Future<void> webAudioApiNodeScriptProcessorNodeClearOnaudioprocess(
      {required ScriptProcessorNode that});

  Future<ScriptProcessorNode> webAudioApiNodeScriptProcessorNodeNew(
      {required C context, required ScriptProcessorOptions options});

  Future<void> webAudioApiNodeScriptProcessorNodeSetOnaudioprocess(
      {required ScriptProcessorNode that, required F callback});

  Future<StereoPannerNode> webAudioApiNodeStereoPannerNodeNew(
      {required C context, required StereoPannerOptions options});

  Future<AudioParam> webAudioApiNodeStereoPannerNodePan(
      {required StereoPannerNode that});

  Future<F32?> webAudioApiNodeWaveShaperNodeCurve(
      {required WaveShaperNode that});

  Future<WaveShaperNode> webAudioApiNodeWaveShaperNodeNew(
      {required C context, required WaveShaperOptions options});

  Future<OverSampleType> webAudioApiNodeWaveShaperNodeOversample(
      {required WaveShaperNode that});

  Future<void> webAudioApiNodeWaveShaperNodeSetCurve(
      {required WaveShaperNode that, required List<double> curve});

  Future<void> webAudioApiNodeWaveShaperNodeSetOversample(
      {required WaveShaperNode that, required OverSampleType oversample});

  AudioNodeOptions webAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptions(
      {required AudioWorkletNodeOptions that});

  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputs(
      {required AudioWorkletNodeOptions that});

  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputs(
      {required AudioWorkletNodeOptions that});

  Uint64List webAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCount(
      {required AudioWorkletNodeOptions that});

  Map<String, double> webAudioApiWorkletAudioWorkletNodeOptionsGetParameterData(
      {required AudioWorkletNodeOptions that});

  C webAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptions(
      {required AudioWorkletNodeOptions that});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptions(
      {required AudioWorkletNodeOptions that,
      required AudioNodeOptions audioNodeOptions});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputs(
      {required AudioWorkletNodeOptions that, required BigInt numberOfInputs});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputs(
      {required AudioWorkletNodeOptions that, required BigInt numberOfOutputs});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCount(
      {required AudioWorkletNodeOptions that,
      required Uint64List outputChannelCount});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetParameterData(
      {required AudioWorkletNodeOptions that,
      required Map<String, double> parameterData});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptions(
      {required AudioWorkletNodeOptions that, required C processorOptions});

  Future<HashMapStringAudioParam> webAudioApiWorkletAudioWorkletNodeParameters(
      {required AudioWorkletNode that});

  Future<MessagePort> webAudioApiWorkletAudioWorkletNodePort(
      {required AudioWorkletNode that});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AnalyserNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AnalyserNode;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AnalyserNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF32;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AtomicF32Ptr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF64;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF64;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AtomicF64Ptr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioBuffer;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioBuffer;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AudioBufferPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioBufferSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioBufferSourceNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioBufferSourceNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioContext;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AudioContextPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioContextRegistration;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioContextRegistration;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioContextRegistrationPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioDestinationNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioDestinationNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioDestinationNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioParam;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioParam;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AudioParamPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioRenderCapacity;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioRenderCapacity;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioRenderCapacityPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioRenderCapacityEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioRenderCapacityEvent;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioRenderCapacityEventPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioWorkletNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNodeOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNodeOptions;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioWorkletNodeOptionsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BiquadFilterNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BiquadFilterNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BiquadFilterNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlobEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlobEvent;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BlobEventPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BoxAny;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BoxAny;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BoxAnyPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_BoxAny;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_BoxAny;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BoxAnyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxError;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxError;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BoxErrorPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_C;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_C;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ChannelData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ChannelData;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ChannelDataPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ChannelMergerNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ChannelMergerNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ChannelMergerNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ChannelSplitterNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ChannelSplitterNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ChannelSplitterNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ConcreteBaseAudioContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ConcreteBaseAudioContext;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ConcreteBaseAudioContextPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ConstantSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ConstantSourceNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ConstantSourceNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ConvolverNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ConvolverNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ConvolverNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DelayNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DelayNode;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_DelayNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DynamicsCompressorNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DynamicsCompressorNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_DynamicsCompressorNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ErrorEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ErrorEvent;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ErrorEventPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Event;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Event;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EventPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventDispatch;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventDispatch;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_EventDispatchPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventHandler;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventHandler;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EventHandlerPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventLoop;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventLoop;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EventLoopPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_F;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_F;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_GainNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_GainNode;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GainNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_HashMapStringAudioParam;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_HashMapStringAudioParam;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_HashMapStringAudioParamPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_IirFilterNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_IirFilterNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_IirFilterNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaDeviceInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaDeviceInfo;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaDeviceInfoPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaElement;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaElement;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MediaElementPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaElementAudioSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaElementAudioSourceNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaElementAudioSourceNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaElementAudioSourceOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaElementAudioSourceOptions;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaElementAudioSourceOptionsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaRecorder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaRecorder;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaRecorderPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStream;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MediaStreamPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamAudioDestinationNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamAudioDestinationNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamAudioDestinationNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamAudioSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamAudioSourceNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamAudioSourceNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamAudioSourceOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamAudioSourceOptions;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamAudioSourceOptionsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrack;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrack;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamTrackPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrackAudioSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrackAudioSourceOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceOptions;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceOptionsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MessagePort;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MessagePort;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MessagePortPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OfflineAudioCompletionEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OfflineAudioCompletionEvent;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_OfflineAudioCompletionEventPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OfflineAudioContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OfflineAudioContext;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_OfflineAudioContextPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ordering;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ordering;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OrderingPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OscillatorNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OscillatorNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_OscillatorNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PannerNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PannerNode;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PannerNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PeriodicWave;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PeriodicWave;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PeriodicWavePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ReceiverEventDispatch;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ReceiverEventDispatch;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ReceiverEventDispatchPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ScriptProcessorNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ScriptProcessorNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ScriptProcessorNodePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Self;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Self;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SelfPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_StereoPannerNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_StereoPannerNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_StereoPannerNodePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_T;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_T;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WaveShaperNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WaveShaperNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_WaveShaperNodePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_F32;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_F32;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_F32Ptr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Str;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Str;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StrPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_U8;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_U8;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_U8Ptr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGreetConstMeta,
      argValues: [name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<double> webAudioApiAtomicF32Load(
      {required AtomicF32 that, required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF32LoadConstMeta,
      argValues: [that, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF32LoadConstMeta => const TaskConstMeta(
        debugName: "AtomicF32_load",
        argNames: ["that", "ordering"],
      );

  @override
  Future<AtomicF32> webAudioApiAtomicF32New({required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF32NewConstMeta,
      argValues: [value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF32NewConstMeta => const TaskConstMeta(
        debugName: "AtomicF32_new",
        argNames: ["value"],
      );

  @override
  Future<void> webAudioApiAtomicF32Store(
      {required AtomicF32 that,
      required double value,
      required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
            that, serializer);
        sse_encode_f_32(value, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF32StoreConstMeta,
      argValues: [that, value, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF32StoreConstMeta => const TaskConstMeta(
        debugName: "AtomicF32_store",
        argNames: ["that", "value", "ordering"],
      );

  @override
  Future<double> webAudioApiAtomicF64Load(
      {required AtomicF64 that, required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF64LoadConstMeta,
      argValues: [that, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF64LoadConstMeta => const TaskConstMeta(
        debugName: "AtomicF64_load",
        argNames: ["that", "ordering"],
      );

  @override
  Future<AtomicF64> webAudioApiAtomicF64New({required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF64NewConstMeta,
      argValues: [value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF64NewConstMeta => const TaskConstMeta(
        debugName: "AtomicF64_new",
        argNames: ["value"],
      );

  @override
  Future<void> webAudioApiAtomicF64Store(
      {required AtomicF64 that,
      required double value,
      required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
            that, serializer);
        sse_encode_f_64(value, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF64StoreConstMeta,
      argValues: [that, value, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF64StoreConstMeta => const TaskConstMeta(
        debugName: "AtomicF64_store",
        argNames: ["that", "value", "ordering"],
      );

  @override
  Future<AutomationRate> webAudioApiAudioParamAutomationRate(
      {required AudioParam that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_automation_rate,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamAutomationRateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamAutomationRateConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_automation_rate",
        argNames: ["that"],
      );

  @override
  Future<Self> webAudioApiAudioParamCancelAndHoldAtTime(
      {required AudioParam that, required double cancelTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_64(cancelTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamCancelAndHoldAtTimeConstMeta,
      argValues: [that, cancelTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamCancelAndHoldAtTimeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_cancel_and_hold_at_time",
        argNames: ["that", "cancelTime"],
      );

  @override
  Future<Self> webAudioApiAudioParamCancelScheduledValues(
      {required AudioParam that, required double cancelTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_64(cancelTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamCancelScheduledValuesConstMeta,
      argValues: [that, cancelTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamCancelScheduledValuesConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_cancel_scheduled_values",
        argNames: ["that", "cancelTime"],
      );

  @override
  Future<double> webAudioApiAudioParamDefaultValue({required AudioParam that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamDefaultValueConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamDefaultValueConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_default_value",
        argNames: ["that"],
      );

  @override
  Future<Self> webAudioApiAudioParamExponentialRampToValueAtTime(
      {required AudioParam that,
      required double value,
      required double endTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_32(value, serializer);
        sse_encode_f_64(endTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamExponentialRampToValueAtTimeConstMeta,
      argValues: [that, value, endTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiAudioParamExponentialRampToValueAtTimeConstMeta =>
          const TaskConstMeta(
            debugName: "AudioParam_exponential_ramp_to_value_at_time",
            argNames: ["that", "value", "endTime"],
          );

  @override
  Future<Self> webAudioApiAudioParamLinearRampToValueAtTime(
      {required AudioParam that,
      required double value,
      required double endTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_32(value, serializer);
        sse_encode_f_64(endTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamLinearRampToValueAtTimeConstMeta,
      argValues: [that, value, endTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamLinearRampToValueAtTimeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_linear_ramp_to_value_at_time",
        argNames: ["that", "value", "endTime"],
      );

  @override
  Future<double> webAudioApiAudioParamMaxValue({required AudioParam that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamMaxValueConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamMaxValueConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_max_value",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiAudioParamMinValue({required AudioParam that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamMinValueConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamMinValueConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_min_value",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiAudioParamSetAutomationRate(
      {required AudioParam that, required AutomationRate value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_automation_rate(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamSetAutomationRateConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamSetAutomationRateConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_set_automation_rate",
        argNames: ["that", "value"],
      );

  @override
  Future<Self> webAudioApiAudioParamSetTargetAtTime(
      {required AudioParam that,
      required double value,
      required double startTime,
      required double timeConstant}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_32(value, serializer);
        sse_encode_f_64(startTime, serializer);
        sse_encode_f_64(timeConstant, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamSetTargetAtTimeConstMeta,
      argValues: [that, value, startTime, timeConstant],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamSetTargetAtTimeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_set_target_at_time",
        argNames: ["that", "value", "startTime", "timeConstant"],
      );

  @override
  Future<Self> webAudioApiAudioParamSetValue(
      {required AudioParam that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamSetValueConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamSetValueConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_set_value",
        argNames: ["that", "value"],
      );

  @override
  Future<Self> webAudioApiAudioParamSetValueAtTime(
      {required AudioParam that,
      required double value,
      required double startTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_f_32(value, serializer);
        sse_encode_f_64(startTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamSetValueAtTimeConstMeta,
      argValues: [that, value, startTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamSetValueAtTimeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_set_value_at_time",
        argNames: ["that", "value", "startTime"],
      );

  @override
  Future<Self> webAudioApiAudioParamSetValueCurveAtTime(
      {required AudioParam that,
      required F32 values,
      required double startTime,
      required double duration}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            values, serializer);
        sse_encode_f_64(startTime, serializer);
        sse_encode_f_64(duration, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamSetValueCurveAtTimeConstMeta,
      argValues: [that, values, startTime, duration],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamSetValueCurveAtTimeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioParam_set_value_curve_at_time",
        argNames: ["that", "values", "startTime", "duration"],
      );

  @override
  Future<double> webAudioApiAudioParamValue({required AudioParam that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioParamValueConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioParamValueConstMeta => const TaskConstMeta(
        debugName: "AudioParam_value",
        argNames: ["that"],
      );

  @override
  double webAudioApiAudioRenderCapacityEventGetAverageLoad(
      {required AudioRenderCapacityEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventGetAverageLoadConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiAudioRenderCapacityEventGetAverageLoadConstMeta =>
          const TaskConstMeta(
            debugName: "AudioRenderCapacityEvent_get_average_load",
            argNames: ["that"],
          );

  @override
  Event webAudioApiAudioRenderCapacityEventGetEvent(
      {required AudioRenderCapacityEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventGetEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityEventGetEventConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacityEvent_get_event",
        argNames: ["that"],
      );

  @override
  double webAudioApiAudioRenderCapacityEventGetPeakLoad(
      {required AudioRenderCapacityEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventGetPeakLoadConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityEventGetPeakLoadConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacityEvent_get_peak_load",
        argNames: ["that"],
      );

  @override
  double webAudioApiAudioRenderCapacityEventGetTimestamp(
      {required AudioRenderCapacityEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventGetTimestampConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityEventGetTimestampConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacityEvent_get_timestamp",
        argNames: ["that"],
      );

  @override
  double webAudioApiAudioRenderCapacityEventGetUnderrunRatio(
      {required AudioRenderCapacityEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventGetUnderrunRatioConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiAudioRenderCapacityEventGetUnderrunRatioConstMeta =>
          const TaskConstMeta(
            debugName: "AudioRenderCapacityEvent_get_underrun_ratio",
            argNames: ["that"],
          );

  @override
  void webAudioApiAudioRenderCapacityEventSetAverageLoad(
      {required AudioRenderCapacityEvent that, required double averageLoad}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        sse_encode_f_64(averageLoad, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventSetAverageLoadConstMeta,
      argValues: [that, averageLoad],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiAudioRenderCapacityEventSetAverageLoadConstMeta =>
          const TaskConstMeta(
            debugName: "AudioRenderCapacityEvent_set_average_load",
            argNames: ["that", "averageLoad"],
          );

  @override
  void webAudioApiAudioRenderCapacityEventSetEvent(
      {required AudioRenderCapacityEvent that, required Event event}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            event, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventSetEventConstMeta,
      argValues: [that, event],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityEventSetEventConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacityEvent_set_event",
        argNames: ["that", "event"],
      );

  @override
  void webAudioApiAudioRenderCapacityEventSetPeakLoad(
      {required AudioRenderCapacityEvent that, required double peakLoad}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        sse_encode_f_64(peakLoad, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventSetPeakLoadConstMeta,
      argValues: [that, peakLoad],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityEventSetPeakLoadConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacityEvent_set_peak_load",
        argNames: ["that", "peakLoad"],
      );

  @override
  void webAudioApiAudioRenderCapacityEventSetTimestamp(
      {required AudioRenderCapacityEvent that, required double timestamp}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        sse_encode_f_64(timestamp, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventSetTimestampConstMeta,
      argValues: [that, timestamp],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityEventSetTimestampConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacityEvent_set_timestamp",
        argNames: ["that", "timestamp"],
      );

  @override
  void webAudioApiAudioRenderCapacityEventSetUnderrunRatio(
      {required AudioRenderCapacityEvent that, required double underrunRatio}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            that, serializer);
        sse_encode_f_64(underrunRatio, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityEventSetUnderrunRatioConstMeta,
      argValues: [that, underrunRatio],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiAudioRenderCapacityEventSetUnderrunRatioConstMeta =>
          const TaskConstMeta(
            debugName: "AudioRenderCapacityEvent_set_underrun_ratio",
            argNames: ["that", "underrunRatio"],
          );

  @override
  Future<void> webAudioApiAudioRenderCapacityClearOnupdate(
      {required AudioRenderCapacity that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityClearOnupdateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityClearOnupdateConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacity_clear_onupdate",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiAudioRenderCapacitySetOnupdate(
      {required AudioRenderCapacity that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacitySetOnupdateConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacitySetOnupdateConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacity_set_onupdate",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiAudioRenderCapacityStart(
      {required AudioRenderCapacity that,
      required AudioRenderCapacityOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
            that, serializer);
        sse_encode_box_autoadd_audio_render_capacity_options(
            options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityStartConstMeta,
      argValues: [that, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityStartConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacity_start",
        argNames: ["that", "options"],
      );

  @override
  Future<void> webAudioApiAudioRenderCapacityStop(
      {required AudioRenderCapacity that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioRenderCapacityStopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioRenderCapacityStopConstMeta =>
      const TaskConstMeta(
        debugName: "AudioRenderCapacity_stop",
        argNames: ["that"],
      );

  @override
  Future<F32> webAudioApiChannelDataAsMutSlice({required ChannelData that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiChannelDataAsMutSliceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiChannelDataAsMutSliceConstMeta =>
      const TaskConstMeta(
        debugName: "ChannelData_as_mut_slice",
        argNames: ["that"],
      );

  @override
  Future<F32> webAudioApiChannelDataAsSlice({required ChannelData that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiChannelDataAsSliceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiChannelDataAsSliceConstMeta =>
      const TaskConstMeta(
        debugName: "ChannelData_as_slice",
        argNames: ["that"],
      );

  @override
  Future<ChannelData> webAudioApiChannelDataFrom({required List<double> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_f_32_loose(data, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiChannelDataFromConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiChannelDataFromConstMeta => const TaskConstMeta(
        debugName: "ChannelData_from",
        argNames: ["data"],
      );

  @override
  Future<bool> webAudioApiChannelDataIsEmpty({required ChannelData that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiChannelDataIsEmptyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiChannelDataIsEmptyConstMeta =>
      const TaskConstMeta(
        debugName: "ChannelData_is_empty",
        argNames: ["that"],
      );

  @override
  Future<BigInt> webAudioApiChannelDataLen({required ChannelData that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiChannelDataLenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiChannelDataLenConstMeta => const TaskConstMeta(
        debugName: "ChannelData_len",
        argNames: ["that"],
      );

  @override
  Future<ChannelData> webAudioApiChannelDataNew({required BigInt length}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(length, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiChannelDataNewConstMeta,
      argValues: [length],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiChannelDataNewConstMeta => const TaskConstMeta(
        debugName: "ChannelData_new",
        argNames: ["length"],
      );

  @override
  BoxAny webAudioApiErrorEventGetError({required ErrorEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiErrorEventGetErrorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiErrorEventGetErrorConstMeta =>
      const TaskConstMeta(
        debugName: "ErrorEvent_get_error",
        argNames: ["that"],
      );

  @override
  Event webAudioApiErrorEventGetEvent({required ErrorEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiErrorEventGetEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiErrorEventGetEventConstMeta =>
      const TaskConstMeta(
        debugName: "ErrorEvent_get_event",
        argNames: ["that"],
      );

  @override
  String webAudioApiErrorEventGetMessage({required ErrorEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiErrorEventGetMessageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiErrorEventGetMessageConstMeta =>
      const TaskConstMeta(
        debugName: "ErrorEvent_get_message",
        argNames: ["that"],
      );

  @override
  void webAudioApiErrorEventSetError(
      {required ErrorEvent that, required BoxAny error}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
            error, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiErrorEventSetErrorConstMeta,
      argValues: [that, error],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiErrorEventSetErrorConstMeta =>
      const TaskConstMeta(
        debugName: "ErrorEvent_set_error",
        argNames: ["that", "error"],
      );

  @override
  void webAudioApiErrorEventSetEvent(
      {required ErrorEvent that, required Event event}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            event, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiErrorEventSetEventConstMeta,
      argValues: [that, event],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiErrorEventSetEventConstMeta =>
      const TaskConstMeta(
        debugName: "ErrorEvent_set_event",
        argNames: ["that", "event"],
      );

  @override
  void webAudioApiErrorEventSetMessage(
      {required ErrorEvent that, required String message}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            that, serializer);
        sse_encode_String(message, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiErrorEventSetMessageConstMeta,
      argValues: [that, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiErrorEventSetMessageConstMeta =>
      const TaskConstMeta(
        debugName: "ErrorEvent_set_message",
        argNames: ["that", "message"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchAudioProcessing(
      {required AudioNodeId id, required AudioProcessingEvent value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_node_id(id, serializer);
        sse_encode_box_autoadd_audio_processing_event(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchAudioProcessingConstMeta,
      argValues: [id, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchAudioProcessingConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_audio_processing",
        argNames: ["id", "value"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchComplete(
      {required AudioBuffer buffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(buffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchCompleteConstMeta,
      argValues: [buffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchCompleteConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_complete",
        argNames: ["buffer"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchDiagnostics(
      {required List<int> value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchDiagnosticsConstMeta,
      argValues: [value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchDiagnosticsConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_diagnostics",
        argNames: ["value"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchEnded(
      {required AudioNodeId id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_node_id(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchEndedConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchEndedConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_ended",
        argNames: ["id"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchMessage(
      {required AudioNodeId id, required BoxAny value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_node_id(id, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
            value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchMessageConstMeta,
      argValues: [id, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchMessageConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_message",
        argNames: ["id", "value"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchProcessorError(
      {required AudioNodeId id, required ErrorEvent value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_node_id(id, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
            value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchProcessorErrorConstMeta,
      argValues: [id, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchProcessorErrorConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_processor_error",
        argNames: ["id", "value"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchRenderCapacity(
      {required AudioRenderCapacityEvent value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
            value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchRenderCapacityConstMeta,
      argValues: [value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchRenderCapacityConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_render_capacity",
        argNames: ["value"],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchSinkChange() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchSinkChangeConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchSinkChangeConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_sink_change",
        argNames: [],
      );

  @override
  Future<EventDispatch> webAudioApiEventDispatchStateChange(
      {required AudioContextState state}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_audio_context_state(state, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventDispatchStateChangeConstMeta,
      argValues: [state],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventDispatchStateChangeConstMeta =>
      const TaskConstMeta(
        debugName: "EventDispatch_state_change",
        argNames: ["state"],
      );

  @override
  Future<void> webAudioApiEventLoopClearHandler(
      {required EventLoop that, required EventType event}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
            that, serializer);
        sse_encode_box_autoadd_event_type(event, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventLoopClearHandlerConstMeta,
      argValues: [that, event],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventLoopClearHandlerConstMeta =>
      const TaskConstMeta(
        debugName: "EventLoop_clear_handler",
        argNames: ["that", "event"],
      );

  @override
  Future<bool> webAudioApiEventLoopHandlePendingEvents(
      {required EventLoop that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventLoopHandlePendingEventsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventLoopHandlePendingEventsConstMeta =>
      const TaskConstMeta(
        debugName: "EventLoop_handle_pending_events",
        argNames: ["that"],
      );

  @override
  Future<EventLoop> webAudioApiEventLoopNew(
      {required ReceiverEventDispatch eventRecv}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
            eventRecv, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventLoopNewConstMeta,
      argValues: [eventRecv],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventLoopNewConstMeta => const TaskConstMeta(
        debugName: "EventLoop_new",
        argNames: ["eventRecv"],
      );

  @override
  Future<void> webAudioApiEventLoopRunInThread({required EventLoop that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventLoopRunInThreadConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventLoopRunInThreadConstMeta =>
      const TaskConstMeta(
        debugName: "EventLoop_run_in_thread",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiEventLoopSetHandler(
      {required EventLoop that,
      required EventType event,
      required EventHandler callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
            that, serializer);
        sse_encode_box_autoadd_event_type(event, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventLoopSetHandlerConstMeta,
      argValues: [that, event, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventLoopSetHandlerConstMeta =>
      const TaskConstMeta(
        debugName: "EventLoop_set_handler",
        argNames: ["that", "event", "callback"],
      );

  @override
  Str webAudioApiEventGetType({required Event that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventGetTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventGetTypeConstMeta => const TaskConstMeta(
        debugName: "Event_get_type_",
        argNames: ["that"],
      );

  @override
  void webAudioApiEventSetType({required Event that, required Str type}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
            type, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiEventSetTypeConstMeta,
      argValues: [that, type],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiEventSetTypeConstMeta => const TaskConstMeta(
        debugName: "Event_set_type_",
        argNames: ["that", "type"],
      );

  @override
  Event webAudioApiOfflineAudioCompletionEventGetEvent(
      {required OfflineAudioCompletionEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiOfflineAudioCompletionEventGetEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiOfflineAudioCompletionEventGetEventConstMeta =>
      const TaskConstMeta(
        debugName: "OfflineAudioCompletionEvent_get_event",
        argNames: ["that"],
      );

  @override
  AudioBuffer webAudioApiOfflineAudioCompletionEventGetRenderedBuffer(
      {required OfflineAudioCompletionEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio_buffer,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiOfflineAudioCompletionEventGetRenderedBufferConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiOfflineAudioCompletionEventGetRenderedBufferConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioCompletionEvent_get_rendered_buffer",
            argNames: ["that"],
          );

  @override
  void webAudioApiOfflineAudioCompletionEventSetEvent(
      {required OfflineAudioCompletionEvent that, required Event event}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            event, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiOfflineAudioCompletionEventSetEventConstMeta,
      argValues: [that, event],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiOfflineAudioCompletionEventSetEventConstMeta =>
      const TaskConstMeta(
        debugName: "OfflineAudioCompletionEvent_set_event",
        argNames: ["that", "event"],
      );

  @override
  void webAudioApiOfflineAudioCompletionEventSetRenderedBuffer(
      {required OfflineAudioCompletionEvent that,
      required AudioBuffer renderedBuffer}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
            that, serializer);
        sse_encode_audio_buffer(renderedBuffer, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiOfflineAudioCompletionEventSetRenderedBufferConstMeta,
      argValues: [that, renderedBuffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiOfflineAudioCompletionEventSetRenderedBufferConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioCompletionEvent_set_rendered_buffer",
            argNames: ["that", "renderedBuffer"],
          );

  @override
  Future<PeriodicWave> webAudioApiPeriodicWaveNew(
      {required C context, required PeriodicWaveOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_periodic_wave_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiPeriodicWaveNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiPeriodicWaveNewConstMeta => const TaskConstMeta(
        debugName: "PeriodicWave_new",
        argNames: ["context", "options"],
      );

  @override
  Future<void> webAudioApiAudioBufferCopyFromChannel(
      {required AudioBuffer that,
      required F32 destination,
      required BigInt channelNumber}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            destination, serializer);
        sse_encode_usize(channelNumber, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferCopyFromChannelConstMeta,
      argValues: [that, destination, channelNumber],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferCopyFromChannelConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_copy_from_channel",
        argNames: ["that", "destination", "channelNumber"],
      );

  @override
  Future<void> webAudioApiAudioBufferCopyFromChannelWithOffset(
      {required AudioBuffer that,
      required F32 destination,
      required BigInt channelNumber,
      required BigInt offset}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            destination, serializer);
        sse_encode_usize(channelNumber, serializer);
        sse_encode_usize(offset, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferCopyFromChannelWithOffsetConstMeta,
      argValues: [that, destination, channelNumber, offset],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferCopyFromChannelWithOffsetConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_copy_from_channel_with_offset",
        argNames: ["that", "destination", "channelNumber", "offset"],
      );

  @override
  Future<void> webAudioApiAudioBufferCopyToChannel(
      {required AudioBuffer that,
      required F32 source,
      required BigInt channelNumber}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            source, serializer);
        sse_encode_usize(channelNumber, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferCopyToChannelConstMeta,
      argValues: [that, source, channelNumber],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferCopyToChannelConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_copy_to_channel",
        argNames: ["that", "source", "channelNumber"],
      );

  @override
  Future<void> webAudioApiAudioBufferCopyToChannelWithOffset(
      {required AudioBuffer that,
      required F32 source,
      required BigInt channelNumber,
      required BigInt offset}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            source, serializer);
        sse_encode_usize(channelNumber, serializer);
        sse_encode_usize(offset, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferCopyToChannelWithOffsetConstMeta,
      argValues: [that, source, channelNumber, offset],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferCopyToChannelWithOffsetConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_copy_to_channel_with_offset",
        argNames: ["that", "source", "channelNumber", "offset"],
      );

  @override
  Future<double> webAudioApiAudioBufferDuration({required AudioBuffer that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 74, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferDurationConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferDurationConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_duration",
        argNames: ["that"],
      );

  @override
  Future<AudioBuffer> webAudioApiAudioBufferFrom(
      {required List<Float32List> samples, required double sampleRate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_list_prim_f_32_strict(samples, serializer);
        sse_encode_f_32(sampleRate, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio_buffer,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferFromConstMeta,
      argValues: [samples, sampleRate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferFromConstMeta => const TaskConstMeta(
        debugName: "audio_buffer_from",
        argNames: ["samples", "sampleRate"],
      );

  @override
  Future<F32> webAudioApiAudioBufferGetChannelData(
      {required AudioBuffer that, required BigInt channelNumber}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        sse_encode_usize(channelNumber, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferGetChannelDataConstMeta,
      argValues: [that, channelNumber],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferGetChannelDataConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_get_channel_data",
        argNames: ["that", "channelNumber"],
      );

  @override
  Future<F32> webAudioApiAudioBufferGetChannelDataMut(
      {required AudioBuffer that, required BigInt channelNumber}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
            that, serializer);
        sse_encode_usize(channelNumber, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferGetChannelDataMutConstMeta,
      argValues: [that, channelNumber],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferGetChannelDataMutConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_get_channel_data_mut",
        argNames: ["that", "channelNumber"],
      );

  @override
  Future<BigInt> webAudioApiAudioBufferLength({required AudioBuffer that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferLengthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferLengthConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_length",
        argNames: ["that"],
      );

  @override
  Future<AudioBuffer> webAudioApiAudioBufferNew(
      {required AudioBufferOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 79, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio_buffer,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferNewConstMeta,
      argValues: [options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferNewConstMeta => const TaskConstMeta(
        debugName: "audio_buffer_new",
        argNames: ["options"],
      );

  @override
  Future<BigInt> webAudioApiAudioBufferNumberOfChannels(
      {required AudioBuffer that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferNumberOfChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferNumberOfChannelsConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_number_of_channels",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiAudioBufferSampleRate({required AudioBuffer that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_buffer(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAudioBufferSampleRateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAudioBufferSampleRateConstMeta =>
      const TaskConstMeta(
        debugName: "audio_buffer_sample_rate",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiContextAudioContextBaseLatency(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextBaseLatencyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextBaseLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_base_latency",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextClearOnsinkchange(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextClearOnsinkchangeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextClearOnsinkchangeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_clear_onsinkchange",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextClose(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextCloseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextCloseConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_close",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextCloseSync(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextCloseSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextCloseSyncConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_close_sync",
        argNames: ["that"],
      );

  @override
  Future<MediaElementAudioSourceNode>
      webAudioApiContextAudioContextCreateMediaElementSource(
          {required AudioContext that, required MediaElement mediaElement}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
            mediaElement, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiContextAudioContextCreateMediaElementSourceConstMeta,
      argValues: [that, mediaElement],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextAudioContextCreateMediaElementSourceConstMeta =>
          const TaskConstMeta(
            debugName: "AudioContext_create_media_element_source",
            argNames: ["that", "mediaElement"],
          );

  @override
  Future<MediaStreamAudioDestinationNode>
      webAudioApiContextAudioContextCreateMediaStreamDestination(
          {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiContextAudioContextCreateMediaStreamDestinationConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextAudioContextCreateMediaStreamDestinationConstMeta =>
          const TaskConstMeta(
            debugName: "AudioContext_create_media_stream_destination",
            argNames: ["that"],
          );

  @override
  Future<MediaStreamAudioSourceNode>
      webAudioApiContextAudioContextCreateMediaStreamSource(
          {required AudioContext that, required MediaStream media}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        sse_encode_box_autoadd_media_stream(media, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiContextAudioContextCreateMediaStreamSourceConstMeta,
      argValues: [that, media],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextAudioContextCreateMediaStreamSourceConstMeta =>
          const TaskConstMeta(
            debugName: "AudioContext_create_media_stream_source",
            argNames: ["that", "media"],
          );

  @override
  Future<MediaStreamTrackAudioSourceNode>
      webAudioApiContextAudioContextCreateMediaStreamTrackSource(
          {required AudioContext that, required MediaStreamTrack media}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            media, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 89, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiContextAudioContextCreateMediaStreamTrackSourceConstMeta,
      argValues: [that, media],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextAudioContextCreateMediaStreamTrackSourceConstMeta =>
          const TaskConstMeta(
            debugName: "AudioContext_create_media_stream_track_source",
            argNames: ["that", "media"],
          );

  @override
  Future<AudioContext> webAudioApiContextAudioContextNew(
      {required AudioContextOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_audio_context_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 90, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextNewConstMeta,
      argValues: [options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextNewConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_new",
        argNames: ["options"],
      );

  @override
  Future<double> webAudioApiContextAudioContextOutputLatency(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextOutputLatencyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextOutputLatencyConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_output_latency",
        argNames: ["that"],
      );

  @override
  Future<AudioRenderCapacity> webAudioApiContextAudioContextRenderCapacity(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 92, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextRenderCapacityConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextRenderCapacityConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_render_capacity",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextResume(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 93, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextResumeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextResumeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_resume",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextResumeSync(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 94, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextResumeSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextResumeSyncConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_resume_sync",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextRunDiagnostics(
      {required AudioContext that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 95, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextRunDiagnosticsConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextRunDiagnosticsConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_run_diagnostics",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiContextAudioContextSetOnsinkchange(
      {required AudioContext that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 96, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextSetOnsinkchangeConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextSetOnsinkchangeConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_set_onsinkchange",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiContextAudioContextSetSinkIdSync(
      {required AudioContext that, required String sinkId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        sse_encode_String(sinkId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 97, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError,
      ),
      constMeta: kWebAudioApiContextAudioContextSetSinkIdSyncConstMeta,
      argValues: [that, sinkId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextSetSinkIdSyncConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_set_sink_id_sync",
        argNames: ["that", "sinkId"],
      );

  @override
  Future<String> webAudioApiContextAudioContextSinkId(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 98, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextSinkIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextSinkIdConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_sink_id",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextSuspend(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 99, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextSuspendConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextSuspendConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_suspend",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextAudioContextSuspendSync(
      {required AudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextAudioContextSuspendSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextAudioContextSuspendSyncConstMeta =>
      const TaskConstMeta(
        debugName: "AudioContext_suspend_sync",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextConcreteBaseAudioContextMarkCycleBreaker(
      {required ConcreteBaseAudioContext that,
      required AudioContextRegistration reg}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
            reg, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 101, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiContextConcreteBaseAudioContextMarkCycleBreakerConstMeta,
      argValues: [that, reg],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextConcreteBaseAudioContextMarkCycleBreakerConstMeta =>
          const TaskConstMeta(
            debugName: "ConcreteBaseAudioContext_mark_cycle_breaker",
            argNames: ["that", "reg"],
          );

  @override
  Future<void> webAudioApiContextOfflineAudioContextClearOncomplete(
      {required OfflineAudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 102, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextClearOncompleteConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextOfflineAudioContextClearOncompleteConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioContext_clear_oncomplete",
            argNames: ["that"],
          );

  @override
  Future<BigInt> webAudioApiContextOfflineAudioContextLength(
      {required OfflineAudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 103, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextLengthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextOfflineAudioContextLengthConstMeta =>
      const TaskConstMeta(
        debugName: "OfflineAudioContext_length",
        argNames: ["that"],
      );

  @override
  Future<OfflineAudioContext> webAudioApiContextOfflineAudioContextNew(
      {required BigInt numberOfChannels,
      required BigInt length,
      required double sampleRate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(numberOfChannels, serializer);
        sse_encode_usize(length, serializer);
        sse_encode_f_32(sampleRate, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 104, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextNewConstMeta,
      argValues: [numberOfChannels, length, sampleRate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextOfflineAudioContextNewConstMeta =>
      const TaskConstMeta(
        debugName: "OfflineAudioContext_new",
        argNames: ["numberOfChannels", "length", "sampleRate"],
      );

  @override
  Future<void> webAudioApiContextOfflineAudioContextResume(
      {required OfflineAudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 105, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextResumeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextOfflineAudioContextResumeConstMeta =>
      const TaskConstMeta(
        debugName: "OfflineAudioContext_resume",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiContextOfflineAudioContextSetOncomplete(
      {required OfflineAudioContext that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 106, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextSetOncompleteConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextOfflineAudioContextSetOncompleteConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioContext_set_oncomplete",
            argNames: ["that", "callback"],
          );

  @override
  Future<AudioBuffer> webAudioApiContextOfflineAudioContextStartRendering(
      {required OfflineAudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 107, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio_buffer,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextStartRenderingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextOfflineAudioContextStartRenderingConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioContext_start_rendering",
            argNames: ["that"],
          );

  @override
  Future<AudioBuffer> webAudioApiContextOfflineAudioContextStartRenderingSync(
      {required OfflineAudioContext that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 108, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio_buffer,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiContextOfflineAudioContextStartRenderingSyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextOfflineAudioContextStartRenderingSyncConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioContext_start_rendering_sync",
            argNames: ["that"],
          );

  @override
  Future<void> webAudioApiContextOfflineAudioContextSuspend(
      {required OfflineAudioContext that, required double suspendTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        sse_encode_f_64(suspendTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 109, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextSuspendConstMeta,
      argValues: [that, suspendTime],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiContextOfflineAudioContextSuspendConstMeta =>
      const TaskConstMeta(
        debugName: "OfflineAudioContext_suspend",
        argNames: ["that", "suspendTime"],
      );

  @override
  Future<void> webAudioApiContextOfflineAudioContextSuspendSync(
      {required OfflineAudioContext that,
      required double suspendTime,
      required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
            that, serializer);
        sse_encode_f_64(suspendTime, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 110, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiContextOfflineAudioContextSuspendSyncConstMeta,
      argValues: [that, suspendTime, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiContextOfflineAudioContextSuspendSyncConstMeta =>
          const TaskConstMeta(
            debugName: "OfflineAudioContext_suspend_sync",
            argNames: ["that", "suspendTime", "callback"],
          );

  @override
  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoDeviceId(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 111, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoDeviceIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoDeviceIdConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_device_id",
        argNames: ["that"],
      );

  @override
  Future<Str?> webAudioApiMediaDevicesMediaDeviceInfoGroupId(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 112, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoGroupIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoGroupIdConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_group_id",
        argNames: ["that"],
      );

  @override
  Future<MediaDeviceInfoKind> webAudioApiMediaDevicesMediaDeviceInfoKind(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 113, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_device_info_kind,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoKindConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoKindConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_kind",
        argNames: ["that"],
      );

  @override
  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoLabel(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 114, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoLabelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoLabelConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_label",
        argNames: ["that"],
      );

  @override
  Future<List<MediaDeviceInfo>> webAudioApiMediaDevicesEnumerateDevicesSync() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 115, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesEnumerateDevicesSyncConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesEnumerateDevicesSyncConstMeta =>
      const TaskConstMeta(
        debugName: "enumerate_devices_sync",
        argNames: [],
      );

  @override
  Future<MediaStream> webAudioApiMediaDevicesGetUserMediaSync(
      {required MediaStreamConstraints constraints}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream_constraints(
            constraints, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 116, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesGetUserMediaSyncConstMeta,
      argValues: [constraints],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesGetUserMediaSyncConstMeta =>
      const TaskConstMeta(
        debugName: "get_user_media_sync",
        argNames: ["constraints"],
      );

  @override
  Uint8List webAudioApiMediaRecorderBlobEventGetBlob(
      {required BlobEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 117)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventGetBlobConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventGetBlobConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_get_blob",
        argNames: ["that"],
      );

  @override
  Event webAudioApiMediaRecorderBlobEventGetEvent({required BlobEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 118)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventGetEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventGetEventConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_get_event",
        argNames: ["that"],
      );

  @override
  double webAudioApiMediaRecorderBlobEventGetTimecode(
      {required BlobEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 119)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventGetTimecodeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventGetTimecodeConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_get_timecode",
        argNames: ["that"],
      );

  @override
  void webAudioApiMediaRecorderBlobEventSetBlob(
      {required BlobEvent that, required Uint8List blob}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        sse_encode_list_prim_u_8_strict(blob, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 120)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventSetBlobConstMeta,
      argValues: [that, blob],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventSetBlobConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_set_blob",
        argNames: ["that", "blob"],
      );

  @override
  void webAudioApiMediaRecorderBlobEventSetEvent(
      {required BlobEvent that, required Event event}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            event, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 121)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventSetEventConstMeta,
      argValues: [that, event],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventSetEventConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_set_event",
        argNames: ["that", "event"],
      );

  @override
  void webAudioApiMediaRecorderBlobEventSetTimecode(
      {required BlobEvent that, required double timecode}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        sse_encode_f_64(timecode, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 122)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventSetTimecodeConstMeta,
      argValues: [that, timecode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventSetTimecodeConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_set_timecode",
        argNames: ["that", "timecode"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderClearOndataavailable(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 123, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiMediaRecorderMediaRecorderClearOndataavailableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderClearOndataavailableConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_clear_ondataavailable",
            argNames: ["that"],
          );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnerror(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 124, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderClearOnerrorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderClearOnerrorConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_clear_onerror",
            argNames: ["that"],
          );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnstop(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 125, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderClearOnstopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderClearOnstopConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_clear_onstop",
            argNames: ["that"],
          );

  @override
  Future<MediaRecorder> webAudioApiMediaRecorderMediaRecorderNew(
      {required MediaStream stream}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream(stream, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 126, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderNewConstMeta,
      argValues: [stream],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderNewConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_new",
        argNames: ["stream"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderSetOndataavailable(
      {required MediaRecorder that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 127, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiMediaRecorderMediaRecorderSetOndataavailableConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderSetOndataavailableConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_set_ondataavailable",
            argNames: ["that", "callback"],
          );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnerror(
      {required MediaRecorder that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 128, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderSetOnerrorConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderSetOnerrorConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_set_onerror",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnstop(
      {required MediaRecorder that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 129, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderSetOnstopConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderSetOnstopConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_set_onstop",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderStart(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 130, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderStartConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderStartConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_start",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderStop(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 131, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderStopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderStopConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_stop",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiMediaStreamsMediaStreamTrackClose(
      {required MediaStreamTrack that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 132, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamTrackCloseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamTrackCloseConstMeta =>
      const TaskConstMeta(
        debugName: "MediaStreamTrack_close",
        argNames: ["that"],
      );

  @override
  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamTrackFromIter(
      {required T iter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
            iter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 133, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamTrackFromIterConstMeta,
      argValues: [iter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamTrackFromIterConstMeta =>
      const TaskConstMeta(
        debugName: "MediaStreamTrack_from_iter",
        argNames: ["iter"],
      );

  @override
  Future<MediaStreamTrackState>
      webAudioApiMediaStreamsMediaStreamTrackReadyState(
          {required MediaStreamTrack that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 134, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream_track_state,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamTrackReadyStateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaStreamsMediaStreamTrackReadyStateConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamTrack_ready_state",
            argNames: ["that"],
          );

  @override
  Future<MediaStream> webAudioApiMediaStreamsMediaStreamFromTracks(
      {required List<MediaStreamTrack> tracks}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            tracks, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 135, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamFromTracksConstMeta,
      argValues: [tracks],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamFromTracksConstMeta =>
      const TaskConstMeta(
        debugName: "media_stream_from_tracks",
        argNames: ["tracks"],
      );

  @override
  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamGetTracks(
      {required MediaStream that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 136, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamGetTracksConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamGetTracksConstMeta =>
      const TaskConstMeta(
        debugName: "media_stream_get_tracks",
        argNames: ["that"],
      );

  @override
  Future<BigInt> webAudioApiNodeAnalyserNodeFftSize(
      {required AnalyserNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 137, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeFftSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeFftSizeConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_fft_size",
        argNames: ["that"],
      );

  @override
  Future<BigInt> webAudioApiNodeAnalyserNodeFrequencyBinCount(
      {required AnalyserNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 138, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeFrequencyBinCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeFrequencyBinCountConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_frequency_bin_count",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeAnalyserNodeGetByteFrequencyData(
      {required AnalyserNode that, required U8 buffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
            buffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 139, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeGetByteFrequencyDataConstMeta,
      argValues: [that, buffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeGetByteFrequencyDataConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_get_byte_frequency_data",
        argNames: ["that", "buffer"],
      );

  @override
  Future<void> webAudioApiNodeAnalyserNodeGetByteTimeDomainData(
      {required AnalyserNode that, required U8 buffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
            buffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 140, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeGetByteTimeDomainDataConstMeta,
      argValues: [that, buffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAnalyserNodeGetByteTimeDomainDataConstMeta =>
          const TaskConstMeta(
            debugName: "AnalyserNode_get_byte_time_domain_data",
            argNames: ["that", "buffer"],
          );

  @override
  Future<void> webAudioApiNodeAnalyserNodeGetFloatFrequencyData(
      {required AnalyserNode that, required F32 buffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            buffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 141, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeGetFloatFrequencyDataConstMeta,
      argValues: [that, buffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAnalyserNodeGetFloatFrequencyDataConstMeta =>
          const TaskConstMeta(
            debugName: "AnalyserNode_get_float_frequency_data",
            argNames: ["that", "buffer"],
          );

  @override
  Future<void> webAudioApiNodeAnalyserNodeGetFloatTimeDomainData(
      {required AnalyserNode that, required F32 buffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            buffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 142, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeGetFloatTimeDomainDataConstMeta,
      argValues: [that, buffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAnalyserNodeGetFloatTimeDomainDataConstMeta =>
          const TaskConstMeta(
            debugName: "AnalyserNode_get_float_time_domain_data",
            argNames: ["that", "buffer"],
          );

  @override
  Future<double> webAudioApiNodeAnalyserNodeMaxDecibels(
      {required AnalyserNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 143, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeMaxDecibelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeMaxDecibelsConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_max_decibels",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodeAnalyserNodeMinDecibels(
      {required AnalyserNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 144, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeMinDecibelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeMinDecibelsConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_min_decibels",
        argNames: ["that"],
      );

  @override
  Future<AnalyserNode> webAudioApiNodeAnalyserNodeNew(
      {required C context, required AnalyserOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_analyser_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 145, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<void> webAudioApiNodeAnalyserNodeSetFftSize(
      {required AnalyserNode that, required BigInt fftSize}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_usize(fftSize, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 146, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeSetFftSizeConstMeta,
      argValues: [that, fftSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeSetFftSizeConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_set_fft_size",
        argNames: ["that", "fftSize"],
      );

  @override
  Future<void> webAudioApiNodeAnalyserNodeSetMaxDecibels(
      {required AnalyserNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 147, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeSetMaxDecibelsConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeSetMaxDecibelsConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_set_max_decibels",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodeAnalyserNodeSetMinDecibels(
      {required AnalyserNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 148, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeSetMinDecibelsConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAnalyserNodeSetMinDecibelsConstMeta =>
      const TaskConstMeta(
        debugName: "AnalyserNode_set_min_decibels",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodeAnalyserNodeSetSmoothingTimeConstant(
      {required AnalyserNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 149, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeSetSmoothingTimeConstantConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAnalyserNodeSetSmoothingTimeConstantConstMeta =>
          const TaskConstMeta(
            debugName: "AnalyserNode_set_smoothing_time_constant",
            argNames: ["that", "value"],
          );

  @override
  Future<double> webAudioApiNodeAnalyserNodeSmoothingTimeConstant(
      {required AnalyserNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 150, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAnalyserNodeSmoothingTimeConstantConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAnalyserNodeSmoothingTimeConstantConstMeta =>
          const TaskConstMeta(
            debugName: "AnalyserNode_smoothing_time_constant",
            argNames: ["that"],
          );

  @override
  Future<AudioBuffer?> webAudioApiNodeAudioBufferSourceNodeBuffer(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 151, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeBufferConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeBufferConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_buffer",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeAudioBufferSourceNodeDetune(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 152, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeDetuneConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeDetuneConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_detune",
        argNames: ["that"],
      );

  @override
  Future<bool> webAudioApiNodeAudioBufferSourceNodeLoop(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 153, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeLoopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeLoopConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_loop_",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodeAudioBufferSourceNodeLoopEnd(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 154, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeLoopEndConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeLoopEndConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_loop_end",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodeAudioBufferSourceNodeLoopStart(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 155, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeLoopStartConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeLoopStartConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_loop_start",
        argNames: ["that"],
      );

  @override
  Future<AudioBufferSourceNode> webAudioApiNodeAudioBufferSourceNodeNew(
      {required C context, required AudioBufferSourceOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_audio_buffer_source_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 156, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodeAudioBufferSourceNodePlaybackRate(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 157, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodePlaybackRateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAudioBufferSourceNodePlaybackRateConstMeta =>
          const TaskConstMeta(
            debugName: "AudioBufferSourceNode_playback_rate",
            argNames: ["that"],
          );

  @override
  Future<double> webAudioApiNodeAudioBufferSourceNodePosition(
      {required AudioBufferSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 158, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodePositionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodePositionConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_position",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeAudioBufferSourceNodeSetBuffer(
      {required AudioBufferSourceNode that, required AudioBuffer audioBuffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        sse_encode_box_autoadd_audio_buffer(audioBuffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 159, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeSetBufferConstMeta,
      argValues: [that, audioBuffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeSetBufferConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_set_buffer",
        argNames: ["that", "audioBuffer"],
      );

  @override
  Future<void> webAudioApiNodeAudioBufferSourceNodeSetLoop(
      {required AudioBufferSourceNode that, required bool value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        sse_encode_bool(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 160, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeSetLoopConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeSetLoopConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_set_loop",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodeAudioBufferSourceNodeSetLoopEnd(
      {required AudioBufferSourceNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 161, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeSetLoopEndConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeAudioBufferSourceNodeSetLoopEndConstMeta =>
      const TaskConstMeta(
        debugName: "AudioBufferSourceNode_set_loop_end",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodeAudioBufferSourceNodeSetLoopStart(
      {required AudioBufferSourceNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 162, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioBufferSourceNodeSetLoopStartConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAudioBufferSourceNodeSetLoopStartConstMeta =>
          const TaskConstMeta(
            debugName: "AudioBufferSourceNode_set_loop_start",
            argNames: ["that", "value"],
          );

  @override
  Future<void> webAudioApiNodeAudioBufferSourceNodeStartAtWithOffset(
      {required AudioBufferSourceNode that,
      required double start,
      required double offset}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        sse_encode_f_64(start, serializer);
        sse_encode_f_64(offset, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 163, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetConstMeta,
      argValues: [that, start, offset],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetConstMeta =>
          const TaskConstMeta(
            debugName: "AudioBufferSourceNode_start_at_with_offset",
            argNames: ["that", "start", "offset"],
          );

  @override
  Future<void> webAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetAndDuration(
      {required AudioBufferSourceNode that,
      required double start,
      required double offset,
      required double duration}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
            that, serializer);
        sse_encode_f_64(start, serializer);
        sse_encode_f_64(offset, serializer);
        sse_encode_f_64(duration, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 164, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetAndDurationConstMeta,
      argValues: [that, start, offset, duration],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetAndDurationConstMeta =>
          const TaskConstMeta(
            debugName:
                "AudioBufferSourceNode_start_at_with_offset_and_duration",
            argNames: ["that", "start", "offset", "duration"],
          );

  @override
  Future<BigInt> webAudioApiNodeAudioDestinationNodeMaxChannelCount(
      {required AudioDestinationNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 165, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeAudioDestinationNodeMaxChannelCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeAudioDestinationNodeMaxChannelCountConstMeta =>
          const TaskConstMeta(
            debugName: "AudioDestinationNode_max_channel_count",
            argNames: ["that"],
          );

  @override
  Future<AudioParam> webAudioApiNodeBiquadFilterNodeDetune(
      {required BiquadFilterNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 166, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeDetuneConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeDetuneConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_detune",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeBiquadFilterNodeFrequency(
      {required BiquadFilterNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 167, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeFrequencyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeFrequencyConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_frequency",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeBiquadFilterNodeGain(
      {required BiquadFilterNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 168, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeGainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeGainConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_gain",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeBiquadFilterNodeGetFrequencyResponse(
      {required BiquadFilterNode that,
      required F32 frequencyHz,
      required F32 magResponse,
      required F32 phaseResponse}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            frequencyHz, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            magResponse, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            phaseResponse, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 169, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeGetFrequencyResponseConstMeta,
      argValues: [that, frequencyHz, magResponse, phaseResponse],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeBiquadFilterNodeGetFrequencyResponseConstMeta =>
          const TaskConstMeta(
            debugName: "BiquadFilterNode_get_frequency_response",
            argNames: ["that", "frequencyHz", "magResponse", "phaseResponse"],
          );

  @override
  Future<BiquadFilterNode> webAudioApiNodeBiquadFilterNodeNew(
      {required C context, required BiquadFilterOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_biquad_filter_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 170, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodeBiquadFilterNodeQ(
      {required BiquadFilterNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 171, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeQConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeQConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_q",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeBiquadFilterNodeSetType(
      {required BiquadFilterNode that, required BiquadFilterType type}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        sse_encode_biquad_filter_type(type, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 172, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeSetTypeConstMeta,
      argValues: [that, type],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeSetTypeConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_set_type",
        argNames: ["that", "type"],
      );

  @override
  Future<BiquadFilterType> webAudioApiNodeBiquadFilterNodeType(
      {required BiquadFilterNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 173, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_biquad_filter_type,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeBiquadFilterNodeTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeBiquadFilterNodeTypeConstMeta =>
      const TaskConstMeta(
        debugName: "BiquadFilterNode_type_",
        argNames: ["that"],
      );

  @override
  Future<ChannelMergerNode> webAudioApiNodeChannelMergerNodeNew(
      {required C context, required ChannelMergerOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_channel_merger_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 174, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeChannelMergerNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeChannelMergerNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "ChannelMergerNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<ChannelSplitterNode> webAudioApiNodeChannelSplitterNodeNew(
      {required C context, required ChannelSplitterOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_channel_splitter_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 175, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeChannelSplitterNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeChannelSplitterNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "ChannelSplitterNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<ConstantSourceNode> webAudioApiNodeConstantSourceNodeNew(
      {required C context, required ConstantSourceOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_constant_source_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 176, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConstantSourceNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConstantSourceNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "ConstantSourceNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodeConstantSourceNodeOffset(
      {required ConstantSourceNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 177, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConstantSourceNodeOffsetConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConstantSourceNodeOffsetConstMeta =>
      const TaskConstMeta(
        debugName: "ConstantSourceNode_offset",
        argNames: ["that"],
      );

  @override
  Future<AudioBuffer?> webAudioApiNodeConvolverNodeBuffer(
      {required ConvolverNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 178, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConvolverNodeBufferConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConvolverNodeBufferConstMeta =>
      const TaskConstMeta(
        debugName: "ConvolverNode_buffer",
        argNames: ["that"],
      );

  @override
  Future<ConvolverNode> webAudioApiNodeConvolverNodeNew(
      {required C context, required ConvolverOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_convolver_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 179, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConvolverNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConvolverNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "ConvolverNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<bool> webAudioApiNodeConvolverNodeNormalize(
      {required ConvolverNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 180, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConvolverNodeNormalizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConvolverNodeNormalizeConstMeta =>
      const TaskConstMeta(
        debugName: "ConvolverNode_normalize",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeConvolverNodeSetBuffer(
      {required ConvolverNode that, required AudioBuffer buffer}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
            that, serializer);
        sse_encode_box_autoadd_audio_buffer(buffer, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 181, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConvolverNodeSetBufferConstMeta,
      argValues: [that, buffer],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConvolverNodeSetBufferConstMeta =>
      const TaskConstMeta(
        debugName: "ConvolverNode_set_buffer",
        argNames: ["that", "buffer"],
      );

  @override
  Future<void> webAudioApiNodeConvolverNodeSetNormalize(
      {required ConvolverNode that, required bool value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
            that, serializer);
        sse_encode_bool(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 182, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeConvolverNodeSetNormalizeConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeConvolverNodeSetNormalizeConstMeta =>
      const TaskConstMeta(
        debugName: "ConvolverNode_set_normalize",
        argNames: ["that", "value"],
      );

  @override
  Future<AudioParam> webAudioApiNodeDelayNodeDelayTime(
      {required DelayNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 183, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDelayNodeDelayTimeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDelayNodeDelayTimeConstMeta =>
      const TaskConstMeta(
        debugName: "DelayNode_delay_time",
        argNames: ["that"],
      );

  @override
  Future<DelayNode> webAudioApiNodeDelayNodeNew(
      {required C context, required DelayOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_delay_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 184, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDelayNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDelayNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "DelayNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeAttack(
      {required DynamicsCompressorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 185, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeAttackConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeAttackConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_attack",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeKnee(
      {required DynamicsCompressorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 186, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeKneeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeKneeConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_knee",
        argNames: ["that"],
      );

  @override
  Future<DynamicsCompressorNode> webAudioApiNodeDynamicsCompressorNodeNew(
      {required C context, required DynamicsCompressorOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_dynamics_compressor_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 187, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeRatio(
      {required DynamicsCompressorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 188, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeRatioConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeRatioConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_ratio",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodeDynamicsCompressorNodeReduction(
      {required DynamicsCompressorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 189, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeReductionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeReductionConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_reduction",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeRelease(
      {required DynamicsCompressorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 190, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeReleaseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeReleaseConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_release",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeDynamicsCompressorNodeThreshold(
      {required DynamicsCompressorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 191, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeDynamicsCompressorNodeThresholdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeDynamicsCompressorNodeThresholdConstMeta =>
      const TaskConstMeta(
        debugName: "DynamicsCompressorNode_threshold",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeGainNodeGain({required GainNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 192, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeGainNodeGainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeGainNodeGainConstMeta =>
      const TaskConstMeta(
        debugName: "GainNode_gain",
        argNames: ["that"],
      );

  @override
  Future<GainNode> webAudioApiNodeGainNodeNew(
      {required C context, required GainOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_gain_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 193, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeGainNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeGainNodeNewConstMeta => const TaskConstMeta(
        debugName: "GainNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<void> webAudioApiNodeIirFilterNodeGetFrequencyResponse(
      {required IirFilterNode that,
      required F32 frequencyHz,
      required F32 magResponse,
      required F32 phaseResponse}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            frequencyHz, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            magResponse, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            phaseResponse, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 194, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeIirFilterNodeGetFrequencyResponseConstMeta,
      argValues: [that, frequencyHz, magResponse, phaseResponse],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeIirFilterNodeGetFrequencyResponseConstMeta =>
          const TaskConstMeta(
            debugName: "IirFilterNode_get_frequency_response",
            argNames: ["that", "frequencyHz", "magResponse", "phaseResponse"],
          );

  @override
  Future<IirFilterNode> webAudioApiNodeIirFilterNodeNew(
      {required C context, required IIRFilterOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_iir_filter_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 195, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeIirFilterNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeIirFilterNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "IirFilterNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<MediaElementAudioSourceNode>
      webAudioApiNodeMediaElementAudioSourceNodeNew(
          {required C context,
          required MediaElementAudioSourceOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
            options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 196, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeMediaElementAudioSourceNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeMediaElementAudioSourceNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "MediaElementAudioSourceNode_new",
        argNames: ["context", "options"],
      );

  @override
  MediaElement webAudioApiNodeMediaElementAudioSourceOptionsGetMediaElement(
      {required MediaElementAudioSourceOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 197)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeMediaElementAudioSourceOptionsGetMediaElementConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaElementAudioSourceOptionsGetMediaElementConstMeta =>
          const TaskConstMeta(
            debugName: "MediaElementAudioSourceOptions_get_media_element",
            argNames: ["that"],
          );

  @override
  void webAudioApiNodeMediaElementAudioSourceOptionsSetMediaElement(
      {required MediaElementAudioSourceOptions that,
      required MediaElement mediaElement}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
            that, serializer);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
            mediaElement, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 198)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeMediaElementAudioSourceOptionsSetMediaElementConstMeta,
      argValues: [that, mediaElement],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaElementAudioSourceOptionsSetMediaElementConstMeta =>
          const TaskConstMeta(
            debugName: "MediaElementAudioSourceOptions_set_media_element",
            argNames: ["that", "mediaElement"],
          );

  @override
  Future<MediaStreamAudioDestinationNode>
      webAudioApiNodeMediaStreamAudioDestinationNodeNew(
          {required C context, required AudioNodeOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_audio_node_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 199, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeMediaStreamAudioDestinationNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamAudioDestinationNodeNewConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamAudioDestinationNode_new",
            argNames: ["context", "options"],
          );

  @override
  Future<MediaStream> webAudioApiNodeMediaStreamAudioDestinationNodeStream(
      {required MediaStreamAudioDestinationNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 200, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeMediaStreamAudioDestinationNodeStreamConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamAudioDestinationNodeStreamConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamAudioDestinationNode_stream",
            argNames: ["that"],
          );

  @override
  Future<MediaStreamAudioSourceNode>
      webAudioApiNodeMediaStreamAudioSourceNodeNew(
          {required C context,
          required MediaStreamAudioSourceOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
            options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 201, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeMediaStreamAudioSourceNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeMediaStreamAudioSourceNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "MediaStreamAudioSourceNode_new",
        argNames: ["context", "options"],
      );

  @override
  MediaStream webAudioApiNodeMediaStreamAudioSourceOptionsGetMediaStream(
      {required MediaStreamAudioSourceOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 202)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeMediaStreamAudioSourceOptionsGetMediaStreamConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamAudioSourceOptionsGetMediaStreamConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamAudioSourceOptions_get_media_stream",
            argNames: ["that"],
          );

  @override
  void webAudioApiNodeMediaStreamAudioSourceOptionsSetMediaStream(
      {required MediaStreamAudioSourceOptions that,
      required MediaStream mediaStream}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
            mediaStream, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 203)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeMediaStreamAudioSourceOptionsSetMediaStreamConstMeta,
      argValues: [that, mediaStream],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamAudioSourceOptionsSetMediaStreamConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamAudioSourceOptions_set_media_stream",
            argNames: ["that", "mediaStream"],
          );

  @override
  Future<MediaStreamTrackAudioSourceNode>
      webAudioApiNodeMediaStreamTrackAudioSourceNodeNew(
          {required C context,
          required MediaStreamTrackAudioSourceOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
            options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 204, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeMediaStreamTrackAudioSourceNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamTrackAudioSourceNodeNewConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamTrackAudioSourceNode_new",
            argNames: ["context", "options"],
          );

  @override
  MediaStreamTrack
      webAudioApiNodeMediaStreamTrackAudioSourceOptionsGetMediaStreamTrack(
          {required MediaStreamTrackAudioSourceOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 205)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeMediaStreamTrackAudioSourceOptionsGetMediaStreamTrackConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamTrackAudioSourceOptionsGetMediaStreamTrackConstMeta =>
          const TaskConstMeta(
            debugName:
                "MediaStreamTrackAudioSourceOptions_get_media_stream_track",
            argNames: ["that"],
          );

  @override
  void webAudioApiNodeMediaStreamTrackAudioSourceOptionsSetMediaStreamTrack(
      {required MediaStreamTrackAudioSourceOptions that,
      required MediaStreamTrack mediaStreamTrack}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            mediaStreamTrack, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 206)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeMediaStreamTrackAudioSourceOptionsSetMediaStreamTrackConstMeta,
      argValues: [that, mediaStreamTrack],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeMediaStreamTrackAudioSourceOptionsSetMediaStreamTrackConstMeta =>
          const TaskConstMeta(
            debugName:
                "MediaStreamTrackAudioSourceOptions_set_media_stream_track",
            argNames: ["that", "mediaStreamTrack"],
          );

  @override
  Future<AudioParam> webAudioApiNodeOscillatorNodeDetune(
      {required OscillatorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 207, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeOscillatorNodeDetuneConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeOscillatorNodeDetuneConstMeta =>
      const TaskConstMeta(
        debugName: "OscillatorNode_detune",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodeOscillatorNodeFrequency(
      {required OscillatorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 208, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeOscillatorNodeFrequencyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeOscillatorNodeFrequencyConstMeta =>
      const TaskConstMeta(
        debugName: "OscillatorNode_frequency",
        argNames: ["that"],
      );

  @override
  Future<OscillatorNode> webAudioApiNodeOscillatorNodeNew(
      {required C context, required OscillatorOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_oscillator_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 209, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeOscillatorNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeOscillatorNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "OscillatorNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<void> webAudioApiNodeOscillatorNodeSetPeriodicWave(
      {required OscillatorNode that, required PeriodicWave periodicWave}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
            periodicWave, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 210, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeOscillatorNodeSetPeriodicWaveConstMeta,
      argValues: [that, periodicWave],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeOscillatorNodeSetPeriodicWaveConstMeta =>
      const TaskConstMeta(
        debugName: "OscillatorNode_set_periodic_wave",
        argNames: ["that", "periodicWave"],
      );

  @override
  Future<void> webAudioApiNodeOscillatorNodeSetType(
      {required OscillatorNode that, required OscillatorType type}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
            that, serializer);
        sse_encode_oscillator_type(type, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 211, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeOscillatorNodeSetTypeConstMeta,
      argValues: [that, type],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeOscillatorNodeSetTypeConstMeta =>
      const TaskConstMeta(
        debugName: "OscillatorNode_set_type",
        argNames: ["that", "type"],
      );

  @override
  Future<OscillatorType> webAudioApiNodeOscillatorNodeType(
      {required OscillatorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 212, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_oscillator_type,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeOscillatorNodeTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeOscillatorNodeTypeConstMeta =>
      const TaskConstMeta(
        debugName: "OscillatorNode_type_",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodePannerNodeConeInnerAngle(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 213, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeConeInnerAngleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeConeInnerAngleConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_cone_inner_angle",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodePannerNodeConeOuterAngle(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 214, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeConeOuterAngleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeConeOuterAngleConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_cone_outer_angle",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodePannerNodeConeOuterGain(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 215, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeConeOuterGainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeConeOuterGainConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_cone_outer_gain",
        argNames: ["that"],
      );

  @override
  Future<DistanceModelType> webAudioApiNodePannerNodeDistanceModel(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 216, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_distance_model_type,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeDistanceModelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeDistanceModelConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_distance_model",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodePannerNodeMaxDistance(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 217, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeMaxDistanceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeMaxDistanceConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_max_distance",
        argNames: ["that"],
      );

  @override
  Future<PannerNode> webAudioApiNodePannerNodeNew(
      {required C context, required PannerOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_panner_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 218, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodePannerNodeOrientationX(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 219, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeOrientationXConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeOrientationXConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_orientation_x",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodePannerNodeOrientationY(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 220, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeOrientationYConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeOrientationYConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_orientation_y",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodePannerNodeOrientationZ(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 221, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeOrientationZConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeOrientationZConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_orientation_z",
        argNames: ["that"],
      );

  @override
  Future<PanningModelType> webAudioApiNodePannerNodePanningModel(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 222, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_panning_model_type,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodePanningModelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodePanningModelConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_panning_model",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodePannerNodePositionX(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 223, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodePositionXConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodePositionXConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_position_x",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodePannerNodePositionY(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 224, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodePositionYConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodePositionYConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_position_y",
        argNames: ["that"],
      );

  @override
  Future<AudioParam> webAudioApiNodePannerNodePositionZ(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 225, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodePositionZConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodePositionZConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_position_z",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodePannerNodeRefDistance(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 226, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeRefDistanceConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeRefDistanceConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_ref_distance",
        argNames: ["that"],
      );

  @override
  Future<double> webAudioApiNodePannerNodeRolloffFactor(
      {required PannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 227, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeRolloffFactorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeRolloffFactorConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_rolloff_factor",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetConeInnerAngle(
      {required PannerNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 228, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetConeInnerAngleConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetConeInnerAngleConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_cone_inner_angle",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetConeOuterAngle(
      {required PannerNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 229, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetConeOuterAngleConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetConeOuterAngleConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_cone_outer_angle",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetConeOuterGain(
      {required PannerNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 230, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetConeOuterGainConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetConeOuterGainConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_cone_outer_gain",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetDistanceModel(
      {required PannerNode that, required DistanceModelType value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_distance_model_type(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 231, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetDistanceModelConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetDistanceModelConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_distance_model",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetMaxDistance(
      {required PannerNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 232, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetMaxDistanceConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetMaxDistanceConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_max_distance",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetOrientation(
      {required PannerNode that,
      required double x,
      required double y,
      required double z}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_32(x, serializer);
        sse_encode_f_32(y, serializer);
        sse_encode_f_32(z, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 233, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetOrientationConstMeta,
      argValues: [that, x, y, z],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetOrientationConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_orientation",
        argNames: ["that", "x", "y", "z"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetPanningModel(
      {required PannerNode that, required PanningModelType value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_panning_model_type(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 234, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetPanningModelConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetPanningModelConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_panning_model",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetPosition(
      {required PannerNode that,
      required double x,
      required double y,
      required double z}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_32(x, serializer);
        sse_encode_f_32(y, serializer);
        sse_encode_f_32(z, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 235, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetPositionConstMeta,
      argValues: [that, x, y, z],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetPositionConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_position",
        argNames: ["that", "x", "y", "z"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetRefDistance(
      {required PannerNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 236, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetRefDistanceConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetRefDistanceConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_ref_distance",
        argNames: ["that", "value"],
      );

  @override
  Future<void> webAudioApiNodePannerNodeSetRolloffFactor(
      {required PannerNode that, required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
            that, serializer);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 237, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodePannerNodeSetRolloffFactorConstMeta,
      argValues: [that, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodePannerNodeSetRolloffFactorConstMeta =>
      const TaskConstMeta(
        debugName: "PannerNode_set_rolloff_factor",
        argNames: ["that", "value"],
      );

  @override
  Future<BigInt> webAudioApiNodeScriptProcessorNodeBufferSize(
      {required ScriptProcessorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 238, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeScriptProcessorNodeBufferSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeScriptProcessorNodeBufferSizeConstMeta =>
      const TaskConstMeta(
        debugName: "ScriptProcessorNode_buffer_size",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeScriptProcessorNodeClearOnaudioprocess(
      {required ScriptProcessorNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 239, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiNodeScriptProcessorNodeClearOnaudioprocessConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeScriptProcessorNodeClearOnaudioprocessConstMeta =>
          const TaskConstMeta(
            debugName: "ScriptProcessorNode_clear_onaudioprocess",
            argNames: ["that"],
          );

  @override
  Future<ScriptProcessorNode> webAudioApiNodeScriptProcessorNodeNew(
      {required C context, required ScriptProcessorOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_script_processor_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 240, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeScriptProcessorNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeScriptProcessorNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "ScriptProcessorNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<void> webAudioApiNodeScriptProcessorNodeSetOnaudioprocess(
      {required ScriptProcessorNode that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 241, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeScriptProcessorNodeSetOnaudioprocessConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiNodeScriptProcessorNodeSetOnaudioprocessConstMeta =>
          const TaskConstMeta(
            debugName: "ScriptProcessorNode_set_onaudioprocess",
            argNames: ["that", "callback"],
          );

  @override
  Future<StereoPannerNode> webAudioApiNodeStereoPannerNodeNew(
      {required C context, required StereoPannerOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_stereo_panner_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 242, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeStereoPannerNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeStereoPannerNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "StereoPannerNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<AudioParam> webAudioApiNodeStereoPannerNodePan(
      {required StereoPannerNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 243, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeStereoPannerNodePanConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeStereoPannerNodePanConstMeta =>
      const TaskConstMeta(
        debugName: "StereoPannerNode_pan",
        argNames: ["that"],
      );

  @override
  Future<F32?> webAudioApiNodeWaveShaperNodeCurve(
      {required WaveShaperNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 244, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeWaveShaperNodeCurveConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeWaveShaperNodeCurveConstMeta =>
      const TaskConstMeta(
        debugName: "WaveShaperNode_curve",
        argNames: ["that"],
      );

  @override
  Future<WaveShaperNode> webAudioApiNodeWaveShaperNodeNew(
      {required C context, required WaveShaperOptions options}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            context, serializer);
        sse_encode_box_autoadd_wave_shaper_options(options, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 245, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeWaveShaperNodeNewConstMeta,
      argValues: [context, options],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeWaveShaperNodeNewConstMeta =>
      const TaskConstMeta(
        debugName: "WaveShaperNode_new",
        argNames: ["context", "options"],
      );

  @override
  Future<OverSampleType> webAudioApiNodeWaveShaperNodeOversample(
      {required WaveShaperNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 246, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_over_sample_type,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeWaveShaperNodeOversampleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeWaveShaperNodeOversampleConstMeta =>
      const TaskConstMeta(
        debugName: "WaveShaperNode_oversample",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiNodeWaveShaperNodeSetCurve(
      {required WaveShaperNode that, required List<double> curve}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
            that, serializer);
        sse_encode_list_prim_f_32_loose(curve, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 247, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeWaveShaperNodeSetCurveConstMeta,
      argValues: [that, curve],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeWaveShaperNodeSetCurveConstMeta =>
      const TaskConstMeta(
        debugName: "WaveShaperNode_set_curve",
        argNames: ["that", "curve"],
      );

  @override
  Future<void> webAudioApiNodeWaveShaperNodeSetOversample(
      {required WaveShaperNode that, required OverSampleType oversample}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
            that, serializer);
        sse_encode_over_sample_type(oversample, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 248, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiNodeWaveShaperNodeSetOversampleConstMeta,
      argValues: [that, oversample],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiNodeWaveShaperNodeSetOversampleConstMeta =>
      const TaskConstMeta(
        debugName: "WaveShaperNode_set_oversample",
        argNames: ["that", "oversample"],
      );

  @override
  AudioNodeOptions webAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptions(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 249)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio_node_options,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_audio_node_options",
            argNames: ["that"],
          );

  @override
  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputs(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 250)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_number_of_inputs",
            argNames: ["that"],
          );

  @override
  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputs(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 251)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_number_of_outputs",
            argNames: ["that"],
          );

  @override
  Uint64List webAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCount(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 252)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_usize_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCountConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_output_channel_count",
            argNames: ["that"],
          );

  @override
  Map<String, double> webAudioApiWorkletAudioWorkletNodeOptionsGetParameterData(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 253)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_String_f_64,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetParameterDataConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetParameterDataConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_parameter_data",
            argNames: ["that"],
          );

  @override
  C webAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptions(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 254)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_processor_options",
            argNames: ["that"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptions(
      {required AudioWorkletNodeOptions that,
      required AudioNodeOptions audioNodeOptions}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_audio_node_options(audioNodeOptions, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 255)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptionsConstMeta,
      argValues: [that, audioNodeOptions],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_audio_node_options",
            argNames: ["that", "audioNodeOptions"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputs(
      {required AudioWorkletNodeOptions that, required BigInt numberOfInputs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_usize(numberOfInputs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 256)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputsConstMeta,
      argValues: [that, numberOfInputs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_number_of_inputs",
            argNames: ["that", "numberOfInputs"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputs(
      {required AudioWorkletNodeOptions that,
      required BigInt numberOfOutputs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_usize(numberOfOutputs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 257)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputsConstMeta,
      argValues: [that, numberOfOutputs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_number_of_outputs",
            argNames: ["that", "numberOfOutputs"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCount(
      {required AudioWorkletNodeOptions that,
      required Uint64List outputChannelCount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_list_prim_usize_strict(outputChannelCount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 258)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCountConstMeta,
      argValues: [that, outputChannelCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCountConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_output_channel_count",
            argNames: ["that", "outputChannelCount"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetParameterData(
      {required AudioWorkletNodeOptions that,
      required Map<String, double> parameterData}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_Map_String_f_64(parameterData, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 259)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetParameterDataConstMeta,
      argValues: [that, parameterData],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetParameterDataConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_parameter_data",
            argNames: ["that", "parameterData"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptions(
      {required AudioWorkletNodeOptions that, required C processorOptions}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            processorOptions, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 260)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptionsConstMeta,
      argValues: [that, processorOptions],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_processor_options",
            argNames: ["that", "processorOptions"],
          );

  @override
  Future<HashMapStringAudioParam> webAudioApiWorkletAudioWorkletNodeParameters(
      {required AudioWorkletNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 261, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiWorkletAudioWorkletNodeParametersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiWorkletAudioWorkletNodeParametersConstMeta =>
      const TaskConstMeta(
        debugName: "AudioWorkletNode_parameters",
        argNames: ["that"],
      );

  @override
  Future<MessagePort> webAudioApiWorkletAudioWorkletNodePort(
      {required AudioWorkletNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 262, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiWorkletAudioWorkletNodePortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiWorkletAudioWorkletNodePortConstMeta =>
      const TaskConstMeta(
        debugName: "AudioWorkletNode_port",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AnalyserNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AnalyserNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF32 => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF32 => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF64 => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF64 => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioBuffer => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioBuffer => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioBufferSourceNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioBufferSourceNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioContext => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioContext => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioContextRegistration => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioContextRegistration => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioDestinationNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioDestinationNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioParam => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioParam => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioRenderCapacity => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioRenderCapacity => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioRenderCapacityEvent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioRenderCapacityEvent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNodeOptions => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNodeOptions => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BiquadFilterNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BiquadFilterNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlobEvent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlobEvent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxAny => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxAny => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxAny => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxAny => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxError => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxError => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_C => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_C => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ChannelData => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ChannelData => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ChannelMergerNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ChannelMergerNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ChannelSplitterNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ChannelSplitterNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ConcreteBaseAudioContext => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ConcreteBaseAudioContext => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ConstantSourceNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ConstantSourceNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ConvolverNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ConvolverNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DelayNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DelayNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DynamicsCompressorNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DynamicsCompressorNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ErrorEvent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ErrorEvent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Event =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Event =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventDispatch => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventDispatch => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventHandler => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventHandler => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_EventLoop => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_EventLoop => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_F => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_F => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_GainNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_GainNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_HashMapStringAudioParam => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_HashMapStringAudioParam => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_IirFilterNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_IirFilterNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaDeviceInfo => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaDeviceInfo => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaElement => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaElement => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaElementAudioSourceNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaElementAudioSourceNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaElementAudioSourceOptions => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaElementAudioSourceOptions => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaRecorder => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaRecorder => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStream => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStream => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamAudioDestinationNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamAudioDestinationNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamAudioSourceNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamAudioSourceNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamAudioSourceOptions => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamAudioSourceOptions => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrack => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrack => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrackAudioSourceNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrackAudioSourceOptions =>
          wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceOptions =>
          wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MessagePort => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MessagePort => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OfflineAudioCompletionEvent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OfflineAudioCompletionEvent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OfflineAudioContext => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OfflineAudioContext => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ordering => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ordering => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OscillatorNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OscillatorNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PannerNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PannerNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PeriodicWave => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PeriodicWave => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ReceiverEventDispatch => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ReceiverEventDispatch => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ScriptProcessorNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ScriptProcessorNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Self =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Self =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_StereoPannerNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_StereoPannerNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_T => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_T => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_WaveShaperNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_WaveShaperNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_F32 => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_F32 => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Str => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Str => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_U8 => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_U8 => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8;

  @protected
  AnalyserNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnalyserNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF32
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF64
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF64.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBufferSourceNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioContext
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioDestinationNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioDestinationNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioParam
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacity
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacity.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacityEvent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BiquadFilterNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BiquadFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxAny
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxAny.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxAny
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxAny.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxError
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxError.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  C dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return C.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelData
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelData.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelMergerNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelMergerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelSplitterNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelSplitterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConcreteBaseAudioContext
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConcreteBaseAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConstantSourceNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConstantSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConvolverNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConvolverNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DelayNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DelayNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DynamicsCompressorNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DynamicsCompressorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ErrorEvent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ErrorEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Event
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Event.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventDispatch
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventDispatch.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventHandler
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventHandler.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventLoop
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventLoop.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GainNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GainNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  IirFilterNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IirFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaDeviceInfo
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaElementAudioSourceNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElementAudioSourceNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaElementAudioSourceOptions
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaRecorder
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaRecorder.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioDestinationNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioDestinationNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioSourceNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioSourceNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioSourceOptions
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamTrack
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrack.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamTrackAudioSourceNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackAudioSourceNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MessagePort
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MessagePort.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OfflineAudioCompletionEvent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  OfflineAudioContext
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ordering
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ordering.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OscillatorNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OscillatorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PannerNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PeriodicWave
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PeriodicWave.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ReceiverEventDispatch
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ReceiverEventDispatch.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ScriptProcessorNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ScriptProcessorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  StereoPannerNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StereoPannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  T dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return T.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WaveShaperNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WaveShaperNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AnalyserNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnalyserNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBuffer
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBuffer.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBufferSourceNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacityEvent
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BiquadFilterNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BiquadFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelData
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelData.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConvolverNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConvolverNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ErrorEvent
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ErrorEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Event
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Event.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaElement
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElement.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaElementAudioSourceOptions
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioSourceOptions
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  OfflineAudioCompletionEvent
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  OfflineAudioContext
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OscillatorNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OscillatorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PannerNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WaveShaperNode
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WaveShaperNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F32 dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  U8 dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AnalyserNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnalyserNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF32
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF64
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF64.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBuffer
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBuffer.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBufferSourceNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioContext
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioContextRegistration
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContextRegistration.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioDestinationNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioDestinationNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioParam
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacity
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacity.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacityEvent
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BiquadFilterNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BiquadFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  C dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return C.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelData
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelData.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConcreteBaseAudioContext
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConcreteBaseAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConstantSourceNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConstantSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConvolverNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConvolverNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DelayNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DelayNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DynamicsCompressorNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DynamicsCompressorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ErrorEvent
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ErrorEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Event
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Event.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventLoop
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventLoop.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GainNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GainNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  HashMapStringAudioParam
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  IirFilterNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IirFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaDeviceInfo
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaElementAudioSourceOptions
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaRecorder
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaRecorder.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStream
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStream.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioDestinationNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioDestinationNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioSourceOptions
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamTrack
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrack.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  OfflineAudioCompletionEvent
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  OfflineAudioContext
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OscillatorNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OscillatorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PannerNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ScriptProcessorNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ScriptProcessorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Self
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Self.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  StereoPannerNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StereoPannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WaveShaperNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WaveShaperNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F32 dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Str dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Str.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Map<String, double> dco_decode_Map_String_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_f_64(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AnalyserNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnalyserNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF32
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF64
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF64.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBuffer
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBuffer.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioBufferSourceNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioContext
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioContextRegistration
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContextRegistration.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioDestinationNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioDestinationNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioParam
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacity
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacity.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioRenderCapacityEvent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BiquadFilterNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BiquadFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxAny
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxAny.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxAny
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxAny.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxError
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxError.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  C dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return C.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelData
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelData.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelMergerNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelMergerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ChannelSplitterNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelSplitterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConcreteBaseAudioContext
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConcreteBaseAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConstantSourceNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConstantSourceNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ConvolverNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConvolverNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DelayNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DelayNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DynamicsCompressorNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DynamicsCompressorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ErrorEvent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ErrorEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Event
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Event.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventDispatch
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventDispatch.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventHandler
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventHandler.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  EventLoop
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return EventLoop.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GainNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GainNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  HashMapStringAudioParam
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  IirFilterNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return IirFilterNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaDeviceInfo
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaElement
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElement.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaElementAudioSourceNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElementAudioSourceNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaElementAudioSourceOptions
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaRecorder
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaRecorder.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStream
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStream.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioDestinationNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioDestinationNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioSourceNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioSourceNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamAudioSourceOptions
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamTrack
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrack.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamTrackAudioSourceNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackAudioSourceNode.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  MessagePort
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MessagePort.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OfflineAudioCompletionEvent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  OfflineAudioContext
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OfflineAudioContext.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ordering
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ordering.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OscillatorNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OscillatorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PannerNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PeriodicWave
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PeriodicWave.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ReceiverEventDispatch
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ReceiverEventDispatch.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ScriptProcessorNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ScriptProcessorNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Self
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Self.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  StereoPannerNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StereoPannerNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  T dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return T.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  WaveShaperNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WaveShaperNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F32 dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Str dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Str.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  U8 dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AnalyserOptions dco_decode_analyser_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AnalyserOptions(
      fftSize: dco_decode_usize(arr[0]),
      maxDecibels: dco_decode_f_64(arr[1]),
      minDecibels: dco_decode_f_64(arr[2]),
      smoothingTimeConstant: dco_decode_f_64(arr[3]),
      audioNodeOptions: dco_decode_audio_node_options(arr[4]),
    );
  }

  @protected
  AudioBuffer dco_decode_audio_buffer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AudioBuffer(
      channels:
          dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
              arr[0]),
      sampleRate: dco_decode_f_32(arr[1]),
    );
  }

  @protected
  AudioBufferOptions dco_decode_audio_buffer_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AudioBufferOptions(
      numberOfChannels: dco_decode_usize(arr[0]),
      length: dco_decode_usize(arr[1]),
      sampleRate: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  AudioBufferSourceOptions dco_decode_audio_buffer_source_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return AudioBufferSourceOptions(
      buffer: dco_decode_opt_box_autoadd_audio_buffer(arr[0]),
      detune: dco_decode_f_32(arr[1]),
      loop: dco_decode_bool(arr[2]),
      loopStart: dco_decode_f_64(arr[3]),
      loopEnd: dco_decode_f_64(arr[4]),
      playbackRate: dco_decode_f_32(arr[5]),
    );
  }

  @protected
  AudioContextLatencyCategory dco_decode_audio_context_latency_category(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AudioContextLatencyCategory_Balanced();
      case 1:
        return AudioContextLatencyCategory_Interactive();
      case 2:
        return AudioContextLatencyCategory_Playback();
      case 3:
        return AudioContextLatencyCategory_Custom(
          dco_decode_f_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AudioContextOptions dco_decode_audio_context_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AudioContextOptions(
      latencyHint: dco_decode_audio_context_latency_category(arr[0]),
      sampleRate: dco_decode_opt_box_autoadd_f_32(arr[1]),
      sinkId: dco_decode_String(arr[2]),
      renderSizeHint: dco_decode_audio_context_render_size_category(arr[3]),
    );
  }

  @protected
  AudioContextRenderSizeCategory dco_decode_audio_context_render_size_category(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContextRenderSizeCategory.values[raw as int];
  }

  @protected
  AudioContextState dco_decode_audio_context_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioContextState.values[raw as int];
  }

  @protected
  AudioNodeId dco_decode_audio_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return AudioNodeId(
      field0: dco_decode_u_64(arr[0]),
    );
  }

  @protected
  AudioNodeOptions dco_decode_audio_node_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AudioNodeOptions(
      channelCount: dco_decode_usize(arr[0]),
      channelCountMode: dco_decode_channel_count_mode(arr[1]),
      channelInterpretation: dco_decode_channel_interpretation(arr[2]),
    );
  }

  @protected
  AudioProcessingEvent dco_decode_audio_processing_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AudioProcessingEvent(
      inputBuffer: dco_decode_audio_buffer(arr[0]),
      outputBuffer: dco_decode_audio_buffer(arr[1]),
      playbackTime: dco_decode_f_64(arr[2]),
      registration:
          dco_decode_opt_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
              arr[3]),
    );
  }

  @protected
  AudioRenderCapacityOptions dco_decode_audio_render_capacity_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return AudioRenderCapacityOptions(
      updateInterval: dco_decode_f_64(arr[0]),
    );
  }

  @protected
  AutomationRate dco_decode_automation_rate(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AutomationRate.values[raw as int];
  }

  @protected
  BiquadFilterOptions dco_decode_biquad_filter_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return BiquadFilterOptions(
      q: dco_decode_f_32(arr[0]),
      detune: dco_decode_f_32(arr[1]),
      frequency: dco_decode_f_32(arr[2]),
      gain: dco_decode_f_32(arr[3]),
      type: dco_decode_biquad_filter_type(arr[4]),
      audioNodeOptions: dco_decode_audio_node_options(arr[5]),
    );
  }

  @protected
  BiquadFilterType dco_decode_biquad_filter_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BiquadFilterType.values[raw as int];
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  PeriodicWave
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
        raw);
  }

  @protected
  AudioBuffer
      dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
        raw);
  }

  @protected
  F32 dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
        raw);
  }

  @protected
  Str dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
        raw);
  }

  @protected
  AnalyserOptions dco_decode_box_autoadd_analyser_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_analyser_options(raw);
  }

  @protected
  AudioBuffer dco_decode_box_autoadd_audio_buffer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_buffer(raw);
  }

  @protected
  AudioBufferOptions dco_decode_box_autoadd_audio_buffer_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_buffer_options(raw);
  }

  @protected
  AudioBufferSourceOptions dco_decode_box_autoadd_audio_buffer_source_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_buffer_source_options(raw);
  }

  @protected
  AudioContextOptions dco_decode_box_autoadd_audio_context_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_context_options(raw);
  }

  @protected
  AudioNodeId dco_decode_box_autoadd_audio_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_node_id(raw);
  }

  @protected
  AudioNodeOptions dco_decode_box_autoadd_audio_node_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_node_options(raw);
  }

  @protected
  AudioProcessingEvent dco_decode_box_autoadd_audio_processing_event(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_processing_event(raw);
  }

  @protected
  AudioRenderCapacityOptions
      dco_decode_box_autoadd_audio_render_capacity_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_audio_render_capacity_options(raw);
  }

  @protected
  BiquadFilterOptions dco_decode_box_autoadd_biquad_filter_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_biquad_filter_options(raw);
  }

  @protected
  ChannelMergerOptions dco_decode_box_autoadd_channel_merger_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_merger_options(raw);
  }

  @protected
  ChannelSplitterOptions dco_decode_box_autoadd_channel_splitter_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_splitter_options(raw);
  }

  @protected
  ConstantSourceOptions dco_decode_box_autoadd_constant_source_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_constant_source_options(raw);
  }

  @protected
  ConvolverOptions dco_decode_box_autoadd_convolver_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_convolver_options(raw);
  }

  @protected
  DelayOptions dco_decode_box_autoadd_delay_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_delay_options(raw);
  }

  @protected
  DynamicsCompressorOptions dco_decode_box_autoadd_dynamics_compressor_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_dynamics_compressor_options(raw);
  }

  @protected
  EventType dco_decode_box_autoadd_event_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event_type(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GainOptions dco_decode_box_autoadd_gain_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gain_options(raw);
  }

  @protected
  IIRFilterOptions dco_decode_box_autoadd_iir_filter_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_iir_filter_options(raw);
  }

  @protected
  MediaStream dco_decode_box_autoadd_media_stream(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream(raw);
  }

  @protected
  MediaStreamConstraints dco_decode_box_autoadd_media_stream_constraints(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream_constraints(raw);
  }

  @protected
  MediaTrackConstraints dco_decode_box_autoadd_media_track_constraints(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_track_constraints(raw);
  }

  @protected
  OscillatorOptions dco_decode_box_autoadd_oscillator_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_oscillator_options(raw);
  }

  @protected
  PannerOptions dco_decode_box_autoadd_panner_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_panner_options(raw);
  }

  @protected
  PeriodicWaveOptions dco_decode_box_autoadd_periodic_wave_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_periodic_wave_options(raw);
  }

  @protected
  (
    ConcreteBaseAudioContext,
    AudioNodeId
  ) dco_decode_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as (ConcreteBaseAudioContext, AudioNodeId);
  }

  @protected
  ScriptProcessorOptions dco_decode_box_autoadd_script_processor_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_script_processor_options(raw);
  }

  @protected
  StereoPannerOptions dco_decode_box_autoadd_stereo_panner_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_stereo_panner_options(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  WaveShaperOptions dco_decode_box_autoadd_wave_shaper_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_wave_shaper_options(raw);
  }

  @protected
  ChannelCountMode dco_decode_channel_count_mode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelCountMode.values[raw as int];
  }

  @protected
  ChannelInterpretation dco_decode_channel_interpretation(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChannelInterpretation.values[raw as int];
  }

  @protected
  ChannelMergerOptions dco_decode_channel_merger_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ChannelMergerOptions(
      numberOfInputs: dco_decode_usize(arr[0]),
      audioNodeOptions: dco_decode_audio_node_options(arr[1]),
    );
  }

  @protected
  ChannelSplitterOptions dco_decode_channel_splitter_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ChannelSplitterOptions(
      numberOfOutputs: dco_decode_usize(arr[0]),
      audioNodeOptions: dco_decode_audio_node_options(arr[1]),
    );
  }

  @protected
  ConstantSourceOptions dco_decode_constant_source_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ConstantSourceOptions(
      offset: dco_decode_f_32(arr[0]),
    );
  }

  @protected
  ConvolverOptions dco_decode_convolver_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ConvolverOptions(
      buffer: dco_decode_opt_box_autoadd_audio_buffer(arr[0]),
      disableNormalization: dco_decode_bool(arr[1]),
      audioNodeOptions: dco_decode_audio_node_options(arr[2]),
    );
  }

  @protected
  DelayOptions dco_decode_delay_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return DelayOptions(
      maxDelayTime: dco_decode_f_64(arr[0]),
      delayTime: dco_decode_f_64(arr[1]),
      audioNodeOptions: dco_decode_audio_node_options(arr[2]),
    );
  }

  @protected
  DistanceModelType dco_decode_distance_model_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DistanceModelType.values[raw as int];
  }

  @protected
  DynamicsCompressorOptions dco_decode_dynamics_compressor_options(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DynamicsCompressorOptions(
      attack: dco_decode_f_32(arr[0]),
      knee: dco_decode_f_32(arr[1]),
      ratio: dco_decode_f_32(arr[2]),
      release: dco_decode_f_32(arr[3]),
      threshold: dco_decode_f_32(arr[4]),
      audioNodeOptions: dco_decode_audio_node_options(arr[5]),
    );
  }

  @protected
  EventType dco_decode_event_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EventType_Ended(
          dco_decode_box_autoadd_audio_node_id(raw[1]),
        );
      case 1:
        return EventType_SinkChange();
      case 2:
        return EventType_StateChange();
      case 3:
        return EventType_RenderCapacity();
      case 4:
        return EventType_ProcessorError(
          dco_decode_box_autoadd_audio_node_id(raw[1]),
        );
      case 5:
        return EventType_Diagnostics();
      case 6:
        return EventType_Message(
          dco_decode_box_autoadd_audio_node_id(raw[1]),
        );
      case 7:
        return EventType_Complete();
      case 8:
        return EventType_AudioProcessing(
          dco_decode_box_autoadd_audio_node_id(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  GainOptions dco_decode_gain_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GainOptions(
      gain: dco_decode_f_32(arr[0]),
      audioNodeOptions: dco_decode_audio_node_options(arr[1]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  IIRFilterOptions dco_decode_iir_filter_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return IIRFilterOptions(
      audioNodeOptions: dco_decode_audio_node_options(arr[0]),
      feedforward: dco_decode_list_prim_f_64_strict(arr[1]),
      feedback: dco_decode_list_prim_f_64_strict(arr[2]),
    );
  }

  @protected
  List<ChannelData>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData)
        .toList();
  }

  @protected
  List<MediaDeviceInfo>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo)
        .toList();
  }

  @protected
  List<MediaStreamTrack>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack)
        .toList();
  }

  @protected
  List<Float32List> dco_decode_list_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_list_prim_f_32_strict)
        .toList();
  }

  @protected
  List<double> dco_decode_list_prim_f_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<double>;
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  Float64List dco_decode_list_prim_f_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float64List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(String, double)> dco_decode_list_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_f_64).toList();
  }

  @protected
  MediaDeviceInfoKind dco_decode_media_device_info_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfoKind.values[raw as int];
  }

  @protected
  MediaStream dco_decode_media_stream(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MediaStream(
      tracks:
          dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
              arr[0]),
    );
  }

  @protected
  MediaStreamConstraints dco_decode_media_stream_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MediaStreamConstraints_Audio();
      case 1:
        return MediaStreamConstraints_AudioWithConstraints(
          dco_decode_box_autoadd_media_track_constraints(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  MediaStreamTrackState dco_decode_media_stream_track_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackState.values[raw as int];
  }

  @protected
  MediaTrackConstraints dco_decode_media_track_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return MediaTrackConstraints(
      sampleRate: dco_decode_opt_box_autoadd_f_32(arr[0]),
      latency: dco_decode_opt_box_autoadd_f_64(arr[1]),
      channelCount: dco_decode_opt_box_autoadd_u_32(arr[2]),
      deviceId: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  PeriodicWave?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
            raw);
  }

  @protected
  AudioBuffer?
      dco_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
            raw);
  }

  @protected
  F32?
      dco_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
            raw);
  }

  @protected
  Str?
      dco_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
            raw);
  }

  @protected
  AudioBuffer? dco_decode_opt_box_autoadd_audio_buffer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_audio_buffer(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  (
    ConcreteBaseAudioContext,
    AudioNodeId
  )? dco_decode_opt_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
            raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  Float32List? dco_decode_opt_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_f_32_strict(raw);
  }

  @protected
  OscillatorOptions dco_decode_oscillator_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return OscillatorOptions(
      type: dco_decode_oscillator_type(arr[0]),
      frequency: dco_decode_f_32(arr[1]),
      detune: dco_decode_f_32(arr[2]),
      periodicWave:
          dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
              arr[3]),
      audioNodeOptions: dco_decode_audio_node_options(arr[4]),
    );
  }

  @protected
  OscillatorType dco_decode_oscillator_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OscillatorType.values[raw as int];
  }

  @protected
  OverSampleType dco_decode_over_sample_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OverSampleType.values[raw as int];
  }

  @protected
  PannerOptions dco_decode_panner_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return PannerOptions(
      panningModel: dco_decode_panning_model_type(arr[0]),
      distanceModel: dco_decode_distance_model_type(arr[1]),
      positionX: dco_decode_f_32(arr[2]),
      positionY: dco_decode_f_32(arr[3]),
      positionZ: dco_decode_f_32(arr[4]),
      orientationX: dco_decode_f_32(arr[5]),
      orientationY: dco_decode_f_32(arr[6]),
      orientationZ: dco_decode_f_32(arr[7]),
      refDistance: dco_decode_f_64(arr[8]),
      maxDistance: dco_decode_f_64(arr[9]),
      rolloffFactor: dco_decode_f_64(arr[10]),
      coneInnerAngle: dco_decode_f_64(arr[11]),
      coneOuterAngle: dco_decode_f_64(arr[12]),
      coneOuterGain: dco_decode_f_64(arr[13]),
      audioNodeOptions: dco_decode_audio_node_options(arr[14]),
    );
  }

  @protected
  PanningModelType dco_decode_panning_model_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PanningModelType.values[raw as int];
  }

  @protected
  PeriodicWaveOptions dco_decode_periodic_wave_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PeriodicWaveOptions(
      real: dco_decode_opt_list_prim_f_32_strict(arr[0]),
      imag: dco_decode_opt_list_prim_f_32_strict(arr[1]),
      disableNormalization: dco_decode_bool(arr[2]),
    );
  }

  @protected
  (
    ConcreteBaseAudioContext,
    AudioNodeId
  ) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          arr[0]),
      dco_decode_audio_node_id(arr[1]),
    );
  }

  @protected
  (String, double) dco_decode_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_f_64(arr[1]),
    );
  }

  @protected
  ScriptProcessorOptions dco_decode_script_processor_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ScriptProcessorOptions(
      bufferSize: dco_decode_usize(arr[0]),
      numberOfInputChannels: dco_decode_usize(arr[1]),
      numberOfOutputChannels: dco_decode_usize(arr[2]),
    );
  }

  @protected
  StereoPannerOptions dco_decode_stereo_panner_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return StereoPannerOptions(
      pan: dco_decode_f_32(arr[0]),
      audioNodeOptions: dco_decode_audio_node_options(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WaveShaperOptions dco_decode_wave_shaper_options(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WaveShaperOptions(
      curve: dco_decode_opt_list_prim_f_32_strict(arr[0]),
      oversample: dco_decode_over_sample_type(arr[1]),
      audioNodeOptions: dco_decode_audio_node_options(arr[2]),
    );
  }

  @protected
  AnalyserNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AnalyserNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF32
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF64
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF64.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBufferSourceNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioContext
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioDestinationNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioDestinationNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioParam
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacity
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacity.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacityEvent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BiquadFilterNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BiquadFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxAny
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxAny.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxAny
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxAny.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxError
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxError.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  C sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return C.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelData
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelData.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelMergerNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelMergerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelSplitterNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelSplitterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConcreteBaseAudioContext
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConcreteBaseAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConstantSourceNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConstantSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConvolverNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConvolverNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DelayNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DelayNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DynamicsCompressorNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DynamicsCompressorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ErrorEvent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ErrorEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Event
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Event.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventDispatch
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventDispatch.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventHandler
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventHandler.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventLoop
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventLoop.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GainNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GainNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  IirFilterNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return IirFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaDeviceInfo
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElementAudioSourceNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElementAudioSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElementAudioSourceOptions
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaRecorder
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaRecorder.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioDestinationNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioDestinationNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioSourceNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioSourceOptions
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrack
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrack.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrackAudioSourceNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrackAudioSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MessagePort
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MessagePort.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioCompletionEvent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioContext
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ordering
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ordering.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OscillatorNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OscillatorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PannerNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PeriodicWave
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PeriodicWave.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ReceiverEventDispatch
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ReceiverEventDispatch.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ScriptProcessorNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ScriptProcessorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  StereoPannerNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StereoPannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  T sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return T.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WaveShaperNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WaveShaperNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AnalyserNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AnalyserNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBuffer
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBuffer.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBufferSourceNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacityEvent
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BiquadFilterNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BiquadFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelData
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelData.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConvolverNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConvolverNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ErrorEvent
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ErrorEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Event
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Event.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElement
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElement.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElementAudioSourceOptions
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioSourceOptions
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioCompletionEvent
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioContext
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OscillatorNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OscillatorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PannerNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WaveShaperNode
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WaveShaperNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F32 sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  U8 sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return U8.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AnalyserNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AnalyserNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF32
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF64
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF64.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBuffer
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBuffer.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBufferSourceNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioContext
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioContextRegistration
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioContextRegistration.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioDestinationNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioDestinationNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioParam
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacity
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacity.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacityEvent
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BiquadFilterNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BiquadFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  C sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return C.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelData
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelData.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConcreteBaseAudioContext
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConcreteBaseAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConstantSourceNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConstantSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConvolverNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConvolverNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DelayNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DelayNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DynamicsCompressorNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DynamicsCompressorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ErrorEvent
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ErrorEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Event
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Event.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventLoop
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventLoop.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GainNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GainNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HashMapStringAudioParam
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  IirFilterNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return IirFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaDeviceInfo
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElementAudioSourceOptions
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaRecorder
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaRecorder.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStream
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStream.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioDestinationNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioDestinationNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioSourceOptions
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrack
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrack.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioCompletionEvent
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioContext
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OscillatorNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OscillatorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PannerNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ScriptProcessorNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ScriptProcessorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Self
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Self.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  StereoPannerNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StereoPannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WaveShaperNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WaveShaperNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F32 sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Str sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Str.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Map<String, double> sse_decode_Map_String_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_f_64(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AnalyserNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AnalyserNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF32
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF64
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF64.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBuffer
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBuffer.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioBufferSourceNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioBufferSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioContext
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioContextRegistration
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioContextRegistration.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioDestinationNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioDestinationNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioParam
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacity
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacity.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioRenderCapacityEvent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioRenderCapacityEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BiquadFilterNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BiquadFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxAny
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxAny.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxAny
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxAny.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxError
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxError.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  C sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return C.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelData
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelData.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelMergerNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelMergerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ChannelSplitterNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ChannelSplitterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConcreteBaseAudioContext
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConcreteBaseAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConstantSourceNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConstantSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ConvolverNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ConvolverNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DelayNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DelayNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DynamicsCompressorNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DynamicsCompressorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ErrorEvent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ErrorEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Event
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Event.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventDispatch
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventDispatch.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventHandler
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventHandler.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  EventLoop
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return EventLoop.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GainNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GainNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HashMapStringAudioParam
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  IirFilterNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return IirFilterNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaDeviceInfo
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElement
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElement.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElementAudioSourceNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElementAudioSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaElementAudioSourceOptions
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaElementAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaRecorder
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaRecorder.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStream
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStream.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioDestinationNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioDestinationNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioSourceNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamAudioSourceOptions
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrack
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrack.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrackAudioSourceNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrackAudioSourceNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrackAudioSourceOptions
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrackAudioSourceOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MessagePort
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MessagePort.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioCompletionEvent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioCompletionEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OfflineAudioContext
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OfflineAudioContext.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ordering
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ordering.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OscillatorNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OscillatorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PannerNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PeriodicWave
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PeriodicWave.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ReceiverEventDispatch
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ReceiverEventDispatch.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ScriptProcessorNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ScriptProcessorNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Self
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Self.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  StereoPannerNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StereoPannerNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  T sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return T.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  WaveShaperNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WaveShaperNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F32 sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Str sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Str.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  U8 sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return U8.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AnalyserOptions sse_decode_analyser_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fftSize = sse_decode_usize(deserializer);
    var var_maxDecibels = sse_decode_f_64(deserializer);
    var var_minDecibels = sse_decode_f_64(deserializer);
    var var_smoothingTimeConstant = sse_decode_f_64(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return AnalyserOptions(
        fftSize: var_fftSize,
        maxDecibels: var_maxDecibels,
        minDecibels: var_minDecibels,
        smoothingTimeConstant: var_smoothingTimeConstant,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  AudioBuffer sse_decode_audio_buffer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channels =
        sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
            deserializer);
    var var_sampleRate = sse_decode_f_32(deserializer);
    return AudioBuffer(channels: var_channels, sampleRate: var_sampleRate);
  }

  @protected
  AudioBufferOptions sse_decode_audio_buffer_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_numberOfChannels = sse_decode_usize(deserializer);
    var var_length = sse_decode_usize(deserializer);
    var var_sampleRate = sse_decode_f_32(deserializer);
    return AudioBufferOptions(
        numberOfChannels: var_numberOfChannels,
        length: var_length,
        sampleRate: var_sampleRate);
  }

  @protected
  AudioBufferSourceOptions sse_decode_audio_buffer_source_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_buffer = sse_decode_opt_box_autoadd_audio_buffer(deserializer);
    var var_detune = sse_decode_f_32(deserializer);
    var var_loop = sse_decode_bool(deserializer);
    var var_loopStart = sse_decode_f_64(deserializer);
    var var_loopEnd = sse_decode_f_64(deserializer);
    var var_playbackRate = sse_decode_f_32(deserializer);
    return AudioBufferSourceOptions(
        buffer: var_buffer,
        detune: var_detune,
        loop: var_loop,
        loopStart: var_loopStart,
        loopEnd: var_loopEnd,
        playbackRate: var_playbackRate);
  }

  @protected
  AudioContextLatencyCategory sse_decode_audio_context_latency_category(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return AudioContextLatencyCategory_Balanced();
      case 1:
        return AudioContextLatencyCategory_Interactive();
      case 2:
        return AudioContextLatencyCategory_Playback();
      case 3:
        var var_field0 = sse_decode_f_64(deserializer);
        return AudioContextLatencyCategory_Custom(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AudioContextOptions sse_decode_audio_context_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_latencyHint =
        sse_decode_audio_context_latency_category(deserializer);
    var var_sampleRate = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_sinkId = sse_decode_String(deserializer);
    var var_renderSizeHint =
        sse_decode_audio_context_render_size_category(deserializer);
    return AudioContextOptions(
        latencyHint: var_latencyHint,
        sampleRate: var_sampleRate,
        sinkId: var_sinkId,
        renderSizeHint: var_renderSizeHint);
  }

  @protected
  AudioContextRenderSizeCategory sse_decode_audio_context_render_size_category(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AudioContextRenderSizeCategory.values[inner];
  }

  @protected
  AudioContextState sse_decode_audio_context_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AudioContextState.values[inner];
  }

  @protected
  AudioNodeId sse_decode_audio_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_64(deserializer);
    return AudioNodeId(field0: var_field0);
  }

  @protected
  AudioNodeOptions sse_decode_audio_node_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channelCount = sse_decode_usize(deserializer);
    var var_channelCountMode = sse_decode_channel_count_mode(deserializer);
    var var_channelInterpretation =
        sse_decode_channel_interpretation(deserializer);
    return AudioNodeOptions(
        channelCount: var_channelCount,
        channelCountMode: var_channelCountMode,
        channelInterpretation: var_channelInterpretation);
  }

  @protected
  AudioProcessingEvent sse_decode_audio_processing_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_inputBuffer = sse_decode_audio_buffer(deserializer);
    var var_outputBuffer = sse_decode_audio_buffer(deserializer);
    var var_playbackTime = sse_decode_f_64(deserializer);
    var var_registration =
        sse_decode_opt_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
            deserializer);
    return AudioProcessingEvent(
        inputBuffer: var_inputBuffer,
        outputBuffer: var_outputBuffer,
        playbackTime: var_playbackTime,
        registration: var_registration);
  }

  @protected
  AudioRenderCapacityOptions sse_decode_audio_render_capacity_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_updateInterval = sse_decode_f_64(deserializer);
    return AudioRenderCapacityOptions(updateInterval: var_updateInterval);
  }

  @protected
  AutomationRate sse_decode_automation_rate(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return AutomationRate.values[inner];
  }

  @protected
  BiquadFilterOptions sse_decode_biquad_filter_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_q = sse_decode_f_32(deserializer);
    var var_detune = sse_decode_f_32(deserializer);
    var var_frequency = sse_decode_f_32(deserializer);
    var var_gain = sse_decode_f_32(deserializer);
    var var_type = sse_decode_biquad_filter_type(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return BiquadFilterOptions(
        q: var_q,
        detune: var_detune,
        frequency: var_frequency,
        gain: var_gain,
        type: var_type,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  BiquadFilterType sse_decode_biquad_filter_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BiquadFilterType.values[inner];
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  PeriodicWave
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
        deserializer));
  }

  @protected
  AudioBuffer
      sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
        deserializer));
  }

  @protected
  F32 sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
        deserializer));
  }

  @protected
  Str sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
        deserializer));
  }

  @protected
  AnalyserOptions sse_decode_box_autoadd_analyser_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_analyser_options(deserializer));
  }

  @protected
  AudioBuffer sse_decode_box_autoadd_audio_buffer(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_buffer(deserializer));
  }

  @protected
  AudioBufferOptions sse_decode_box_autoadd_audio_buffer_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_buffer_options(deserializer));
  }

  @protected
  AudioBufferSourceOptions sse_decode_box_autoadd_audio_buffer_source_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_buffer_source_options(deserializer));
  }

  @protected
  AudioContextOptions sse_decode_box_autoadd_audio_context_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_context_options(deserializer));
  }

  @protected
  AudioNodeId sse_decode_box_autoadd_audio_node_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_node_id(deserializer));
  }

  @protected
  AudioNodeOptions sse_decode_box_autoadd_audio_node_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_node_options(deserializer));
  }

  @protected
  AudioProcessingEvent sse_decode_box_autoadd_audio_processing_event(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_processing_event(deserializer));
  }

  @protected
  AudioRenderCapacityOptions
      sse_decode_box_autoadd_audio_render_capacity_options(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_audio_render_capacity_options(deserializer));
  }

  @protected
  BiquadFilterOptions sse_decode_box_autoadd_biquad_filter_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_biquad_filter_options(deserializer));
  }

  @protected
  ChannelMergerOptions sse_decode_box_autoadd_channel_merger_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_merger_options(deserializer));
  }

  @protected
  ChannelSplitterOptions sse_decode_box_autoadd_channel_splitter_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_splitter_options(deserializer));
  }

  @protected
  ConstantSourceOptions sse_decode_box_autoadd_constant_source_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_constant_source_options(deserializer));
  }

  @protected
  ConvolverOptions sse_decode_box_autoadd_convolver_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_convolver_options(deserializer));
  }

  @protected
  DelayOptions sse_decode_box_autoadd_delay_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_delay_options(deserializer));
  }

  @protected
  DynamicsCompressorOptions sse_decode_box_autoadd_dynamics_compressor_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_dynamics_compressor_options(deserializer));
  }

  @protected
  EventType sse_decode_box_autoadd_event_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event_type(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  GainOptions sse_decode_box_autoadd_gain_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gain_options(deserializer));
  }

  @protected
  IIRFilterOptions sse_decode_box_autoadd_iir_filter_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_iir_filter_options(deserializer));
  }

  @protected
  MediaStream sse_decode_box_autoadd_media_stream(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream(deserializer));
  }

  @protected
  MediaStreamConstraints sse_decode_box_autoadd_media_stream_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream_constraints(deserializer));
  }

  @protected
  MediaTrackConstraints sse_decode_box_autoadd_media_track_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_track_constraints(deserializer));
  }

  @protected
  OscillatorOptions sse_decode_box_autoadd_oscillator_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_oscillator_options(deserializer));
  }

  @protected
  PannerOptions sse_decode_box_autoadd_panner_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_panner_options(deserializer));
  }

  @protected
  PeriodicWaveOptions sse_decode_box_autoadd_periodic_wave_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_periodic_wave_options(deserializer));
  }

  @protected
  (
    ConcreteBaseAudioContext,
    AudioNodeId
  ) sse_decode_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
        deserializer));
  }

  @protected
  ScriptProcessorOptions sse_decode_box_autoadd_script_processor_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_script_processor_options(deserializer));
  }

  @protected
  StereoPannerOptions sse_decode_box_autoadd_stereo_panner_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_stereo_panner_options(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  WaveShaperOptions sse_decode_box_autoadd_wave_shaper_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_wave_shaper_options(deserializer));
  }

  @protected
  ChannelCountMode sse_decode_channel_count_mode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChannelCountMode.values[inner];
  }

  @protected
  ChannelInterpretation sse_decode_channel_interpretation(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChannelInterpretation.values[inner];
  }

  @protected
  ChannelMergerOptions sse_decode_channel_merger_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_numberOfInputs = sse_decode_usize(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return ChannelMergerOptions(
        numberOfInputs: var_numberOfInputs,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  ChannelSplitterOptions sse_decode_channel_splitter_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_numberOfOutputs = sse_decode_usize(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return ChannelSplitterOptions(
        numberOfOutputs: var_numberOfOutputs,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  ConstantSourceOptions sse_decode_constant_source_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_offset = sse_decode_f_32(deserializer);
    return ConstantSourceOptions(offset: var_offset);
  }

  @protected
  ConvolverOptions sse_decode_convolver_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_buffer = sse_decode_opt_box_autoadd_audio_buffer(deserializer);
    var var_disableNormalization = sse_decode_bool(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return ConvolverOptions(
        buffer: var_buffer,
        disableNormalization: var_disableNormalization,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  DelayOptions sse_decode_delay_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_maxDelayTime = sse_decode_f_64(deserializer);
    var var_delayTime = sse_decode_f_64(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return DelayOptions(
        maxDelayTime: var_maxDelayTime,
        delayTime: var_delayTime,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  DistanceModelType sse_decode_distance_model_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return DistanceModelType.values[inner];
  }

  @protected
  DynamicsCompressorOptions sse_decode_dynamics_compressor_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_attack = sse_decode_f_32(deserializer);
    var var_knee = sse_decode_f_32(deserializer);
    var var_ratio = sse_decode_f_32(deserializer);
    var var_release = sse_decode_f_32(deserializer);
    var var_threshold = sse_decode_f_32(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return DynamicsCompressorOptions(
        attack: var_attack,
        knee: var_knee,
        ratio: var_ratio,
        release: var_release,
        threshold: var_threshold,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  EventType sse_decode_event_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_audio_node_id(deserializer);
        return EventType_Ended(var_field0);
      case 1:
        return EventType_SinkChange();
      case 2:
        return EventType_StateChange();
      case 3:
        return EventType_RenderCapacity();
      case 4:
        var var_field0 = sse_decode_box_autoadd_audio_node_id(deserializer);
        return EventType_ProcessorError(var_field0);
      case 5:
        return EventType_Diagnostics();
      case 6:
        var var_field0 = sse_decode_box_autoadd_audio_node_id(deserializer);
        return EventType_Message(var_field0);
      case 7:
        return EventType_Complete();
      case 8:
        var var_field0 = sse_decode_box_autoadd_audio_node_id(deserializer);
        return EventType_AudioProcessing(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  GainOptions sse_decode_gain_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gain = sse_decode_f_32(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return GainOptions(gain: var_gain, audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  IIRFilterOptions sse_decode_iir_filter_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    var var_feedforward = sse_decode_list_prim_f_64_strict(deserializer);
    var var_feedback = sse_decode_list_prim_f_64_strict(deserializer);
    return IIRFilterOptions(
        audioNodeOptions: var_audioNodeOptions,
        feedforward: var_feedforward,
        feedback: var_feedback);
  }

  @protected
  List<ChannelData>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ChannelData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaDeviceInfo>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaDeviceInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaStreamTrack>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaStreamTrack>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<Float32List> sse_decode_list_list_prim_f_32_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Float32List>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_prim_f_32_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<double> sse_decode_list_prim_f_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Float64List sse_decode_list_prim_f_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat64List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(String, double)> sse_decode_list_record_string_f_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, double)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_f_64(deserializer));
    }
    return ans_;
  }

  @protected
  MediaDeviceInfoKind sse_decode_media_device_info_kind(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaDeviceInfoKind.values[inner];
  }

  @protected
  MediaStream sse_decode_media_stream(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tracks =
        sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            deserializer);
    return MediaStream(tracks: var_tracks);
  }

  @protected
  MediaStreamConstraints sse_decode_media_stream_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return MediaStreamConstraints_Audio();
      case 1:
        var var_field0 =
            sse_decode_box_autoadd_media_track_constraints(deserializer);
        return MediaStreamConstraints_AudioWithConstraints(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  MediaStreamTrackState sse_decode_media_stream_track_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaStreamTrackState.values[inner];
  }

  @protected
  MediaTrackConstraints sse_decode_media_track_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sampleRate = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_latency = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_channelCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_deviceId = sse_decode_opt_String(deserializer);
    return MediaTrackConstraints(
        sampleRate: var_sampleRate,
        latency: var_latency,
        channelCount: var_channelCount,
        deviceId: var_deviceId);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PeriodicWave?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  AudioBuffer?
      sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  F32?
      sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Str?
      sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  AudioBuffer? sse_decode_opt_box_autoadd_audio_buffer(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_audio_buffer(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (
    ConcreteBaseAudioContext,
    AudioNodeId
  )? sse_decode_opt_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Float32List? sse_decode_opt_list_prim_f_32_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_f_32_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OscillatorOptions sse_decode_oscillator_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_type = sse_decode_oscillator_type(deserializer);
    var var_frequency = sse_decode_f_32(deserializer);
    var var_detune = sse_decode_f_32(deserializer);
    var var_periodicWave =
        sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
            deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return OscillatorOptions(
        type: var_type,
        frequency: var_frequency,
        detune: var_detune,
        periodicWave: var_periodicWave,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  OscillatorType sse_decode_oscillator_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return OscillatorType.values[inner];
  }

  @protected
  OverSampleType sse_decode_over_sample_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return OverSampleType.values[inner];
  }

  @protected
  PannerOptions sse_decode_panner_options(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_panningModel = sse_decode_panning_model_type(deserializer);
    var var_distanceModel = sse_decode_distance_model_type(deserializer);
    var var_positionX = sse_decode_f_32(deserializer);
    var var_positionY = sse_decode_f_32(deserializer);
    var var_positionZ = sse_decode_f_32(deserializer);
    var var_orientationX = sse_decode_f_32(deserializer);
    var var_orientationY = sse_decode_f_32(deserializer);
    var var_orientationZ = sse_decode_f_32(deserializer);
    var var_refDistance = sse_decode_f_64(deserializer);
    var var_maxDistance = sse_decode_f_64(deserializer);
    var var_rolloffFactor = sse_decode_f_64(deserializer);
    var var_coneInnerAngle = sse_decode_f_64(deserializer);
    var var_coneOuterAngle = sse_decode_f_64(deserializer);
    var var_coneOuterGain = sse_decode_f_64(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return PannerOptions(
        panningModel: var_panningModel,
        distanceModel: var_distanceModel,
        positionX: var_positionX,
        positionY: var_positionY,
        positionZ: var_positionZ,
        orientationX: var_orientationX,
        orientationY: var_orientationY,
        orientationZ: var_orientationZ,
        refDistance: var_refDistance,
        maxDistance: var_maxDistance,
        rolloffFactor: var_rolloffFactor,
        coneInnerAngle: var_coneInnerAngle,
        coneOuterAngle: var_coneOuterAngle,
        coneOuterGain: var_coneOuterGain,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  PanningModelType sse_decode_panning_model_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PanningModelType.values[inner];
  }

  @protected
  PeriodicWaveOptions sse_decode_periodic_wave_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_real = sse_decode_opt_list_prim_f_32_strict(deserializer);
    var var_imag = sse_decode_opt_list_prim_f_32_strict(deserializer);
    var var_disableNormalization = sse_decode_bool(deserializer);
    return PeriodicWaveOptions(
        real: var_real,
        imag: var_imag,
        disableNormalization: var_disableNormalization);
  }

  @protected
  (
    ConcreteBaseAudioContext,
    AudioNodeId
  ) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
            deserializer);
    var var_field1 = sse_decode_audio_node_id(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, double) sse_decode_record_string_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_f_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ScriptProcessorOptions sse_decode_script_processor_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bufferSize = sse_decode_usize(deserializer);
    var var_numberOfInputChannels = sse_decode_usize(deserializer);
    var var_numberOfOutputChannels = sse_decode_usize(deserializer);
    return ScriptProcessorOptions(
        bufferSize: var_bufferSize,
        numberOfInputChannels: var_numberOfInputChannels,
        numberOfOutputChannels: var_numberOfOutputChannels);
  }

  @protected
  StereoPannerOptions sse_decode_stereo_panner_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pan = sse_decode_f_32(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return StereoPannerOptions(
        pan: var_pan, audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WaveShaperOptions sse_decode_wave_shaper_options(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_curve = sse_decode_opt_list_prim_f_32_strict(deserializer);
    var var_oversample = sse_decode_over_sample_type(deserializer);
    var var_audioNodeOptions = sse_decode_audio_node_options(deserializer);
    return WaveShaperOptions(
        curve: var_curve,
        oversample: var_oversample,
        audioNodeOptions: var_audioNodeOptions);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          AnalyserNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          AtomicF32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          AtomicF64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          AudioBufferSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          AudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          AudioDestinationNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          AudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          AudioRenderCapacity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          AudioRenderCapacityEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          AudioWorkletNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          BiquadFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
          BoxAny self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
          BoxAny self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError(
          BoxError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
          C self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          ChannelData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode(
          ChannelMergerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode(
          ChannelSplitterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          ConcreteBaseAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          ConstantSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          ConvolverNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          DelayNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          DynamicsCompressorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          ErrorEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch(
          EventDispatch self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
          EventHandler self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          EventLoop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
          F self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          GainNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          IirFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode(
          MediaElementAudioSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          MediaElementAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          MediaRecorder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          MediaStreamAudioDestinationNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode(
          MediaStreamAudioSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          MediaStreamAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode(
          MediaStreamTrackAudioSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          MediaStreamTrackAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          MessagePort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          OfflineAudioCompletionEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          OfflineAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          Ordering self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          OscillatorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          PannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          PeriodicWave self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
          ReceiverEventDispatch self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          ScriptProcessorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          StereoPannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
          T self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          WaveShaperNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          AnalyserNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          AudioBuffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          AudioBufferSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          AudioRenderCapacityEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          BiquadFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          ChannelData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          ConvolverNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          ErrorEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
          MediaElement self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          MediaElementAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          MediaStreamAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          MediaStreamTrackAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          OfflineAudioCompletionEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          OfflineAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          OscillatorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          PannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          WaveShaperNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          F32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
          U8 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          AnalyserNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          AtomicF32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          AtomicF64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          AudioBuffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          AudioBufferSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          AudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
          AudioContextRegistration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          AudioDestinationNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          AudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          AudioRenderCapacity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          AudioRenderCapacityEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          AudioWorkletNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          BiquadFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
          C self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          ChannelData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          ConcreteBaseAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          ConstantSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          ConvolverNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          DelayNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          DynamicsCompressorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          ErrorEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          EventLoop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          GainNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          HashMapStringAudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          IirFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          MediaElementAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          MediaRecorder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
          MediaStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          MediaStreamAudioDestinationNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          MediaStreamAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          MediaStreamTrackAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          OfflineAudioCompletionEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          OfflineAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          OscillatorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          PannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          ScriptProcessorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf(
          Self self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          StereoPannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          WaveShaperNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          F32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Map_String_f_64(
      Map<String, double> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_f_64(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnalyserNode(
          AnalyserNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          AtomicF32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          AtomicF64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          AudioBuffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBufferSourceNode(
          AudioBufferSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContext(
          AudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioContextRegistration(
          AudioContextRegistration self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioDestinationNode(
          AudioDestinationNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioParam(
          AudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacity(
          AudioRenderCapacity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioRenderCapacityEvent(
          AudioRenderCapacityEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          AudioWorkletNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBiquadFilterNode(
          BiquadFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySend(
          BoxAny self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynAnySendstatic(
          BoxAny self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxdynError(
          BoxError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
          C self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          ChannelData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelMergerNode(
          ChannelMergerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelSplitterNode(
          ChannelSplitterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
          ConcreteBaseAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConstantSourceNode(
          ConstantSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConvolverNode(
          ConvolverNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDelayNode(
          DelayNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDynamicsCompressorNode(
          DynamicsCompressorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerErrorEvent(
          ErrorEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventDispatch(
          EventDispatch self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventHandler(
          EventHandler self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEventLoop(
          EventLoop self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
          F self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGainNode(
          GainNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          HashMapStringAudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIIRFilterNode(
          IirFilterNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElement(
          MediaElement self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceNode(
          MediaElementAudioSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaElementAudioSourceOptions(
          MediaElementAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          MediaRecorder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStream(
          MediaStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioDestinationNode(
          MediaStreamAudioDestinationNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceNode(
          MediaStreamAudioSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamAudioSourceOptions(
          MediaStreamAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceNode(
          MediaStreamTrackAudioSourceNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrackAudioSourceOptions(
          MediaStreamTrackAudioSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          MessagePort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioCompletionEvent(
          OfflineAudioCompletionEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOfflineAudioContext(
          OfflineAudioContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          Ordering self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOscillatorNode(
          OscillatorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPannerNode(
          PannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          PeriodicWave self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerReceiverEventDispatch(
          ReceiverEventDispatch self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerScriptProcessorNode(
          ScriptProcessorNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSelf(
          Self self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStereoPannerNode(
          StereoPannerNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
          T self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWaveShaperNode(
          WaveShaperNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          F32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInneru8(
          U8 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_analyser_options(
      AnalyserOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.fftSize, serializer);
    sse_encode_f_64(self.maxDecibels, serializer);
    sse_encode_f_64(self.minDecibels, serializer);
    sse_encode_f_64(self.smoothingTimeConstant, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_audio_buffer(AudioBuffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
        self.channels, serializer);
    sse_encode_f_32(self.sampleRate, serializer);
  }

  @protected
  void sse_encode_audio_buffer_options(
      AudioBufferOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.numberOfChannels, serializer);
    sse_encode_usize(self.length, serializer);
    sse_encode_f_32(self.sampleRate, serializer);
  }

  @protected
  void sse_encode_audio_buffer_source_options(
      AudioBufferSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_audio_buffer(self.buffer, serializer);
    sse_encode_f_32(self.detune, serializer);
    sse_encode_bool(self.loop, serializer);
    sse_encode_f_64(self.loopStart, serializer);
    sse_encode_f_64(self.loopEnd, serializer);
    sse_encode_f_32(self.playbackRate, serializer);
  }

  @protected
  void sse_encode_audio_context_latency_category(
      AudioContextLatencyCategory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AudioContextLatencyCategory_Balanced():
        sse_encode_i_32(0, serializer);
      case AudioContextLatencyCategory_Interactive():
        sse_encode_i_32(1, serializer);
      case AudioContextLatencyCategory_Playback():
        sse_encode_i_32(2, serializer);
      case AudioContextLatencyCategory_Custom(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_f_64(field0, serializer);
    }
  }

  @protected
  void sse_encode_audio_context_options(
      AudioContextOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_context_latency_category(self.latencyHint, serializer);
    sse_encode_opt_box_autoadd_f_32(self.sampleRate, serializer);
    sse_encode_String(self.sinkId, serializer);
    sse_encode_audio_context_render_size_category(
        self.renderSizeHint, serializer);
  }

  @protected
  void sse_encode_audio_context_render_size_category(
      AudioContextRenderSizeCategory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_audio_context_state(
      AudioContextState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_audio_node_id(AudioNodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.field0, serializer);
  }

  @protected
  void sse_encode_audio_node_options(
      AudioNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.channelCount, serializer);
    sse_encode_channel_count_mode(self.channelCountMode, serializer);
    sse_encode_channel_interpretation(self.channelInterpretation, serializer);
  }

  @protected
  void sse_encode_audio_processing_event(
      AudioProcessingEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_buffer(self.inputBuffer, serializer);
    sse_encode_audio_buffer(self.outputBuffer, serializer);
    sse_encode_f_64(self.playbackTime, serializer);
    sse_encode_opt_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
        self.registration, serializer);
  }

  @protected
  void sse_encode_audio_render_capacity_options(
      AudioRenderCapacityOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.updateInterval, serializer);
  }

  @protected
  void sse_encode_automation_rate(
      AutomationRate self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_biquad_filter_options(
      BiquadFilterOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.q, serializer);
    sse_encode_f_32(self.detune, serializer);
    sse_encode_f_32(self.frequency, serializer);
    sse_encode_f_32(self.gain, serializer);
    sse_encode_biquad_filter_type(self.type, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_biquad_filter_type(
      BiquadFilterType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          PeriodicWave self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          AudioBuffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          F32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_analyser_options(
      AnalyserOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_analyser_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_buffer(
      AudioBuffer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_buffer(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_buffer_options(
      AudioBufferOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_buffer_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_buffer_source_options(
      AudioBufferSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_buffer_source_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_context_options(
      AudioContextOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_context_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_node_id(
      AudioNodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_node_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_node_options(
      AudioNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_node_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_processing_event(
      AudioProcessingEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_processing_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_audio_render_capacity_options(
      AudioRenderCapacityOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_render_capacity_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_biquad_filter_options(
      BiquadFilterOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_biquad_filter_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_merger_options(
      ChannelMergerOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_merger_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_splitter_options(
      ChannelSplitterOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_splitter_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_constant_source_options(
      ConstantSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_constant_source_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_convolver_options(
      ConvolverOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_convolver_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_delay_options(
      DelayOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_delay_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_dynamics_compressor_options(
      DynamicsCompressorOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_dynamics_compressor_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event_type(
      EventType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gain_options(
      GainOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gain_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_iir_filter_options(
      IIRFilterOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_iir_filter_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream(
      MediaStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream_constraints(
      MediaStreamConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_track_constraints(
      MediaTrackConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_track_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_oscillator_options(
      OscillatorOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_oscillator_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_panner_options(
      PannerOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_panner_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_periodic_wave_options(
      PeriodicWaveOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_periodic_wave_options(self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
          (ConcreteBaseAudioContext, AudioNodeId) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_script_processor_options(
      ScriptProcessorOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_script_processor_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_stereo_panner_options(
      StereoPannerOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_stereo_panner_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_wave_shaper_options(
      WaveShaperOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_wave_shaper_options(self, serializer);
  }

  @protected
  void sse_encode_channel_count_mode(
      ChannelCountMode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_channel_interpretation(
      ChannelInterpretation self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_channel_merger_options(
      ChannelMergerOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.numberOfInputs, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_channel_splitter_options(
      ChannelSplitterOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.numberOfOutputs, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_constant_source_options(
      ConstantSourceOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.offset, serializer);
  }

  @protected
  void sse_encode_convolver_options(
      ConvolverOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_audio_buffer(self.buffer, serializer);
    sse_encode_bool(self.disableNormalization, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_delay_options(DelayOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.maxDelayTime, serializer);
    sse_encode_f_64(self.delayTime, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_distance_model_type(
      DistanceModelType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_dynamics_compressor_options(
      DynamicsCompressorOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.attack, serializer);
    sse_encode_f_32(self.knee, serializer);
    sse_encode_f_32(self.ratio, serializer);
    sse_encode_f_32(self.release, serializer);
    sse_encode_f_32(self.threshold, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_event_type(EventType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EventType_Ended(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_audio_node_id(field0, serializer);
      case EventType_SinkChange():
        sse_encode_i_32(1, serializer);
      case EventType_StateChange():
        sse_encode_i_32(2, serializer);
      case EventType_RenderCapacity():
        sse_encode_i_32(3, serializer);
      case EventType_ProcessorError(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_audio_node_id(field0, serializer);
      case EventType_Diagnostics():
        sse_encode_i_32(5, serializer);
      case EventType_Message(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_audio_node_id(field0, serializer);
      case EventType_Complete():
        sse_encode_i_32(7, serializer);
      case EventType_AudioProcessing(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_box_autoadd_audio_node_id(field0, serializer);
    }
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_gain_options(GainOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.gain, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_iir_filter_options(
      IIRFilterOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
    sse_encode_list_prim_f_64_strict(self.feedforward, serializer);
    sse_encode_list_prim_f_64_strict(self.feedback, serializer);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          List<ChannelData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelData(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          List<MediaDeviceInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          List<MediaStreamTrack> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_prim_f_32_strict(
      List<Float32List> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_prim_f_32_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_loose(
      List<double> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(
        self is Float32List ? self : Float32List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_f_32_strict(
      Float32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_f_64_strict(
      Float64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_string_f_64(
      List<(String, double)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_f_64(item, serializer);
    }
  }

  @protected
  void sse_encode_media_device_info_kind(
      MediaDeviceInfoKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_media_stream(MediaStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
        self.tracks, serializer);
  }

  @protected
  void sse_encode_media_stream_constraints(
      MediaStreamConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MediaStreamConstraints_Audio():
        sse_encode_i_32(0, serializer);
      case MediaStreamConstraints_AudioWithConstraints(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_media_track_constraints(field0, serializer);
    }
  }

  @protected
  void sse_encode_media_stream_track_state(
      MediaStreamTrackState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_media_track_constraints(
      MediaTrackConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_f_32(self.sampleRate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.latency, serializer);
    sse_encode_opt_box_autoadd_u_32(self.channelCount, serializer);
    sse_encode_opt_String(self.deviceId, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          PeriodicWave? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          AudioBuffer? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioBuffer(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          F32? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerf32(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_audio_buffer(
      AudioBuffer? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_audio_buffer(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
          (ConcreteBaseAudioContext, AudioNodeId)? self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_f_32_strict(
      Float32List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_f_32_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_oscillator_options(
      OscillatorOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_oscillator_type(self.type, serializer);
    sse_encode_f_32(self.frequency, serializer);
    sse_encode_f_32(self.detune, serializer);
    sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeriodicWave(
        self.periodicWave, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_oscillator_type(
      OscillatorType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_over_sample_type(
      OverSampleType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_panner_options(PannerOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_panning_model_type(self.panningModel, serializer);
    sse_encode_distance_model_type(self.distanceModel, serializer);
    sse_encode_f_32(self.positionX, serializer);
    sse_encode_f_32(self.positionY, serializer);
    sse_encode_f_32(self.positionZ, serializer);
    sse_encode_f_32(self.orientationX, serializer);
    sse_encode_f_32(self.orientationY, serializer);
    sse_encode_f_32(self.orientationZ, serializer);
    sse_encode_f_64(self.refDistance, serializer);
    sse_encode_f_64(self.maxDistance, serializer);
    sse_encode_f_64(self.rolloffFactor, serializer);
    sse_encode_f_64(self.coneInnerAngle, serializer);
    sse_encode_f_64(self.coneOuterAngle, serializer);
    sse_encode_f_64(self.coneOuterGain, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_panning_model_type(
      PanningModelType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_periodic_wave_options(
      PeriodicWaveOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_prim_f_32_strict(self.real, serializer);
    sse_encode_opt_list_prim_f_32_strict(self.imag, serializer);
    sse_encode_bool(self.disableNormalization, serializer);
  }

  @protected
  void
      sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_concrete_base_audio_context_audio_node_id(
          (ConcreteBaseAudioContext, AudioNodeId) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConcreteBaseAudioContext(
        self.$1, serializer);
    sse_encode_audio_node_id(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_f_64(
      (String, double) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_f_64(self.$2, serializer);
  }

  @protected
  void sse_encode_script_processor_options(
      ScriptProcessorOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.bufferSize, serializer);
    sse_encode_usize(self.numberOfInputChannels, serializer);
    sse_encode_usize(self.numberOfOutputChannels, serializer);
  }

  @protected
  void sse_encode_stereo_panner_options(
      StereoPannerOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.pan, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_wave_shaper_options(
      WaveShaperOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_list_prim_f_32_strict(self.curve, serializer);
    sse_encode_over_sample_type(self.oversample, serializer);
    sse_encode_audio_node_options(self.audioNodeOptions, serializer);
  }
}
