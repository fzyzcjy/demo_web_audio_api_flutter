// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import '../web_audio_api.dart';
import '../web_audio_api/media_devices.dart';
import '../web_audio_api/media_recorder.dart';
import '../web_audio_api/media_streams.dart';
import '../web_audio_api/worklet.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'web_audio_api.dart';
import 'web_audio_api/media_devices.dart';
import 'web_audio_api/media_recorder.dart';
import 'web_audio_api/media_streams.dart';
import 'web_audio_api/worklet.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.37';

  @override
  int get rustContentHash => 27400456;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_demo_web_audio_api_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  String crateApiSimpleGreet({required String name});

  Future<void> crateApiSimpleInitApp();

  Future<double> webAudioApiAtomicF32Load(
      {required AtomicF32 that, required Ordering ordering});

  Future<AtomicF32> webAudioApiAtomicF32New({required double value});

  Future<void> webAudioApiAtomicF32Store(
      {required AtomicF32 that,
      required double value,
      required Ordering ordering});

  Future<double> webAudioApiAtomicF64Load(
      {required AtomicF64 that, required Ordering ordering});

  Future<AtomicF64> webAudioApiAtomicF64New({required double value});

  Future<void> webAudioApiAtomicF64Store(
      {required AtomicF64 that,
      required double value,
      required Ordering ordering});

  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoDeviceId(
      {required MediaDeviceInfo that});

  Future<Str?> webAudioApiMediaDevicesMediaDeviceInfoGroupId(
      {required MediaDeviceInfo that});

  Future<MediaDeviceInfoKind> webAudioApiMediaDevicesMediaDeviceInfoKind(
      {required MediaDeviceInfo that});

  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoLabel(
      {required MediaDeviceInfo that});

  Future<List<MediaDeviceInfo>> webAudioApiMediaDevicesEnumerateDevicesSync();

  Future<MediaStream> webAudioApiMediaDevicesGetUserMediaSync(
      {required MediaStreamConstraints constraints});

  Uint8List webAudioApiMediaRecorderBlobEventGetBlob({required BlobEvent that});

  Event webAudioApiMediaRecorderBlobEventGetEvent({required BlobEvent that});

  double webAudioApiMediaRecorderBlobEventGetTimecode(
      {required BlobEvent that});

  void webAudioApiMediaRecorderBlobEventSetBlob(
      {required BlobEvent that, required Uint8List blob});

  void webAudioApiMediaRecorderBlobEventSetEvent(
      {required BlobEvent that, required Event event});

  void webAudioApiMediaRecorderBlobEventSetTimecode(
      {required BlobEvent that, required double timecode});

  Future<void> webAudioApiMediaRecorderMediaRecorderClearOndataavailable(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnerror(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnstop(
      {required MediaRecorder that});

  Future<MediaRecorder> webAudioApiMediaRecorderMediaRecorderNew(
      {required MediaStream stream});

  Future<void> webAudioApiMediaRecorderMediaRecorderSetOndataavailable(
      {required MediaRecorder that, required F callback});

  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnerror(
      {required MediaRecorder that, required F callback});

  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnstop(
      {required MediaRecorder that, required F callback});

  Future<void> webAudioApiMediaRecorderMediaRecorderStart(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaRecorderMediaRecorderStop(
      {required MediaRecorder that});

  Future<void> webAudioApiMediaStreamsMediaStreamTrackClose(
      {required MediaStreamTrack that});

  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamTrackFromIter(
      {required T iter});

  Future<MediaStreamTrackState>
      webAudioApiMediaStreamsMediaStreamTrackReadyState(
          {required MediaStreamTrack that});

  Future<MediaStream> webAudioApiMediaStreamsMediaStreamFromTracks(
      {required List<MediaStreamTrack> tracks});

  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamGetTracks(
      {required MediaStream that});

  AudioNodeOptions webAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptions(
      {required AudioWorkletNodeOptions that});

  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputs(
      {required AudioWorkletNodeOptions that});

  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputs(
      {required AudioWorkletNodeOptions that});

  Uint64List webAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCount(
      {required AudioWorkletNodeOptions that});

  Map<String, double> webAudioApiWorkletAudioWorkletNodeOptionsGetParameterData(
      {required AudioWorkletNodeOptions that});

  C webAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptions(
      {required AudioWorkletNodeOptions that});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptions(
      {required AudioWorkletNodeOptions that,
      required AudioNodeOptions audioNodeOptions});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputs(
      {required AudioWorkletNodeOptions that, required BigInt numberOfInputs});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputs(
      {required AudioWorkletNodeOptions that, required BigInt numberOfOutputs});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCount(
      {required AudioWorkletNodeOptions that,
      required Uint64List outputChannelCount});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetParameterData(
      {required AudioWorkletNodeOptions that,
      required Map<String, double> parameterData});

  void webAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptions(
      {required AudioWorkletNodeOptions that, required C processorOptions});

  Future<HashMapStringAudioParam> webAudioApiWorkletAudioWorkletNodeParameters(
      {required AudioWorkletNode that});

  Future<MessagePort> webAudioApiWorkletAudioWorkletNodePort(
      {required AudioWorkletNode that});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF32;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AtomicF32Ptr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF64;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF64;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AtomicF64Ptr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioNodeOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioNodeOptions;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioNodeOptionsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNode;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioWorkletNodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNodeOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNodeOptions;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_AudioWorkletNodeOptionsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlobEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlobEvent;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BlobEventPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_C;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_C;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Event;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Event;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EventPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_F;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_F;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_HashMapStringAudioParam;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_HashMapStringAudioParam;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_HashMapStringAudioParamPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaDeviceInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaDeviceInfo;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaDeviceInfoPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaRecorder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaRecorder;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaRecorderPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrack;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrack;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_MediaStreamTrackPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MessagePort;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MessagePort;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MessagePortPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ordering;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ordering;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OrderingPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_T;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_T;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Str;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Str;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StrPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGreetConstMeta,
      argValues: [name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<double> webAudioApiAtomicF32Load(
      {required AtomicF32 that, required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF32LoadConstMeta,
      argValues: [that, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF32LoadConstMeta => const TaskConstMeta(
        debugName: "AtomicF32_load",
        argNames: ["that", "ordering"],
      );

  @override
  Future<AtomicF32> webAudioApiAtomicF32New({required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF32NewConstMeta,
      argValues: [value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF32NewConstMeta => const TaskConstMeta(
        debugName: "AtomicF32_new",
        argNames: ["value"],
      );

  @override
  Future<void> webAudioApiAtomicF32Store(
      {required AtomicF32 that,
      required double value,
      required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
            that, serializer);
        sse_encode_f_32(value, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF32StoreConstMeta,
      argValues: [that, value, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF32StoreConstMeta => const TaskConstMeta(
        debugName: "AtomicF32_store",
        argNames: ["that", "value", "ordering"],
      );

  @override
  Future<double> webAudioApiAtomicF64Load(
      {required AtomicF64 that, required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF64LoadConstMeta,
      argValues: [that, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF64LoadConstMeta => const TaskConstMeta(
        debugName: "AtomicF64_load",
        argNames: ["that", "ordering"],
      );

  @override
  Future<AtomicF64> webAudioApiAtomicF64New({required double value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_f_64(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF64NewConstMeta,
      argValues: [value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF64NewConstMeta => const TaskConstMeta(
        debugName: "AtomicF64_new",
        argNames: ["value"],
      );

  @override
  Future<void> webAudioApiAtomicF64Store(
      {required AtomicF64 that,
      required double value,
      required Ordering ordering}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
            that, serializer);
        sse_encode_f_64(value, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
            ordering, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiAtomicF64StoreConstMeta,
      argValues: [that, value, ordering],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiAtomicF64StoreConstMeta => const TaskConstMeta(
        debugName: "AtomicF64_store",
        argNames: ["that", "value", "ordering"],
      );

  @override
  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoDeviceId(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoDeviceIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoDeviceIdConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_device_id",
        argNames: ["that"],
      );

  @override
  Future<Str?> webAudioApiMediaDevicesMediaDeviceInfoGroupId(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoGroupIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoGroupIdConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_group_id",
        argNames: ["that"],
      );

  @override
  Future<MediaDeviceInfoKind> webAudioApiMediaDevicesMediaDeviceInfoKind(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_device_info_kind,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoKindConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoKindConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_kind",
        argNames: ["that"],
      );

  @override
  Future<Str> webAudioApiMediaDevicesMediaDeviceInfoLabel(
      {required MediaDeviceInfo that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesMediaDeviceInfoLabelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesMediaDeviceInfoLabelConstMeta =>
      const TaskConstMeta(
        debugName: "MediaDeviceInfo_label",
        argNames: ["that"],
      );

  @override
  Future<List<MediaDeviceInfo>> webAudioApiMediaDevicesEnumerateDevicesSync() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesEnumerateDevicesSyncConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesEnumerateDevicesSyncConstMeta =>
      const TaskConstMeta(
        debugName: "enumerate_devices_sync",
        argNames: [],
      );

  @override
  Future<MediaStream> webAudioApiMediaDevicesGetUserMediaSync(
      {required MediaStreamConstraints constraints}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream_constraints(
            constraints, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaDevicesGetUserMediaSyncConstMeta,
      argValues: [constraints],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaDevicesGetUserMediaSyncConstMeta =>
      const TaskConstMeta(
        debugName: "get_user_media_sync",
        argNames: ["constraints"],
      );

  @override
  Uint8List webAudioApiMediaRecorderBlobEventGetBlob(
      {required BlobEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventGetBlobConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventGetBlobConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_get_blob",
        argNames: ["that"],
      );

  @override
  Event webAudioApiMediaRecorderBlobEventGetEvent({required BlobEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventGetEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventGetEventConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_get_event",
        argNames: ["that"],
      );

  @override
  double webAudioApiMediaRecorderBlobEventGetTimecode(
      {required BlobEvent that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventGetTimecodeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventGetTimecodeConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_get_timecode",
        argNames: ["that"],
      );

  @override
  void webAudioApiMediaRecorderBlobEventSetBlob(
      {required BlobEvent that, required Uint8List blob}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        sse_encode_list_prim_u_8_strict(blob, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventSetBlobConstMeta,
      argValues: [that, blob],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventSetBlobConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_set_blob",
        argNames: ["that", "blob"],
      );

  @override
  void webAudioApiMediaRecorderBlobEventSetEvent(
      {required BlobEvent that, required Event event}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
            event, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventSetEventConstMeta,
      argValues: [that, event],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventSetEventConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_set_event",
        argNames: ["that", "event"],
      );

  @override
  void webAudioApiMediaRecorderBlobEventSetTimecode(
      {required BlobEvent that, required double timecode}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
            that, serializer);
        sse_encode_f_64(timecode, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderBlobEventSetTimecodeConstMeta,
      argValues: [that, timecode],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderBlobEventSetTimecodeConstMeta =>
      const TaskConstMeta(
        debugName: "BlobEvent_set_timecode",
        argNames: ["that", "timecode"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderClearOndataavailable(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiMediaRecorderMediaRecorderClearOndataavailableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderClearOndataavailableConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_clear_ondataavailable",
            argNames: ["that"],
          );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnerror(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderClearOnerrorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderClearOnerrorConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_clear_onerror",
            argNames: ["that"],
          );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderClearOnstop(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderClearOnstopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderClearOnstopConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_clear_onstop",
            argNames: ["that"],
          );

  @override
  Future<MediaRecorder> webAudioApiMediaRecorderMediaRecorderNew(
      {required MediaStream stream}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream(stream, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderNewConstMeta,
      argValues: [stream],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderNewConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_new",
        argNames: ["stream"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderSetOndataavailable(
      {required MediaRecorder that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiMediaRecorderMediaRecorderSetOndataavailableConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaRecorderMediaRecorderSetOndataavailableConstMeta =>
          const TaskConstMeta(
            debugName: "MediaRecorder_set_ondataavailable",
            argNames: ["that", "callback"],
          );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnerror(
      {required MediaRecorder that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderSetOnerrorConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderSetOnerrorConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_set_onerror",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderSetOnstop(
      {required MediaRecorder that, required F callback}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
            callback, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderSetOnstopConstMeta,
      argValues: [that, callback],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderSetOnstopConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_set_onstop",
        argNames: ["that", "callback"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderStart(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderStartConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderStartConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_start",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiMediaRecorderMediaRecorderStop(
      {required MediaRecorder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaRecorderMediaRecorderStopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaRecorderMediaRecorderStopConstMeta =>
      const TaskConstMeta(
        debugName: "MediaRecorder_stop",
        argNames: ["that"],
      );

  @override
  Future<void> webAudioApiMediaStreamsMediaStreamTrackClose(
      {required MediaStreamTrack that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamTrackCloseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamTrackCloseConstMeta =>
      const TaskConstMeta(
        debugName: "MediaStreamTrack_close",
        argNames: ["that"],
      );

  @override
  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamTrackFromIter(
      {required T iter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
            iter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamTrackFromIterConstMeta,
      argValues: [iter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamTrackFromIterConstMeta =>
      const TaskConstMeta(
        debugName: "MediaStreamTrack_from_iter",
        argNames: ["iter"],
      );

  @override
  Future<MediaStreamTrackState>
      webAudioApiMediaStreamsMediaStreamTrackReadyState(
          {required MediaStreamTrack that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream_track_state,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamTrackReadyStateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiMediaStreamsMediaStreamTrackReadyStateConstMeta =>
          const TaskConstMeta(
            debugName: "MediaStreamTrack_ready_state",
            argNames: ["that"],
          );

  @override
  Future<MediaStream> webAudioApiMediaStreamsMediaStreamFromTracks(
      {required List<MediaStreamTrack> tracks}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            tracks, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_stream,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamFromTracksConstMeta,
      argValues: [tracks],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamFromTracksConstMeta =>
      const TaskConstMeta(
        debugName: "media_stream_from_tracks",
        argNames: ["tracks"],
      );

  @override
  Future<MediaStreamTrack> webAudioApiMediaStreamsMediaStreamGetTracks(
      {required MediaStream that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_media_stream(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiMediaStreamsMediaStreamGetTracksConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiMediaStreamsMediaStreamGetTracksConstMeta =>
      const TaskConstMeta(
        debugName: "media_stream_get_tracks",
        argNames: ["that"],
      );

  @override
  AudioNodeOptions webAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptions(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetAudioNodeOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_audio_node_options",
            argNames: ["that"],
          );

  @override
  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputs(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfInputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_number_of_inputs",
            argNames: ["that"],
          );

  @override
  BigInt webAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputs(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_usize,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetNumberOfOutputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_number_of_outputs",
            argNames: ["that"],
          );

  @override
  Uint64List webAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCount(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_usize_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetOutputChannelCountConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_output_channel_count",
            argNames: ["that"],
          );

  @override
  Map<String, double> webAudioApiWorkletAudioWorkletNodeOptionsGetParameterData(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_String_f_64,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetParameterDataConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetParameterDataConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_parameter_data",
            argNames: ["that"],
          );

  @override
  C webAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptions(
      {required AudioWorkletNodeOptions that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsGetProcessorOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_get_processor_options",
            argNames: ["that"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptions(
      {required AudioWorkletNodeOptions that,
      required AudioNodeOptions audioNodeOptions}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
            audioNodeOptions, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptionsConstMeta,
      argValues: [that, audioNodeOptions],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetAudioNodeOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_audio_node_options",
            argNames: ["that", "audioNodeOptions"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputs(
      {required AudioWorkletNodeOptions that, required BigInt numberOfInputs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_usize(numberOfInputs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputsConstMeta,
      argValues: [that, numberOfInputs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfInputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_number_of_inputs",
            argNames: ["that", "numberOfInputs"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputs(
      {required AudioWorkletNodeOptions that,
      required BigInt numberOfOutputs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_usize(numberOfOutputs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputsConstMeta,
      argValues: [that, numberOfOutputs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetNumberOfOutputsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_number_of_outputs",
            argNames: ["that", "numberOfOutputs"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCount(
      {required AudioWorkletNodeOptions that,
      required Uint64List outputChannelCount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_list_prim_usize_strict(outputChannelCount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCountConstMeta,
      argValues: [that, outputChannelCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetOutputChannelCountConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_output_channel_count",
            argNames: ["that", "outputChannelCount"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetParameterData(
      {required AudioWorkletNodeOptions that,
      required Map<String, double> parameterData}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_Map_String_f_64(parameterData, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetParameterDataConstMeta,
      argValues: [that, parameterData],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetParameterDataConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_parameter_data",
            argNames: ["that", "parameterData"],
          );

  @override
  void webAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptions(
      {required AudioWorkletNodeOptions that, required C processorOptions}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
            processorOptions, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kWebAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptionsConstMeta,
      argValues: [that, processorOptions],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kWebAudioApiWorkletAudioWorkletNodeOptionsSetProcessorOptionsConstMeta =>
          const TaskConstMeta(
            debugName: "AudioWorkletNodeOptions_set_processor_options",
            argNames: ["that", "processorOptions"],
          );

  @override
  Future<HashMapStringAudioParam> webAudioApiWorkletAudioWorkletNodeParameters(
      {required AudioWorkletNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiWorkletAudioWorkletNodeParametersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiWorkletAudioWorkletNodeParametersConstMeta =>
      const TaskConstMeta(
        debugName: "AudioWorkletNode_parameters",
        argNames: ["that"],
      );

  @override
  Future<MessagePort> webAudioApiWorkletAudioWorkletNodePort(
      {required AudioWorkletNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_,
        decodeErrorData: null,
      ),
      constMeta: kWebAudioApiWorkletAudioWorkletNodePortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kWebAudioApiWorkletAudioWorkletNodePortConstMeta =>
      const TaskConstMeta(
        debugName: "AudioWorkletNode_port",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF32 => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF32 => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AtomicF64 => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AtomicF64 => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioNodeOptions => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioNodeOptions => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNode => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNode => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AudioWorkletNodeOptions => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AudioWorkletNodeOptions => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BlobEvent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BlobEvent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_C => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_C => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Event =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Event =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_F => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_F => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_HashMapStringAudioParam => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_HashMapStringAudioParam => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaDeviceInfo => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaDeviceInfo => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaRecorder => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaRecorder => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MediaStreamTrack => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MediaStreamTrack => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MessagePort => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MessagePort => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ordering => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ordering => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_T => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_T => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Str => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Str => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr;

  @protected
  AtomicF32
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF64
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF64.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioNodeOptions
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNode
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  C dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return C.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Event
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Event.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaDeviceInfo
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaRecorder
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaRecorder.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamTrack
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrack.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MessagePort
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MessagePort.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ordering
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ordering.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  T dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return T.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF32
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF64
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF64.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNode
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  HashMapStringAudioParam
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaDeviceInfo
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaRecorder
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaRecorder.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamTrack
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrack.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Str dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Str.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Map<String, double> dco_decode_Map_String_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_f_64(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AtomicF32
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF32.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AtomicF64
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AtomicF64.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioNodeOptions
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNode
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNode.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AudioWorkletNodeOptions
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BlobEvent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BlobEvent.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  C dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return C.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Event
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Event.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  F dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return F.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  HashMapStringAudioParam
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaDeviceInfo
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaRecorder
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaRecorder.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MediaStreamTrack
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrack.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MessagePort
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MessagePort.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ordering
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ordering.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  T dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return T.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Str dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Str.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Str dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
        raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  MediaStream dco_decode_box_autoadd_media_stream(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream(raw);
  }

  @protected
  MediaStreamConstraints dco_decode_box_autoadd_media_stream_constraints(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_stream_constraints(raw);
  }

  @protected
  MediaTrackConstraints dco_decode_box_autoadd_media_track_constraints(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_track_constraints(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<MediaDeviceInfo>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo)
        .toList();
  }

  @protected
  List<MediaStreamTrack>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack)
        .toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(String, double)> dco_decode_list_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_f_64).toList();
  }

  @protected
  MediaDeviceInfoKind dco_decode_media_device_info_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaDeviceInfoKind.values[raw as int];
  }

  @protected
  MediaStream dco_decode_media_stream(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return MediaStream(
      tracks:
          dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
              arr[0]),
    );
  }

  @protected
  MediaStreamConstraints dco_decode_media_stream_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MediaStreamConstraints_Audio();
      case 1:
        return MediaStreamConstraints_AudioWithConstraints(
          dco_decode_box_autoadd_media_track_constraints(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  MediaStreamTrackState dco_decode_media_stream_track_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaStreamTrackState.values[raw as int];
  }

  @protected
  MediaTrackConstraints dco_decode_media_track_constraints(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return MediaTrackConstraints(
      sampleRate: dco_decode_opt_box_autoadd_f_32(arr[0]),
      latency: dco_decode_opt_box_autoadd_f_64(arr[1]),
      channelCount: dco_decode_opt_box_autoadd_u_32(arr[2]),
      deviceId: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Str?
      dco_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
            raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  (String, double) dco_decode_record_string_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_f_64(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AtomicF32
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF64
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF64.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioNodeOptions
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNode
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  C sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return C.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Event
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Event.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaDeviceInfo
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaRecorder
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaRecorder.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrack
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrack.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MessagePort
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MessagePort.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ordering
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ordering.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  T sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return T.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF32
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF64
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF64.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNode
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HashMapStringAudioParam
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaDeviceInfo
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaRecorder
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaRecorder.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrack
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrack.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Str sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Str.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Map<String, double> sse_decode_Map_String_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_f_64(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AtomicF32
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF32.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AtomicF64
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AtomicF64.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioNodeOptions
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNode
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNode.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AudioWorkletNodeOptions
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AudioWorkletNodeOptions.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BlobEvent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BlobEvent.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  C sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return C.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Event
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Event.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  F sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return F.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HashMapStringAudioParam
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HashMapStringAudioParam.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaDeviceInfo
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaDeviceInfo.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaRecorder
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaRecorder.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MediaStreamTrack
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaStreamTrack.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MessagePort
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MessagePort.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ordering
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ordering.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  T sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return T.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Str sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Str.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Str sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
        deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  MediaStream sse_decode_box_autoadd_media_stream(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream(deserializer));
  }

  @protected
  MediaStreamConstraints sse_decode_box_autoadd_media_stream_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_stream_constraints(deserializer));
  }

  @protected
  MediaTrackConstraints sse_decode_box_autoadd_media_track_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_track_constraints(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<MediaDeviceInfo>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaDeviceInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaStreamTrack>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaStreamTrack>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
              deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(String, double)> sse_decode_list_record_string_f_64(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, double)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_f_64(deserializer));
    }
    return ans_;
  }

  @protected
  MediaDeviceInfoKind sse_decode_media_device_info_kind(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaDeviceInfoKind.values[inner];
  }

  @protected
  MediaStream sse_decode_media_stream(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_tracks =
        sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
            deserializer);
    return MediaStream(tracks: var_tracks);
  }

  @protected
  MediaStreamConstraints sse_decode_media_stream_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return MediaStreamConstraints_Audio();
      case 1:
        var var_field0 =
            sse_decode_box_autoadd_media_track_constraints(deserializer);
        return MediaStreamConstraints_AudioWithConstraints(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  MediaStreamTrackState sse_decode_media_stream_track_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaStreamTrackState.values[inner];
  }

  @protected
  MediaTrackConstraints sse_decode_media_track_constraints(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sampleRate = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_latency = sse_decode_opt_box_autoadd_f_64(deserializer);
    var var_channelCount = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_deviceId = sse_decode_opt_String(deserializer);
    return MediaTrackConstraints(
        sampleRate: var_sampleRate,
        latency: var_latency,
        channelCount: var_channelCount,
        deviceId: var_deviceId);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Str?
      sse_decode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  (String, double) sse_decode_record_string_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_f_64(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          AtomicF32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          AtomicF64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
          AudioNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          AudioWorkletNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
          C self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
          F self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          MediaRecorder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          MessagePort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          Ordering self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
          T self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          AtomicF32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          AtomicF64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          AudioWorkletNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          HashMapStringAudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          MediaRecorder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Map_String_f_64(
      Map<String, double> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_f_64(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF32(
          AtomicF32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAtomicF64(
          AtomicF64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioNodeOptions(
          AudioNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNode(
          AudioWorkletNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAudioWorkletNodeOptions(
          AudioWorkletNodeOptions self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBlobEvent(
          BlobEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerC(
          C self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
          Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerF(
          F self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHashMapStringAudioParam(
          HashMapStringAudioParam self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          MediaDeviceInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaRecorder(
          MediaRecorder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          MediaStreamTrack self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessagePort_(
          MessagePort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOrdering(
          Ordering self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerT(
          T self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream(
      MediaStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_stream_constraints(
      MediaStreamConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_stream_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_track_constraints(
      MediaTrackConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_track_constraints(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          List<MediaDeviceInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaDeviceInfo(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          List<MediaStreamTrack> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_string_f_64(
      List<(String, double)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_f_64(item, serializer);
    }
  }

  @protected
  void sse_encode_media_device_info_kind(
      MediaDeviceInfoKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_media_stream(MediaStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMediaStreamTrack(
        self.tracks, serializer);
  }

  @protected
  void sse_encode_media_stream_constraints(
      MediaStreamConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MediaStreamConstraints_Audio():
        sse_encode_i_32(0, serializer);
      case MediaStreamConstraints_AudioWithConstraints(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_media_track_constraints(field0, serializer);
    }
  }

  @protected
  void sse_encode_media_stream_track_state(
      MediaStreamTrackState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_media_track_constraints(
      MediaTrackConstraints self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_f_32(self.sampleRate, serializer);
    sse_encode_opt_box_autoadd_f_64(self.latency, serializer);
    sse_encode_opt_box_autoadd_u_32(self.channelCount, serializer);
    sse_encode_opt_String(self.deviceId, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          Str? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerstr(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_record_string_f_64(
      (String, double) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_f_64(self.$2, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }
}
