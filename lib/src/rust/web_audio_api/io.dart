// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'capacity.dart';
import 'context/online.dart';
import 'events.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `thread_init`, `build_output`, `build_input`, `buffer_size_for_latency_category`, `enumerate_devices_sync`, `fmt`, `clone`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ControlThreadInit>>
@sealed
class ControlThreadInit extends RustOpaque {
  // Not to be used by end users
  ControlThreadInit.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ControlThreadInit.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ControlThreadInit,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ControlThreadInit,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ControlThreadInitPtr,
  );

  SenderControlMessage get ctrlMsgSend =>
      RustLib.instance.api.webAudioApiIoControlThreadInitGetCtrlMsgSend(
        that: this,
      );

  ReceiverEventDispatch get eventRecv =>
      RustLib.instance.api.webAudioApiIoControlThreadInitGetEventRecv(
        that: this,
      );

  SenderEventDispatch get eventSend =>
      RustLib.instance.api.webAudioApiIoControlThreadInitGetEventSend(
        that: this,
      );

  ArcAtomicU64 get framesPlayed =>
      RustLib.instance.api.webAudioApiIoControlThreadInitGetFramesPlayed(
        that: this,
      );

  ReceiverAudioRenderCapacityLoad get loadValueRecv =>
      RustLib.instance.api.webAudioApiIoControlThreadInitGetLoadValueRecv(
        that: this,
      );

  ArcAtomicU8 get state =>
      RustLib.instance.api.webAudioApiIoControlThreadInitGetState(
        that: this,
      );

  void set ctrlMsgSend(SenderControlMessage ctrlMsgSend) =>
      RustLib.instance.api.webAudioApiIoControlThreadInitSetCtrlMsgSend(
          that: this, ctrlMsgSend: ctrlMsgSend);

  void set eventRecv(ReceiverEventDispatch eventRecv) =>
      RustLib.instance.api.webAudioApiIoControlThreadInitSetEventRecv(
          that: this, eventRecv: eventRecv);

  void set eventSend(SenderEventDispatch eventSend) =>
      RustLib.instance.api.webAudioApiIoControlThreadInitSetEventSend(
          that: this, eventSend: eventSend);

  void set framesPlayed(ArcAtomicU64 framesPlayed) =>
      RustLib.instance.api.webAudioApiIoControlThreadInitSetFramesPlayed(
          that: this, framesPlayed: framesPlayed);

  void set loadValueRecv(ReceiverAudioRenderCapacityLoad loadValueRecv) =>
      RustLib.instance.api.webAudioApiIoControlThreadInitSetLoadValueRecv(
          that: this, loadValueRecv: loadValueRecv);

  void set state(ArcAtomicU8 state) => RustLib.instance.api
      .webAudioApiIoControlThreadInitSetState(that: this, state: state);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RenderThreadInit>>
@sealed
class RenderThreadInit extends RustOpaque {
  // Not to be used by end users
  RenderThreadInit.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  RenderThreadInit.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_RenderThreadInit,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_RenderThreadInit,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_RenderThreadInitPtr,
  );

  ReceiverControlMessage get ctrlMsgRecv =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitGetCtrlMsgRecv(
        that: this,
      );

  SenderEventDispatch get eventSend =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitGetEventSend(
        that: this,
      );

  ArcAtomicU64 get framesPlayed =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitGetFramesPlayed(
        that: this,
      );

  SenderAudioRenderCapacityLoad get loadValueSend =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitGetLoadValueSend(
        that: this,
      );

  ArcAtomicU8 get state =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitGetState(
        that: this,
      );

  void set ctrlMsgRecv(ReceiverControlMessage ctrlMsgRecv) =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitSetCtrlMsgRecv(
          that: this, ctrlMsgRecv: ctrlMsgRecv);

  void set eventSend(SenderEventDispatch eventSend) =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitSetEventSend(
          that: this, eventSend: eventSend);

  void set framesPlayed(ArcAtomicU64 framesPlayed) =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitSetFramesPlayed(
          that: this, framesPlayed: framesPlayed);

  void set loadValueSend(SenderAudioRenderCapacityLoad loadValueSend) =>
      RustLib.instance.api.webAudioApiIoRenderThreadInitSetLoadValueSend(
          that: this, loadValueSend: loadValueSend);

  void set state(ArcAtomicU8 state) => RustLib.instance.api
      .webAudioApiIoRenderThreadInitSetState(that: this, state: state);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sender < ControlMessage >>>
@sealed
class SenderControlMessage extends RustOpaque {
  // Not to be used by end users
  SenderControlMessage.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SenderControlMessage.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_SenderControlMessage,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_SenderControlMessage,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_SenderControlMessagePtr,
  );
}
