// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `clone`, `eq`, `assert_receiver_is_total_eq`, `fmt`, `from`, `clone`, `eq`, `assert_receiver_is_total_eq`, `fmt`, `from`, `clone`, `fmt`, `default`, `clone`, `fmt`, `clone`, `default`, `fmt`, `count_mode`, `set_count_mode`, `interpretation`, `set_interpretation`, `count`, `set_count`, `inner`, `from`
// These types are ignored because they are not used by any `pub` functions: `ChannelConfig`

/// Options that can be used in constructing all AudioNodes.
class AudioNodeOptions {
  /// Desired number of channels for the [`AudioNode::channel_count`] attribute.
  final BigInt channelCount;

  /// Desired mode for the [`AudioNode::channel_count_mode`] attribute.
  final ChannelCountMode channelCountMode;

  /// Desired mode for the [`AudioNode::channel_interpretation`] attribute.
  final ChannelInterpretation channelInterpretation;

  const AudioNodeOptions({
    required this.channelCount,
    required this.channelCountMode,
    required this.channelInterpretation,
  });

  @override
  int get hashCode =>
      channelCount.hashCode ^
      channelCountMode.hashCode ^
      channelInterpretation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioNodeOptions &&
          runtimeType == other.runtimeType &&
          channelCount == other.channelCount &&
          channelCountMode == other.channelCountMode &&
          channelInterpretation == other.channelInterpretation;
}

class ChannelConfigInner {
  final BigInt count;
  final ChannelCountMode countMode;
  final ChannelInterpretation interpretation;

  const ChannelConfigInner({
    required this.count,
    required this.countMode,
    required this.interpretation,
  });

  @override
  int get hashCode =>
      count.hashCode ^ countMode.hashCode ^ interpretation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelConfigInner &&
          runtimeType == other.runtimeType &&
          count == other.count &&
          countMode == other.countMode &&
          interpretation == other.interpretation;
}

/// How channels must be matched between the node's inputs and outputs.
enum ChannelCountMode {
  /// `computedNumberOfChannels` is the maximum of the number of channels of all connections to an
  /// input. In this mode channelCount is ignored.
  max,

  /// `computedNumberOfChannels` is determined as for "max" and then clamped to a maximum value of
  /// the given channelCount.
  clampedMax,

  /// `computedNumberOfChannels` is the exact value as specified by the channelCount.
  explicit,
  ;
}

/// The meaning of the channels, defining how audio up-mixing and down-mixing will happen.
enum ChannelInterpretation {
  speakers,
  discrete,
  ;
}
