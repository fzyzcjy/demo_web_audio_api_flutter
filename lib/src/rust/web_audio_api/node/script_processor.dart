// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../capacity.dart';
import '../periodic_wave.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `channel_config`, `clone`, `fmt`, `fmt`, `number_of_inputs`, `number_of_outputs`, `onmessage`, `process`, `registration`, `set_channel_count_mode`, `set_channel_count`
// These types are ignored because they are not used by any `pub` functions: `ScriptProcessorRenderer`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
@sealed
class ScriptProcessorNode extends RustOpaque {
  // Not to be used by end users
  ScriptProcessorNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ScriptProcessorNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_ScriptProcessorNode,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_ScriptProcessorNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ScriptProcessorNodePtr,
  );

  Future<BigInt> bufferSize() => RustLib.instance.api
          .webAudioApiNodeScriptProcessorScriptProcessorNodeBufferSize(
        that: this,
      );

  /// Unset the callback to run when the AudioProcessingEvent is dispatched
  Future<void> clearOnaudioprocess() => RustLib.instance.api
          .webAudioApiNodeScriptProcessorScriptProcessorNodeClearOnaudioprocess(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a `ScriptProcessorNode`
  ///
  /// # Arguments
  ///
  /// - `context` - Audio context in which the node will live
  /// - `options` - node options
  ///
  /// # Panics
  ///
  /// This function panics if:
  /// - `buffer_size` is not 256, 512, 1024, 2048, 4096, 8192, or 16384
  /// - the number of input and output channels are both zero
  /// - either of the channel counts exceed [`crate::MAX_CHANNELS`]
  static Future<ScriptProcessorNode> newInstance(
          {required C context, required ScriptProcessorOptions options}) =>
      RustLib.instance.api.webAudioApiNodeScriptProcessorScriptProcessorNodeNew(
          context: context, options: options);

  /// Register callback to run when the AudioProcessingEvent is dispatched
  ///
  /// The event handler processes audio from the input (if any) by accessing the audio data from
  /// the inputBuffer attribute. The audio data which is the result of the processing (or the
  /// synthesized data if there are no inputs) is then placed into the outputBuffer.
  ///
  /// The output buffer is shipped back to the render thread when the AudioProcessingEvent goes
  /// out of scope, so be sure not to store it somewhere.
  ///
  /// Only a single event handler is active at any time. Calling this method multiple times will
  /// override the previous event handler.
  Future<void> setOnaudioprocess({required F callback}) => RustLib.instance.api
      .webAudioApiNodeScriptProcessorScriptProcessorNodeSetOnaudioprocess(
          that: this, callback: callback);
}

/// Options for constructing an [`ScriptProcessorNode`]
class ScriptProcessorOptions {
  final BigInt bufferSize;
  final BigInt numberOfInputChannels;
  final BigInt numberOfOutputChannels;

  const ScriptProcessorOptions({
    required this.bufferSize,
    required this.numberOfInputChannels,
    required this.numberOfOutputChannels,
  });

  @override
  int get hashCode =>
      bufferSize.hashCode ^
      numberOfInputChannels.hashCode ^
      numberOfOutputChannels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScriptProcessorOptions &&
          runtimeType == other.runtimeType &&
          bufferSize == other.bufferSize &&
          numberOfInputChannels == other.numberOfInputChannels &&
          numberOfOutputChannels == other.numberOfOutputChannels;
}
