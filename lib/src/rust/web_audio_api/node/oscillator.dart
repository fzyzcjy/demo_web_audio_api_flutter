// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../param.dart';
import '../periodic_wave.dart';
import 'audio_node.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `assert_receiver_is_total_eq`, `before_drop`, `channel_config`, `clone`, `clone`, `clone`, `default`, `default`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `generate_custom`, `generate_sample`, `generate_sawtooth`, `generate_sine`, `generate_square`, `generate_triangle`, `get_phase_incr`, `number_of_inputs`, `number_of_outputs`, `onmessage`, `poly_blep`, `process`, `registration`, `start_at`, `start`, `stop_at`, `stop`, `unroll_phase`
// These types are ignored because they are not used by any `pub` functions: `OscillatorRenderer`, `Schedule`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
@sealed
class OscillatorNode extends RustOpaque {
  // Not to be used by end users
  OscillatorNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  OscillatorNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OscillatorNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OscillatorNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OscillatorNodePtr,
  );

  /// A-rate [`AudioParam`] that defines a transposition according to the
  /// frequency, expressed in cents.
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  Future<AudioParam> detune() =>
      RustLib.instance.api.webAudioApiNodeOscillatorOscillatorNodeDetune(
        that: this,
      );

  /// A-rate [`AudioParam`] that defines the fundamental frequency of the
  /// oscillator, expressed in Hz
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  Future<AudioParam> frequency() =>
      RustLib.instance.api.webAudioApiNodeOscillatorOscillatorNodeFrequency(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Returns an `OscillatorNode`
  ///
  /// # Arguments:
  ///
  /// * `context` - The `AudioContext`
  /// * `options` - The OscillatorOptions
  static Future<OscillatorNode> newInstance(
          {required C context, required OscillatorOptions options}) =>
      RustLib.instance.api.webAudioApiNodeOscillatorOscillatorNodeNew(
          context: context, options: options);

  /// Sets a `PeriodicWave` which describes a waveform to be used by the oscillator.
  ///
  /// Calling this sets the oscillator type to `custom`, once set to `custom`
  /// the oscillator cannot be reverted back to a standard waveform.
  Future<void> setPeriodicWave({required PeriodicWave periodicWave}) =>
      RustLib.instance.api
          .webAudioApiNodeOscillatorOscillatorNodeSetPeriodicWave(
              that: this, periodicWave: periodicWave);

  /// Set the oscillator type
  ///
  /// # Arguments
  ///
  /// * `type_` - oscillator type (sine, square, triangle, sawtooth)
  ///
  /// # Panics
  ///
  /// if `type_` is `OscillatorType::Custom`
  Future<void> setType({required OscillatorType type}) => RustLib.instance.api
      .webAudioApiNodeOscillatorOscillatorNodeSetType(that: this, type: type);

  /// Returns the oscillator type
  Future<OscillatorType> type() =>
      RustLib.instance.api.webAudioApiNodeOscillatorOscillatorNodeType(
        that: this,
      );
}

/// Options for constructing an [`OscillatorNode`]
class OscillatorOptions {
  /// The shape of the periodic waveform
  final OscillatorType type;

  /// The frequency of the fundamental frequency.
  final double frequency;

  /// A detuning value (in cents) which will offset the frequency by the given amount.
  final double detune;

  /// Optional custom waveform, if specified (set `type` to "custom")
  final PeriodicWave? periodicWave;

  /// channel config options
  final AudioNodeOptions audioNodeOptions;

  const OscillatorOptions({
    required this.type,
    required this.frequency,
    required this.detune,
    this.periodicWave,
    required this.audioNodeOptions,
  });

  @override
  int get hashCode =>
      type.hashCode ^
      frequency.hashCode ^
      detune.hashCode ^
      periodicWave.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OscillatorOptions &&
          runtimeType == other.runtimeType &&
          type == other.type &&
          frequency == other.frequency &&
          detune == other.detune &&
          periodicWave == other.periodicWave &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Type of the waveform rendered by an `OscillatorNode`
enum OscillatorType {
  /// Sine wave
  sine,

  /// Square wave
  square,

  /// Sawtooth wave
  sawtooth,

  /// Triangle wave
  triangle,

  /// type used when periodic_wave is specified
  custom,
  ;
}
