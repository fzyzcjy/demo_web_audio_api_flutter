// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `fmt`, `allocate`, `push`, `clone`, `fmt`, `make_mut`, `is_silent`, `add`, `silence`, `deref`, `deref_mut`, `as_ref`, `drop`, `clone`, `fmt`, `from`, `single_valued`, `set_single_valued`, `stereo_mut`, `mix`, `mix_inner`, `force_mono`, `modify_channels`, `add`, `all_channels_identical`
// These types are ignored because they are not used by any `pub` functions: `AllocInner`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Alloc>>
@sealed
class Alloc extends RustOpaque {
  // Not to be used by end users
  Alloc.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Alloc.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Alloc,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Alloc,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AllocPtr,
  );

  Future<AudioRenderQuantumChannel> silence() =>
      RustLib.instance.api.webAudioApiRenderQuantumAllocSilence(
        that: this,
      );

  static Future<Alloc> withCapacity({required BigInt n}) =>
      RustLib.instance.api.webAudioApiRenderQuantumAllocWithCapacity(n: n);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantum>>
@sealed
class AudioRenderQuantum extends RustOpaque {
  // Not to be used by end users
  AudioRenderQuantum.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AudioRenderQuantum.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AudioRenderQuantum,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AudioRenderQuantum,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioRenderQuantumPtr,
  );

  /// Get the samples from this specific channel.
  ///
  /// # Panics
  /// Panics if the index is greater than the available number of channels
  Future<AudioRenderQuantumChannel> channelData({required BigInt index}) =>
      RustLib.instance.api
          .webAudioApiRenderQuantumAudioRenderQuantumChannelData(
              that: this, index: index);

  /// Get the samples (mutable) from this specific channel.
  ///
  /// # Panics
  /// Panics if the index is greater than the available number of channels
  Future<AudioRenderQuantumChannel> channelDataMut({required BigInt index}) =>
      RustLib.instance.api
          .webAudioApiRenderQuantumAudioRenderQuantumChannelDataMut(
              that: this, index: index);

  /// Channel data as slice
  Future<AudioRenderQuantumChannel> channels() =>
      RustLib.instance.api.webAudioApiRenderQuantumAudioRenderQuantumChannels(
        that: this,
      );

  /// Channel data as slice (mutable)
  Future<AudioRenderQuantumChannel> channelsMut() => RustLib.instance.api
          .webAudioApiRenderQuantumAudioRenderQuantumChannelsMut(
        that: this,
      );

  /// `O(1)` check if this buffer is equal to the 'silence buffer'
  ///
  /// If this function returns false, it is still possible for all samples to be zero.
  Future<bool> isSilent() =>
      RustLib.instance.api.webAudioApiRenderQuantumAudioRenderQuantumIsSilent(
        that: this,
      );

  /// Convert this buffer to silence
  ///
  /// `O(1)` operation to convert this buffer to the 'silence buffer' which will enable some
  /// optimizations in the graph rendering.
  Future<void> makeSilent() =>
      RustLib.instance.api.webAudioApiRenderQuantumAudioRenderQuantumMakeSilent(
        that: this,
      );

  /// Number of channels in this AudioRenderQuantum
  Future<BigInt> numberOfChannels() => RustLib.instance.api
          .webAudioApiRenderQuantumAudioRenderQuantumNumberOfChannels(
        that: this,
      );

  /// Set number of channels in this AudioRenderQuantum
  ///
  /// Note: if the new number is higher than the previous, the new channels will be filled with
  /// garbage.
  ///
  /// # Panics
  ///
  /// This function will panic if the given number of channels is outside the [1, 32] range, 32
  /// being defined by the MAX_CHANNELS constant.
  Future<void> setNumberOfChannels({required BigInt n}) => RustLib.instance.api
      .webAudioApiRenderQuantumAudioRenderQuantumSetNumberOfChannels(
          that: this, n: n);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioRenderQuantumChannel>>
@sealed
class AudioRenderQuantumChannel extends RustOpaque {
  // Not to be used by end users
  AudioRenderQuantumChannel.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AudioRenderQuantumChannel.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_AudioRenderQuantumChannel,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioRenderQuantumChannel,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_AudioRenderQuantumChannelPtr,
  );
}
