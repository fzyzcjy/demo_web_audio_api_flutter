// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../web_audio_api.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `apply_curve`, `apply_mono_to_stereo_gain`, `apply_stereo_to_stereo_gain`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_valid_channel_count_mode`, `assert_valid_channel_count_mode`, `assert_valid_channel_count_mode`, `assert_valid_channel_count_mode`, `assert_valid_channel_count_mode`, `assert_valid_channel_count`, `assert_valid_channel_count`, `assert_valid_channel_count`, `assert_valid_channel_count`, `assert_valid_channel_count`, `assert_valid_channel_interpretation`, `assert_valid_cone_outer_gain`, `assert_valid_feedback_coefs`, `assert_valid_feedforward_coefs`, `assert_valid_number_of_channels`, `assert_valid_number_of_channels`, `before_drop`, `before_drop`, `before_drop`, `calculate_coefs`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `channel_config`, `check_ring_buffer_up_down_mix`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `complex`, `cone_gain`, `connect_from_output_to_input`, `count_mode`, `count`, `db_to_lin`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `default`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output`, `disconnect_dest`, `disconnect_output`, `disconnect`, `dist_gain`, `downsample_x2`, `downsample_x4`, `drop`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from_raw_parts`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `generate_custom`, `generate_sample`, `generate_sawtooth`, `generate_sine`, `generate_square`, `generate_triangle`, `get_computed_freq`, `get_phase_incr`, `get_playback_infos`, `get_stereo_gains`, `handle_control_message`, `has_side_effects`, `has_side_effects`, `inner`, `interpretation`, `into_channel_config`, `inverse`, `lin_to_db`, `load_hrtf_processor`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `next`, `normalize_buffer`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_inputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `number_of_outputs`, `onmessage`, `onmessage`, `onmessage`, `onmessage`, `onmessage`, `onmessage`, `onmessage`, `onmessage`, `poly_blep`, `precomputed_sine_table`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `process`, `real`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `registration`, `ring_buffer_mut`, `ring_buffer_mut`, `roll_zero`, `samples_out_mut`, `samples_out`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_interpretation`, `set_count_mode`, `set_count`, `set_interpretation`, `start_at`, `start_at`, `start_at`, `start`, `start`, `start`, `stop_at`, `stop_at`, `stop_at`, `stop`, `stop`, `stop`, `tail_time_samples`, `tail`, `unroll_phase`, `upsample_x2`, `upsample_x4`
// These functions are ignored because they have generic arguments: `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `new`, `set_onaudioprocess`
// These types are ignored because they are not used by any `pub` functions: `AnalyserOptions`, `AnalyserRenderer`, `AudioBufferRendererState`, `AudioBufferSourceOptions`, `AudioBufferSourceRenderer`, `AudioDestinationNodeStream`, `AudioNodeOptions`, `BiquadFilterOptions`, `BiquadFilterRenderer`, `ChannelConfigInner`, `ChannelConfig`, `ChannelCountMode`, `ChannelInterpretation`, `ChannelMergerNode`, `ChannelMergerOptions`, `ChannelMergerRenderer`, `ChannelSplitterNode`, `ChannelSplitterOptions`, `ChannelSplitterRenderer`, `Coefficients`, `ConstantSourceOptions`, `ConstantSourceRenderer`, `ControlMessage`, `ConvolverOptions`, `ConvolverRendererInner`, `ConvolverRenderer`, `DelayOptions`, `DelayReader`, `DelayWriter`, `DestinationRenderer`, `DynamicsCompressorOptions`, `DynamicsCompressorRenderer`, `Fft`, `GainOptions`, `GainRenderer`, `HrtfState`, `IIRFilterOptions`, `IirFilterRenderer`, `LoopState`, `MediaElementAudioSourceOptions`, `MediaStreamAudioSourceOptions`, `MediaStreamRenderer`, `MediaStreamTrackAudioSourceOptions`, `OscillatorOptions`, `OscillatorRenderer`, `PannerOptions`, `PannerRenderer`, `PlaybackInfo`, `RendererConfig`, `ResamplerConfig`, `Resampler`, `Schedule`, `ScriptProcessorOptions`, `ScriptProcessorRenderer`, `SpatialParams`, `StereoPannerOptions`, `StereoPannerRenderer`, `WaveShaperOptions`, `WaveShaperRenderer`
// These functions are ignored: `get_byte_frequency_data`, `get_byte_time_domain_data`, `get_float_frequency_data`, `get_float_time_domain_data`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>
@sealed
class AnalyserNode extends RustOpaque {
  // Not to be used by end users
  AnalyserNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AnalyserNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AnalyserNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AnalyserNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AnalyserNodePtr,
  );

  /// The size of the FFT used for frequency-domain analysis (in sample-frames)
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<BigInt> fftSize() =>
      RustLib.instance.api.webAudioApiNodeAnalyserNodeFftSize(
        that: this,
      );

  /// Number of bins in the FFT results, is half the FFT size
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<BigInt> frequencyBinCount() =>
      RustLib.instance.api.webAudioApiNodeAnalyserNodeFrequencyBinCount(
        that: this,
      );

  /// Maximum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -30.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> maxDecibels() =>
      RustLib.instance.api.webAudioApiNodeAnalyserNodeMaxDecibels(
        that: this,
      );

  /// Minimum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -100.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> minDecibels() =>
      RustLib.instance.api.webAudioApiNodeAnalyserNodeMinDecibels(
        that: this,
      );

  /// Set FFT size
  ///
  /// # Panics
  ///
  /// This function panics if fft_size is not a power of two or not in the range [32, 32768]
  Future<void> setFftSize({required BigInt fftSize}) => RustLib.instance.api
      .webAudioApiNodeAnalyserNodeSetFftSize(that: this, fftSize: fftSize);

  /// Set max decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than or equal
  /// to min decibels.
  Future<void> setMaxDecibels({required double value}) => RustLib.instance.api
      .webAudioApiNodeAnalyserNodeSetMaxDecibels(that: this, value: value);

  /// Set min decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value more than or equal
  /// to max decibels.
  Future<void> setMinDecibels({required double value}) => RustLib.instance.api
      .webAudioApiNodeAnalyserNodeSetMinDecibels(that: this, value: value);

  /// Set smoothing time constant
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than 0 or more than 1.
  Future<void> setSmoothingTimeConstant({required double value}) =>
      RustLib.instance.api.webAudioApiNodeAnalyserNodeSetSmoothingTimeConstant(
          that: this, value: value);

  /// Time averaging parameter with the last analysis frame.
  /// A value from 0 -> 1 where 0 represents no time averaging with the last
  /// analysis frame. The default value is 0.8.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> smoothingTimeConstant() =>
      RustLib.instance.api.webAudioApiNodeAnalyserNodeSmoothingTimeConstant(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>
@sealed
class AudioBufferSourceNode extends RustOpaque {
  // Not to be used by end users
  AudioBufferSourceNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AudioBufferSourceNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_AudioBufferSourceNode,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioBufferSourceNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioBufferSourceNodePtr,
  );

  /// Current buffer value (nullable)
  Future<AudioBuffer?> buffer() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeBuffer(
        that: this,
      );

  /// K-rate [`AudioParam`] that defines a pitch transposition of the file,
  /// expressed in cents
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  Future<void> detune() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeDetune(
        that: this,
      );

  /// Defines if the playback the [`AudioBuffer`] should be looped
  Future<bool> loop() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeLoop(
        that: this,
      );

  /// Defines the loop end point, in the time reference of the [`AudioBuffer`]
  Future<double> loopEnd() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeLoopEnd(
        that: this,
      );

  /// Defines the loop start point, in the time reference of the [`AudioBuffer`]
  Future<double> loopStart() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeLoopStart(
        that: this,
      );

  /// K-rate [`AudioParam`] that defines the speed at which the [`AudioBuffer`]
  /// will be played, e.g.:
  /// - `0.5` will play the file at half speed
  /// - `-1` will play the file in reverse
  ///
  /// Note that playback rate will also alter the pitch of the [`AudioBuffer`]
  Future<void> playbackRate() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodePlaybackRate(
        that: this,
      );

  /// Current playhead position in seconds within the [`AudioBuffer`].
  ///
  /// This value is updated at the end of each render quantum.
  ///
  /// Unofficial v2 API extension, not part of the spec yet.
  /// See also: <https://github.com/WebAudio/web-audio-api/issues/2397#issuecomment-709478405>
  Future<double> position() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodePosition(
        that: this,
      );

  /// Provide an [`AudioBuffer`] as the source of data to be played bask
  ///
  /// # Panics
  ///
  /// Panics if a buffer has already been given to the source (though `new` or through
  /// `set_buffer`)
  Future<void> setBuffer({required AudioBuffer audioBuffer}) =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeSetBuffer(
          that: this, audioBuffer: audioBuffer);

  Future<void> setLoop({required bool value}) => RustLib.instance.api
      .webAudioApiNodeAudioBufferSourceNodeSetLoop(that: this, value: value);

  Future<void> setLoopEnd({required double value}) => RustLib.instance.api
      .webAudioApiNodeAudioBufferSourceNodeSetLoopEnd(that: this, value: value);

  Future<void> setLoopStart({required double value}) =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceNodeSetLoopStart(
          that: this, value: value);

  /// Start the playback at the given time and with a given offset
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAtWithOffset(
          {required double start, required double offset}) =>
      RustLib.instance.api
          .webAudioApiNodeAudioBufferSourceNodeStartAtWithOffset(
              that: this, start: start, offset: offset);

  /// Start the playback at the given time, with a given offset, for a given duration
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAtWithOffsetAndDuration(
          {required double start,
          required double offset,
          required double duration}) =>
      RustLib.instance.api
          .webAudioApiNodeAudioBufferSourceNodeStartAtWithOffsetAndDuration(
              that: this, start: start, offset: offset, duration: duration);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>>
@sealed
class AudioDestinationNode extends RustOpaque {
  // Not to be used by end users
  AudioDestinationNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AudioDestinationNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_AudioDestinationNode,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioDestinationNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_AudioDestinationNodePtr,
  );

  /// The maximum number of channels that the channelCount attribute can be set to (the max
  /// number of channels that the hardware is capable of supporting).
  /// <https://www.w3.org/TR/webaudio/#dom-audiodestinationnode-maxchannelcount>
  Future<BigInt> maxChannelCount() =>
      RustLib.instance.api.webAudioApiNodeAudioDestinationNodeMaxChannelCount(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>
@sealed
class BiquadFilterNode extends RustOpaque {
  // Not to be used by end users
  BiquadFilterNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BiquadFilterNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BiquadFilterNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BiquadFilterNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_BiquadFilterNodePtr,
  );

  /// Returns the detune audio parameter
  Future<void> detune() =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterNodeDetune(
        that: this,
      );

  /// Returns the frequency audio parameter
  Future<void> frequency() =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterNodeFrequency(
        that: this,
      );

  /// Returns the gain audio parameter
  Future<void> gain() =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterNodeGain(
        that: this,
      );

  /// Returns the frequency response for the specified frequencies
  ///
  /// # Arguments
  ///
  /// * `frequency_hz` - frequencies for which frequency response of the filter should be calculated
  /// * `mag_response` - magnitude of the frequency response of the filter
  /// * `phase_response` - phase of the frequency response of the filter
  ///
  /// # Panics
  ///
  /// This function will panic if arguments' lengths don't match
  ///
  Future<void> getFrequencyResponse(
          {required List<double> frequencyHz,
          required F32 magResponse,
          required F32 phaseResponse}) =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterNodeGetFrequencyResponse(
          that: this,
          frequencyHz: frequencyHz,
          magResponse: magResponse,
          phaseResponse: phaseResponse);

  /// Returns the Q audio parameter
  Future<void> q() => RustLib.instance.api.webAudioApiNodeBiquadFilterNodeQ(
        that: this,
      );

  /// biquad filter type setter
  ///
  /// # Arguments
  ///
  /// * `type_` - the biquad filter type (lowpass, highpass,...)
  Future<void> setType({required BiquadFilterType type}) => RustLib.instance.api
      .webAudioApiNodeBiquadFilterNodeSetType(that: this, type: type);

  /// Returns the biquad filter type
  Future<BiquadFilterType> type() =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterNodeType(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>
@sealed
class ConstantSourceNode extends RustOpaque {
  // Not to be used by end users
  ConstantSourceNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ConstantSourceNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ConstantSourceNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ConstantSourceNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ConstantSourceNodePtr,
  );

  Future<void> offset() =>
      RustLib.instance.api.webAudioApiNodeConstantSourceNodeOffset(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>
@sealed
class ConvolverNode extends RustOpaque {
  // Not to be used by end users
  ConvolverNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ConvolverNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ConvolverNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ConvolverNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ConvolverNodePtr,
  );

  /// Get the current impulse response buffer
  Future<AudioBuffer?> buffer() =>
      RustLib.instance.api.webAudioApiNodeConvolverNodeBuffer(
        that: this,
      );

  /// Denotes if the response buffer will be scaled with an equal-power normalization
  Future<bool> normalize() =>
      RustLib.instance.api.webAudioApiNodeConvolverNodeNormalize(
        that: this,
      );

  /// Set or update the impulse response buffer
  ///
  /// # Panics
  ///
  /// Panics when the sample rate of the provided AudioBuffer differs from the audio context
  /// sample rate.
  Future<void> setBuffer({required AudioBuffer buffer}) => RustLib.instance.api
      .webAudioApiNodeConvolverNodeSetBuffer(that: this, buffer: buffer);

  /// Update the `normalize` setting. This will only have an effect when `set_buffer` is called.
  Future<void> setNormalize({required bool value}) => RustLib.instance.api
      .webAudioApiNodeConvolverNodeSetNormalize(that: this, value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>
@sealed
class DelayNode extends RustOpaque {
  // Not to be used by end users
  DelayNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DelayNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DelayNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DelayNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_DelayNodePtr,
  );

  /// A-rate [`AudioParam`] representing the amount of delay (in seconds) to apply.
  Future<void> delayTime() =>
      RustLib.instance.api.webAudioApiNodeDelayNodeDelayTime(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>
@sealed
class DynamicsCompressorNode extends RustOpaque {
  // Not to be used by end users
  DynamicsCompressorNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DynamicsCompressorNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_DynamicsCompressorNode,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_DynamicsCompressorNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_DynamicsCompressorNodePtr,
  );

  Future<void> attack() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorNodeAttack(
        that: this,
      );

  Future<void> knee() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorNodeKnee(
        that: this,
      );

  Future<void> ratio() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorNodeRatio(
        that: this,
      );

  Future<double> reduction() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorNodeReduction(
        that: this,
      );

  Future<void> release() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorNodeRelease(
        that: this,
      );

  Future<void> threshold() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorNodeThreshold(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>
@sealed
class GainNode extends RustOpaque {
  // Not to be used by end users
  GainNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  GainNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_GainNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_GainNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_GainNodePtr,
  );

  Future<void> gain() => RustLib.instance.api.webAudioApiNodeGainNodeGain(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>
@sealed
class IirFilterNode extends RustOpaque {
  // Not to be used by end users
  IirFilterNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  IirFilterNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_IirFilterNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_IirFilterNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_IirFilterNodePtr,
  );

  /// Returns the frequency response for the specified frequencies
  ///
  /// # Arguments
  ///
  /// - `frequency_hz` - frequencies for which frequency response of the filter should be calculated
  /// - `mag_response` - magnitude of the frequency response of the filter
  /// - `phase_response` - phase of the frequency response of the filter
  ///
  /// # Panics
  ///
  /// This function will panic if arguments' lengths don't match
  ///
  Future<void> getFrequencyResponse(
          {required List<double> frequencyHz,
          required F32 magResponse,
          required F32 phaseResponse}) =>
      RustLib.instance.api.webAudioApiNodeIirFilterNodeGetFrequencyResponse(
          that: this,
          frequencyHz: frequencyHz,
          magResponse: magResponse,
          phaseResponse: phaseResponse);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>>
@sealed
class MediaElementAudioSourceNode extends RustOpaque {
  // Not to be used by end users
  MediaElementAudioSourceNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MediaElementAudioSourceNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_MediaElementAudioSourceNode,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaElementAudioSourceNode,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaElementAudioSourceNodePtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>>
@sealed
class MediaStreamAudioDestinationNode extends RustOpaque {
  // Not to be used by end users
  MediaStreamAudioDestinationNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MediaStreamAudioDestinationNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_MediaStreamAudioDestinationNode,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaStreamAudioDestinationNode,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaStreamAudioDestinationNodePtr,
  );

  /// A [`MediaStream`] producing audio buffers with the same number of channels as the node
  /// itself
  Future<void> stream() =>
      RustLib.instance.api.webAudioApiNodeMediaStreamAudioDestinationNodeStream(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>>
@sealed
class MediaStreamAudioSourceNode extends RustOpaque {
  // Not to be used by end users
  MediaStreamAudioSourceNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MediaStreamAudioSourceNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_MediaStreamAudioSourceNode,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaStreamAudioSourceNode,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaStreamAudioSourceNodePtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceNode>>
@sealed
class MediaStreamTrackAudioSourceNode extends RustOpaque {
  // Not to be used by end users
  MediaStreamTrackAudioSourceNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MediaStreamTrackAudioSourceNode.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_MediaStreamTrackAudioSourceNode,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceNode,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_MediaStreamTrackAudioSourceNodePtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
@sealed
class OscillatorNode extends RustOpaque {
  // Not to be used by end users
  OscillatorNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  OscillatorNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OscillatorNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OscillatorNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OscillatorNodePtr,
  );

  /// A-rate [`AudioParam`] that defines a transposition according to the
  /// frequency, expressed in cents.
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  Future<void> detune() =>
      RustLib.instance.api.webAudioApiNodeOscillatorNodeDetune(
        that: this,
      );

  /// A-rate [`AudioParam`] that defines the fundamental frequency of the
  /// oscillator, expressed in Hz
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  Future<void> frequency() =>
      RustLib.instance.api.webAudioApiNodeOscillatorNodeFrequency(
        that: this,
      );

  /// Sets a `PeriodicWave` which describes a waveform to be used by the oscillator.
  ///
  /// Calling this sets the oscillator type to `custom`, once set to `custom`
  /// the oscillator cannot be reverted back to a standard waveform.
  Future<void> setPeriodicWave({required PeriodicWave periodicWave}) =>
      RustLib.instance.api.webAudioApiNodeOscillatorNodeSetPeriodicWave(
          that: this, periodicWave: periodicWave);

  /// Set the oscillator type
  ///
  /// # Arguments
  ///
  /// * `type_` - oscillator type (sine, square, triangle, sawtooth)
  ///
  /// # Panics
  ///
  /// if `type_` is `OscillatorType::Custom`
  Future<void> setType({required OscillatorType type}) => RustLib.instance.api
      .webAudioApiNodeOscillatorNodeSetType(that: this, type: type);

  /// Returns the oscillator type
  Future<OscillatorType> type() =>
      RustLib.instance.api.webAudioApiNodeOscillatorNodeType(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>
@sealed
class PannerNode extends RustOpaque {
  // Not to be used by end users
  PannerNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PannerNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PannerNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PannerNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PannerNodePtr,
  );

  Future<double> coneInnerAngle() =>
      RustLib.instance.api.webAudioApiNodePannerNodeConeInnerAngle(
        that: this,
      );

  Future<double> coneOuterAngle() =>
      RustLib.instance.api.webAudioApiNodePannerNodeConeOuterAngle(
        that: this,
      );

  Future<double> coneOuterGain() =>
      RustLib.instance.api.webAudioApiNodePannerNodeConeOuterGain(
        that: this,
      );

  Future<DistanceModelType> distanceModel() =>
      RustLib.instance.api.webAudioApiNodePannerNodeDistanceModel(
        that: this,
      );

  Future<double> maxDistance() =>
      RustLib.instance.api.webAudioApiNodePannerNodeMaxDistance(
        that: this,
      );

  Future<void> orientationX() =>
      RustLib.instance.api.webAudioApiNodePannerNodeOrientationX(
        that: this,
      );

  Future<void> orientationY() =>
      RustLib.instance.api.webAudioApiNodePannerNodeOrientationY(
        that: this,
      );

  Future<void> orientationZ() =>
      RustLib.instance.api.webAudioApiNodePannerNodeOrientationZ(
        that: this,
      );

  Future<PanningModelType> panningModel() =>
      RustLib.instance.api.webAudioApiNodePannerNodePanningModel(
        that: this,
      );

  Future<void> positionX() =>
      RustLib.instance.api.webAudioApiNodePannerNodePositionX(
        that: this,
      );

  Future<void> positionY() =>
      RustLib.instance.api.webAudioApiNodePannerNodePositionY(
        that: this,
      );

  Future<void> positionZ() =>
      RustLib.instance.api.webAudioApiNodePannerNodePositionZ(
        that: this,
      );

  Future<double> refDistance() =>
      RustLib.instance.api.webAudioApiNodePannerNodeRefDistance(
        that: this,
      );

  Future<double> rolloffFactor() =>
      RustLib.instance.api.webAudioApiNodePannerNodeRolloffFactor(
        that: this,
      );

  Future<void> setConeInnerAngle({required double value}) =>
      RustLib.instance.api
          .webAudioApiNodePannerNodeSetConeInnerAngle(that: this, value: value);

  Future<void> setConeOuterAngle({required double value}) =>
      RustLib.instance.api
          .webAudioApiNodePannerNodeSetConeOuterAngle(that: this, value: value);

  /// Set the coneOuterGain attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is not in the range [0, 1]
  Future<void> setConeOuterGain({required double value}) => RustLib.instance.api
      .webAudioApiNodePannerNodeSetConeOuterGain(that: this, value: value);

  Future<void> setDistanceModel({required DistanceModelType value}) =>
      RustLib.instance.api
          .webAudioApiNodePannerNodeSetDistanceModel(that: this, value: value);

  /// Set the maxDistance attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setMaxDistance({required double value}) => RustLib.instance.api
      .webAudioApiNodePannerNodeSetMaxDistance(that: this, value: value);

  Future<void> setOrientation(
          {required double x, required double y, required double z}) =>
      RustLib.instance.api.webAudioApiNodePannerNodeSetOrientation(
          that: this, x: x, y: y, z: z);

  Future<void> setPanningModel({required PanningModelType value}) =>
      RustLib.instance.api
          .webAudioApiNodePannerNodeSetPanningModel(that: this, value: value);

  Future<void> setPosition(
          {required double x, required double y, required double z}) =>
      RustLib.instance.api
          .webAudioApiNodePannerNodeSetPosition(that: this, x: x, y: y, z: z);

  /// Set the refDistance attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setRefDistance({required double value}) => RustLib.instance.api
      .webAudioApiNodePannerNodeSetRefDistance(that: this, value: value);

  /// Set the rolloffFactor attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setRolloffFactor({required double value}) => RustLib.instance.api
      .webAudioApiNodePannerNodeSetRolloffFactor(that: this, value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
@sealed
class ScriptProcessorNode extends RustOpaque {
  // Not to be used by end users
  ScriptProcessorNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ScriptProcessorNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_ScriptProcessorNode,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_ScriptProcessorNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ScriptProcessorNodePtr,
  );

  Future<BigInt> bufferSize() =>
      RustLib.instance.api.webAudioApiNodeScriptProcessorNodeBufferSize(
        that: this,
      );

  /// Unset the callback to run when the AudioProcessingEvent is dispatched
  Future<void> clearOnaudioprocess() => RustLib.instance.api
          .webAudioApiNodeScriptProcessorNodeClearOnaudioprocess(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>
@sealed
class StereoPannerNode extends RustOpaque {
  // Not to be used by end users
  StereoPannerNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  StereoPannerNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_StereoPannerNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_StereoPannerNode,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_StereoPannerNodePtr,
  );

  /// Returns the pan audio parameter
  Future<void> pan() => RustLib.instance.api.webAudioApiNodeStereoPannerNodePan(
        that: this,
      );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>
@sealed
class WaveShaperNode extends RustOpaque {
  // Not to be used by end users
  WaveShaperNode.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  WaveShaperNode.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_WaveShaperNode,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_WaveShaperNode,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WaveShaperNodePtr,
  );

  /// Returns the distortion curve
  Future<F32?> curve() =>
      RustLib.instance.api.webAudioApiNodeWaveShaperNodeCurve(
        that: this,
      );

  /// Returns the `oversample` faactor of this node
  Future<OverSampleType> oversample() =>
      RustLib.instance.api.webAudioApiNodeWaveShaperNodeOversample(
        that: this,
      );

  /// Set the distortion `curve` of this node
  ///
  /// # Arguments
  ///
  /// * `curve` - the desired distortion `curve`
  ///
  /// # Panics
  ///
  /// Panics if a curve has already been given to the source (though `new` or through
  /// `set_curve`)
  Future<void> setCurve({required List<double> curve}) => RustLib.instance.api
      .webAudioApiNodeWaveShaperNodeSetCurve(that: this, curve: curve);

  /// set the `oversample` factor of this node
  ///
  /// # Arguments
  ///
  /// * `oversample` - the desired `OversampleType` variant
  Future<void> setOversample({required OverSampleType oversample}) =>
      RustLib.instance.api.webAudioApiNodeWaveShaperNodeSetOversample(
          that: this, oversample: oversample);
}

/// Biquad filter types
enum BiquadFilterType {
  /// Allows frequencies below the cutoff frequency to pass through and
  /// attenuates frequencies above the cutoff. (12dB/oct rolloff)
  lowpass,

  /// Frequencies above the cutoff frequency are passed through, but
  /// frequencies below the cutoff are attenuated. (12dB/oct rolloff)
  highpass,

  /// Allows a range of frequencies to pass through and attenuates the
  /// frequencies below and above this frequency range.
  bandpass,

  /// Allows all frequencies through, except for a set of frequencies.
  notch,

  /// Allows all frequencies through, but changes the phase relationship
  /// between the various frequencies.
  allpass,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// a range of frequencies.
  peaking,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// the lower frequencies.
  lowshelf,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// the higher frequencies.
  highshelf,
  ;
}

/// Algorithm to reduce the volume of an audio source as it moves away from the listener
enum DistanceModelType {
  linear,
  inverse,
  exponential,
  ;
}

/// Type of the waveform rendered by an `OscillatorNode`
enum OscillatorType {
  /// Sine wave
  sine,

  /// Square wave
  square,

  /// Sawtooth wave
  sawtooth,

  /// Triangle wave
  triangle,

  /// type used when periodic_wave is specified
  custom,
  ;
}

/// enumerates the oversampling rate available for `WaveShaperNode`
enum OverSampleType {
  /// No oversampling is applied
  none,

  /// Oversampled by a factor of 2
  x2,

  /// Oversampled by a factor of 4
  x4,
  ;
}

/// Spatialization algorithm used to position the audio in 3D space
enum PanningModelType {
  equalPower,
  hrtf,
  ;
}
